// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"gitlab.jiguang.dev/pos-dine/dine/domain"
	"gitlab.jiguang.dev/pos-dine/dine/ent/refundorder"
)

// RefundOrder is the model entity for the RefundOrder schema.
type RefundOrder struct {
	config `json:"-"`
	// ID of the ent.
	// UUID as primary key
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// 删除时间
	DeletedAt int64 `json:"deleted_at,omitempty"`
	// 品牌商ID
	MerchantID uuid.UUID `json:"merchant_id,omitempty"`
	// 门店ID
	StoreID uuid.UUID `json:"store_id,omitempty"`
	// 营业日
	BusinessDate string `json:"business_date,omitempty"`
	// 班次号
	ShiftNo string `json:"shift_no,omitempty"`
	// 退款单号
	RefundNo string `json:"refund_no,omitempty"`
	// 原订单ID
	OriginOrderID uuid.UUID `json:"origin_order_id,omitempty"`
	// 原订单号
	OriginOrderNo string `json:"origin_order_no,omitempty"`
	// 原订单支付时间
	OriginPaidAt *time.Time `json:"origin_paid_at,omitempty"`
	// 原订单实付金额
	OriginAmountPaid *decimal.Decimal `json:"origin_amount_paid,omitempty"`
	// 退款类型
	RefundType domain.RefundType `json:"refund_type,omitempty"`
	// 退款状态
	RefundStatus domain.RefundStatus `json:"refund_status,omitempty"`
	// 退款原因代码
	RefundReasonCode string `json:"refund_reason_code,omitempty"`
	// 退款原因描述
	RefundReason string `json:"refund_reason,omitempty"`
	// 退款操作人ID
	RefundedBy uuid.UUID `json:"refunded_by,omitempty"`
	// 退款操作人名称
	RefundedByName string `json:"refunded_by_name,omitempty"`
	// 审批人ID
	ApprovedBy uuid.UUID `json:"approved_by,omitempty"`
	// 审批人名称
	ApprovedByName string `json:"approved_by_name,omitempty"`
	// 审批时间
	ApprovedAt *time.Time `json:"approved_at,omitempty"`
	// 退款完成时间
	RefundedAt *time.Time `json:"refunded_at,omitempty"`
	// 门店信息
	Store domain.OrderStore `json:"store,omitempty"`
	// 退款渠道
	Channel domain.Channel `json:"channel,omitempty"`
	// POS终端信息
	Pos domain.OrderPOS `json:"pos,omitempty"`
	// 收银员信息
	Cashier domain.OrderCashier `json:"cashier,omitempty"`
	// 退款金额明细
	RefundAmount domain.RefundAmount `json:"refund_amount,omitempty"`
	// 退款支付记录
	RefundPayments []domain.RefundPayment `json:"refund_payments,omitempty"`
	// 备注
	Remark string `json:"remark,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the RefundOrderQuery when eager-loading is set.
	Edges        RefundOrderEdges `json:"edges"`
	selectValues sql.SelectValues
}

// RefundOrderEdges holds the relations/edges for other nodes in the graph.
type RefundOrderEdges struct {
	// 退款商品明细
	RefundProducts []*RefundOrderProduct `json:"refund_products,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// RefundProductsOrErr returns the RefundProducts value or an error if the edge
// was not loaded in eager-loading.
func (e RefundOrderEdges) RefundProductsOrErr() ([]*RefundOrderProduct, error) {
	if e.loadedTypes[0] {
		return e.RefundProducts, nil
	}
	return nil, &NotLoadedError{edge: "refund_products"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*RefundOrder) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case refundorder.FieldOriginAmountPaid:
			values[i] = &sql.NullScanner{S: new(decimal.Decimal)}
		case refundorder.FieldStore, refundorder.FieldPos, refundorder.FieldCashier, refundorder.FieldRefundAmount, refundorder.FieldRefundPayments:
			values[i] = new([]byte)
		case refundorder.FieldDeletedAt:
			values[i] = new(sql.NullInt64)
		case refundorder.FieldBusinessDate, refundorder.FieldShiftNo, refundorder.FieldRefundNo, refundorder.FieldOriginOrderNo, refundorder.FieldRefundType, refundorder.FieldRefundStatus, refundorder.FieldRefundReasonCode, refundorder.FieldRefundReason, refundorder.FieldRefundedByName, refundorder.FieldApprovedByName, refundorder.FieldChannel, refundorder.FieldRemark:
			values[i] = new(sql.NullString)
		case refundorder.FieldCreatedAt, refundorder.FieldUpdatedAt, refundorder.FieldOriginPaidAt, refundorder.FieldApprovedAt, refundorder.FieldRefundedAt:
			values[i] = new(sql.NullTime)
		case refundorder.FieldID, refundorder.FieldMerchantID, refundorder.FieldStoreID, refundorder.FieldOriginOrderID, refundorder.FieldRefundedBy, refundorder.FieldApprovedBy:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the RefundOrder fields.
func (ro *RefundOrder) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case refundorder.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				ro.ID = *value
			}
		case refundorder.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				ro.CreatedAt = value.Time
			}
		case refundorder.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				ro.UpdatedAt = value.Time
			}
		case refundorder.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				ro.DeletedAt = value.Int64
			}
		case refundorder.FieldMerchantID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field merchant_id", values[i])
			} else if value != nil {
				ro.MerchantID = *value
			}
		case refundorder.FieldStoreID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field store_id", values[i])
			} else if value != nil {
				ro.StoreID = *value
			}
		case refundorder.FieldBusinessDate:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field business_date", values[i])
			} else if value.Valid {
				ro.BusinessDate = value.String
			}
		case refundorder.FieldShiftNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field shift_no", values[i])
			} else if value.Valid {
				ro.ShiftNo = value.String
			}
		case refundorder.FieldRefundNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refund_no", values[i])
			} else if value.Valid {
				ro.RefundNo = value.String
			}
		case refundorder.FieldOriginOrderID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field origin_order_id", values[i])
			} else if value != nil {
				ro.OriginOrderID = *value
			}
		case refundorder.FieldOriginOrderNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field origin_order_no", values[i])
			} else if value.Valid {
				ro.OriginOrderNo = value.String
			}
		case refundorder.FieldOriginPaidAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field origin_paid_at", values[i])
			} else if value.Valid {
				ro.OriginPaidAt = new(time.Time)
				*ro.OriginPaidAt = value.Time
			}
		case refundorder.FieldOriginAmountPaid:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field origin_amount_paid", values[i])
			} else if value.Valid {
				ro.OriginAmountPaid = new(decimal.Decimal)
				*ro.OriginAmountPaid = *value.S.(*decimal.Decimal)
			}
		case refundorder.FieldRefundType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refund_type", values[i])
			} else if value.Valid {
				ro.RefundType = domain.RefundType(value.String)
			}
		case refundorder.FieldRefundStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refund_status", values[i])
			} else if value.Valid {
				ro.RefundStatus = domain.RefundStatus(value.String)
			}
		case refundorder.FieldRefundReasonCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refund_reason_code", values[i])
			} else if value.Valid {
				ro.RefundReasonCode = value.String
			}
		case refundorder.FieldRefundReason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refund_reason", values[i])
			} else if value.Valid {
				ro.RefundReason = value.String
			}
		case refundorder.FieldRefundedBy:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field refunded_by", values[i])
			} else if value != nil {
				ro.RefundedBy = *value
			}
		case refundorder.FieldRefundedByName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refunded_by_name", values[i])
			} else if value.Valid {
				ro.RefundedByName = value.String
			}
		case refundorder.FieldApprovedBy:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field approved_by", values[i])
			} else if value != nil {
				ro.ApprovedBy = *value
			}
		case refundorder.FieldApprovedByName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field approved_by_name", values[i])
			} else if value.Valid {
				ro.ApprovedByName = value.String
			}
		case refundorder.FieldApprovedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field approved_at", values[i])
			} else if value.Valid {
				ro.ApprovedAt = new(time.Time)
				*ro.ApprovedAt = value.Time
			}
		case refundorder.FieldRefundedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field refunded_at", values[i])
			} else if value.Valid {
				ro.RefundedAt = new(time.Time)
				*ro.RefundedAt = value.Time
			}
		case refundorder.FieldStore:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field store", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ro.Store); err != nil {
					return fmt.Errorf("unmarshal field store: %w", err)
				}
			}
		case refundorder.FieldChannel:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field channel", values[i])
			} else if value.Valid {
				ro.Channel = domain.Channel(value.String)
			}
		case refundorder.FieldPos:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field pos", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ro.Pos); err != nil {
					return fmt.Errorf("unmarshal field pos: %w", err)
				}
			}
		case refundorder.FieldCashier:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field cashier", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ro.Cashier); err != nil {
					return fmt.Errorf("unmarshal field cashier: %w", err)
				}
			}
		case refundorder.FieldRefundAmount:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field refund_amount", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ro.RefundAmount); err != nil {
					return fmt.Errorf("unmarshal field refund_amount: %w", err)
				}
			}
		case refundorder.FieldRefundPayments:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field refund_payments", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ro.RefundPayments); err != nil {
					return fmt.Errorf("unmarshal field refund_payments: %w", err)
				}
			}
		case refundorder.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				ro.Remark = value.String
			}
		default:
			ro.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the RefundOrder.
// This includes values selected through modifiers, order, etc.
func (ro *RefundOrder) Value(name string) (ent.Value, error) {
	return ro.selectValues.Get(name)
}

// QueryRefundProducts queries the "refund_products" edge of the RefundOrder entity.
func (ro *RefundOrder) QueryRefundProducts() *RefundOrderProductQuery {
	return NewRefundOrderClient(ro.config).QueryRefundProducts(ro)
}

// Update returns a builder for updating this RefundOrder.
// Note that you need to call RefundOrder.Unwrap() before calling this method if this RefundOrder
// was returned from a transaction, and the transaction was committed or rolled back.
func (ro *RefundOrder) Update() *RefundOrderUpdateOne {
	return NewRefundOrderClient(ro.config).UpdateOne(ro)
}

// Unwrap unwraps the RefundOrder entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ro *RefundOrder) Unwrap() *RefundOrder {
	_tx, ok := ro.config.driver.(*txDriver)
	if !ok {
		panic("ent: RefundOrder is not a transactional entity")
	}
	ro.config.driver = _tx.drv
	return ro
}

// String implements the fmt.Stringer.
func (ro *RefundOrder) String() string {
	var builder strings.Builder
	builder.WriteString("RefundOrder(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ro.ID))
	builder.WriteString("created_at=")
	builder.WriteString(ro.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(ro.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(fmt.Sprintf("%v", ro.DeletedAt))
	builder.WriteString(", ")
	builder.WriteString("merchant_id=")
	builder.WriteString(fmt.Sprintf("%v", ro.MerchantID))
	builder.WriteString(", ")
	builder.WriteString("store_id=")
	builder.WriteString(fmt.Sprintf("%v", ro.StoreID))
	builder.WriteString(", ")
	builder.WriteString("business_date=")
	builder.WriteString(ro.BusinessDate)
	builder.WriteString(", ")
	builder.WriteString("shift_no=")
	builder.WriteString(ro.ShiftNo)
	builder.WriteString(", ")
	builder.WriteString("refund_no=")
	builder.WriteString(ro.RefundNo)
	builder.WriteString(", ")
	builder.WriteString("origin_order_id=")
	builder.WriteString(fmt.Sprintf("%v", ro.OriginOrderID))
	builder.WriteString(", ")
	builder.WriteString("origin_order_no=")
	builder.WriteString(ro.OriginOrderNo)
	builder.WriteString(", ")
	if v := ro.OriginPaidAt; v != nil {
		builder.WriteString("origin_paid_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := ro.OriginAmountPaid; v != nil {
		builder.WriteString("origin_amount_paid=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("refund_type=")
	builder.WriteString(fmt.Sprintf("%v", ro.RefundType))
	builder.WriteString(", ")
	builder.WriteString("refund_status=")
	builder.WriteString(fmt.Sprintf("%v", ro.RefundStatus))
	builder.WriteString(", ")
	builder.WriteString("refund_reason_code=")
	builder.WriteString(ro.RefundReasonCode)
	builder.WriteString(", ")
	builder.WriteString("refund_reason=")
	builder.WriteString(ro.RefundReason)
	builder.WriteString(", ")
	builder.WriteString("refunded_by=")
	builder.WriteString(fmt.Sprintf("%v", ro.RefundedBy))
	builder.WriteString(", ")
	builder.WriteString("refunded_by_name=")
	builder.WriteString(ro.RefundedByName)
	builder.WriteString(", ")
	builder.WriteString("approved_by=")
	builder.WriteString(fmt.Sprintf("%v", ro.ApprovedBy))
	builder.WriteString(", ")
	builder.WriteString("approved_by_name=")
	builder.WriteString(ro.ApprovedByName)
	builder.WriteString(", ")
	if v := ro.ApprovedAt; v != nil {
		builder.WriteString("approved_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := ro.RefundedAt; v != nil {
		builder.WriteString("refunded_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("store=")
	builder.WriteString(fmt.Sprintf("%v", ro.Store))
	builder.WriteString(", ")
	builder.WriteString("channel=")
	builder.WriteString(fmt.Sprintf("%v", ro.Channel))
	builder.WriteString(", ")
	builder.WriteString("pos=")
	builder.WriteString(fmt.Sprintf("%v", ro.Pos))
	builder.WriteString(", ")
	builder.WriteString("cashier=")
	builder.WriteString(fmt.Sprintf("%v", ro.Cashier))
	builder.WriteString(", ")
	builder.WriteString("refund_amount=")
	builder.WriteString(fmt.Sprintf("%v", ro.RefundAmount))
	builder.WriteString(", ")
	builder.WriteString("refund_payments=")
	builder.WriteString(fmt.Sprintf("%v", ro.RefundPayments))
	builder.WriteString(", ")
	builder.WriteString("remark=")
	builder.WriteString(ro.Remark)
	builder.WriteByte(')')
	return builder.String()
}

// RefundOrders is a parsable slice of RefundOrder.
type RefundOrders []*RefundOrder
