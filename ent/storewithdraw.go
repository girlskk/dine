// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
	"gitlab.jiguang.dev/pos-dine/dine/domain"
	"gitlab.jiguang.dev/pos-dine/dine/ent/store"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storewithdraw"
)

// StoreWithdraw is the model entity for the StoreWithdraw schema.
type StoreWithdraw struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// 删除时间
	DeletedAt int64 `json:"deleted_at,omitempty"`
	// 门店ID
	StoreID int `json:"store_id,omitempty"`
	// 门店名称
	StoreName string `json:"store_name,omitempty"`
	// 单据编号
	No string `json:"no,omitempty"`
	// 提现金额（原始申请金额）
	Amount decimal.Decimal `json:"amount,omitempty"`
	// 积分提现费率
	PointWithdrawalRate decimal.Decimal `json:"point_withdrawal_rate,omitempty"`
	// 实际到账金额（扣除平台佣金）
	ActualAmount decimal.Decimal `json:"actual_amount,omitempty"`
	// 账户类型：public-对公 private-对私
	AccountType domain.AccountType `json:"account_type,omitempty"`
	// 银行账号
	BankAccount string `json:"bank_account,omitempty"`
	// 银行卡名称（对公时为公司名称）
	BankCardName string `json:"bank_card_name,omitempty"`
	// 银行名称
	BankName string `json:"bank_name,omitempty"`
	// 开户支行
	BankBranch string `json:"bank_branch,omitempty"`
	// 开票金额
	InvoiceAmount decimal.Decimal `json:"invoice_amount,omitempty"`
	// 提现状态：1-待审核 2-已审核 3-已驳回
	Status domain.StoreWithdrawStatus `json:"status,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the StoreWithdrawQuery when eager-loading is set.
	Edges        StoreWithdrawEdges `json:"edges"`
	selectValues sql.SelectValues
}

// StoreWithdrawEdges holds the relations/edges for other nodes in the graph.
type StoreWithdrawEdges struct {
	// Store holds the value of the store edge.
	Store *Store `json:"store,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// StoreOrErr returns the Store value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e StoreWithdrawEdges) StoreOrErr() (*Store, error) {
	if e.Store != nil {
		return e.Store, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: store.Label}
	}
	return nil, &NotLoadedError{edge: "store"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*StoreWithdraw) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case storewithdraw.FieldAmount, storewithdraw.FieldPointWithdrawalRate, storewithdraw.FieldActualAmount, storewithdraw.FieldInvoiceAmount:
			values[i] = new(decimal.Decimal)
		case storewithdraw.FieldID, storewithdraw.FieldDeletedAt, storewithdraw.FieldStoreID, storewithdraw.FieldStatus:
			values[i] = new(sql.NullInt64)
		case storewithdraw.FieldStoreName, storewithdraw.FieldNo, storewithdraw.FieldAccountType, storewithdraw.FieldBankAccount, storewithdraw.FieldBankCardName, storewithdraw.FieldBankName, storewithdraw.FieldBankBranch:
			values[i] = new(sql.NullString)
		case storewithdraw.FieldCreatedAt, storewithdraw.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the StoreWithdraw fields.
func (sw *StoreWithdraw) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case storewithdraw.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			sw.ID = int(value.Int64)
		case storewithdraw.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				sw.CreatedAt = value.Time
			}
		case storewithdraw.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				sw.UpdatedAt = value.Time
			}
		case storewithdraw.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				sw.DeletedAt = value.Int64
			}
		case storewithdraw.FieldStoreID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field store_id", values[i])
			} else if value.Valid {
				sw.StoreID = int(value.Int64)
			}
		case storewithdraw.FieldStoreName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field store_name", values[i])
			} else if value.Valid {
				sw.StoreName = value.String
			}
		case storewithdraw.FieldNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field no", values[i])
			} else if value.Valid {
				sw.No = value.String
			}
		case storewithdraw.FieldAmount:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field amount", values[i])
			} else if value != nil {
				sw.Amount = *value
			}
		case storewithdraw.FieldPointWithdrawalRate:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field point_withdrawal_rate", values[i])
			} else if value != nil {
				sw.PointWithdrawalRate = *value
			}
		case storewithdraw.FieldActualAmount:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field actual_amount", values[i])
			} else if value != nil {
				sw.ActualAmount = *value
			}
		case storewithdraw.FieldAccountType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field account_type", values[i])
			} else if value.Valid {
				sw.AccountType = domain.AccountType(value.String)
			}
		case storewithdraw.FieldBankAccount:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bank_account", values[i])
			} else if value.Valid {
				sw.BankAccount = value.String
			}
		case storewithdraw.FieldBankCardName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bank_card_name", values[i])
			} else if value.Valid {
				sw.BankCardName = value.String
			}
		case storewithdraw.FieldBankName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bank_name", values[i])
			} else if value.Valid {
				sw.BankName = value.String
			}
		case storewithdraw.FieldBankBranch:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bank_branch", values[i])
			} else if value.Valid {
				sw.BankBranch = value.String
			}
		case storewithdraw.FieldInvoiceAmount:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field invoice_amount", values[i])
			} else if value != nil {
				sw.InvoiceAmount = *value
			}
		case storewithdraw.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				sw.Status = domain.StoreWithdrawStatus(value.Int64)
			}
		default:
			sw.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the StoreWithdraw.
// This includes values selected through modifiers, order, etc.
func (sw *StoreWithdraw) Value(name string) (ent.Value, error) {
	return sw.selectValues.Get(name)
}

// QueryStore queries the "store" edge of the StoreWithdraw entity.
func (sw *StoreWithdraw) QueryStore() *StoreQuery {
	return NewStoreWithdrawClient(sw.config).QueryStore(sw)
}

// Update returns a builder for updating this StoreWithdraw.
// Note that you need to call StoreWithdraw.Unwrap() before calling this method if this StoreWithdraw
// was returned from a transaction, and the transaction was committed or rolled back.
func (sw *StoreWithdraw) Update() *StoreWithdrawUpdateOne {
	return NewStoreWithdrawClient(sw.config).UpdateOne(sw)
}

// Unwrap unwraps the StoreWithdraw entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (sw *StoreWithdraw) Unwrap() *StoreWithdraw {
	_tx, ok := sw.config.driver.(*txDriver)
	if !ok {
		panic("ent: StoreWithdraw is not a transactional entity")
	}
	sw.config.driver = _tx.drv
	return sw
}

// String implements the fmt.Stringer.
func (sw *StoreWithdraw) String() string {
	var builder strings.Builder
	builder.WriteString("StoreWithdraw(")
	builder.WriteString(fmt.Sprintf("id=%v, ", sw.ID))
	builder.WriteString("created_at=")
	builder.WriteString(sw.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(sw.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(fmt.Sprintf("%v", sw.DeletedAt))
	builder.WriteString(", ")
	builder.WriteString("store_id=")
	builder.WriteString(fmt.Sprintf("%v", sw.StoreID))
	builder.WriteString(", ")
	builder.WriteString("store_name=")
	builder.WriteString(sw.StoreName)
	builder.WriteString(", ")
	builder.WriteString("no=")
	builder.WriteString(sw.No)
	builder.WriteString(", ")
	builder.WriteString("amount=")
	builder.WriteString(fmt.Sprintf("%v", sw.Amount))
	builder.WriteString(", ")
	builder.WriteString("point_withdrawal_rate=")
	builder.WriteString(fmt.Sprintf("%v", sw.PointWithdrawalRate))
	builder.WriteString(", ")
	builder.WriteString("actual_amount=")
	builder.WriteString(fmt.Sprintf("%v", sw.ActualAmount))
	builder.WriteString(", ")
	builder.WriteString("account_type=")
	builder.WriteString(fmt.Sprintf("%v", sw.AccountType))
	builder.WriteString(", ")
	builder.WriteString("bank_account=")
	builder.WriteString(sw.BankAccount)
	builder.WriteString(", ")
	builder.WriteString("bank_card_name=")
	builder.WriteString(sw.BankCardName)
	builder.WriteString(", ")
	builder.WriteString("bank_name=")
	builder.WriteString(sw.BankName)
	builder.WriteString(", ")
	builder.WriteString("bank_branch=")
	builder.WriteString(sw.BankBranch)
	builder.WriteString(", ")
	builder.WriteString("invoice_amount=")
	builder.WriteString(fmt.Sprintf("%v", sw.InvoiceAmount))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", sw.Status))
	builder.WriteByte(')')
	return builder.String()
}

// StoreWithdraws is a parsable slice of StoreWithdraw.
type StoreWithdraws []*StoreWithdraw
