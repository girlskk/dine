// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
	"gitlab.jiguang.dev/pos-dine/dine/domain"
	"gitlab.jiguang.dev/pos-dine/dine/ent/adminuser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/attr"
	"gitlab.jiguang.dev/pos-dine/dine/ent/backenduser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/category"
	"gitlab.jiguang.dev/pos-dine/dine/ent/customer"
	"gitlab.jiguang.dev/pos-dine/dine/ent/dataexport"
	"gitlab.jiguang.dev/pos-dine/dine/ent/dinetable"
	"gitlab.jiguang.dev/pos-dine/dine/ent/frontenduser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/order"
	"gitlab.jiguang.dev/pos-dine/dine/ent/ordercart"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderfinancelog"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderitem"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderitemsetmealdetail"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderlog"
	"gitlab.jiguang.dev/pos-dine/dine/ent/payment"
	"gitlab.jiguang.dev/pos-dine/dine/ent/paymentcallback"
	"gitlab.jiguang.dev/pos-dine/dine/ent/pointsettlement"
	"gitlab.jiguang.dev/pos-dine/dine/ent/predicate"
	"gitlab.jiguang.dev/pos-dine/dine/ent/product"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productspec"
	"gitlab.jiguang.dev/pos-dine/dine/ent/recipe"
	"gitlab.jiguang.dev/pos-dine/dine/ent/reconciliationrecord"
	"gitlab.jiguang.dev/pos-dine/dine/ent/setmealdetail"
	"gitlab.jiguang.dev/pos-dine/dine/ent/spec"
	"gitlab.jiguang.dev/pos-dine/dine/ent/store"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeaccount"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeaccounttransaction"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storefinance"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeinfo"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storewithdraw"
	"gitlab.jiguang.dev/pos-dine/dine/ent/tablearea"
	"gitlab.jiguang.dev/pos-dine/dine/ent/unit"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminUser               = "AdminUser"
	TypeAttr                    = "Attr"
	TypeBackendUser             = "BackendUser"
	TypeCategory                = "Category"
	TypeCustomer                = "Customer"
	TypeDataExport              = "DataExport"
	TypeDineTable               = "DineTable"
	TypeFrontendUser            = "FrontendUser"
	TypeOrder                   = "Order"
	TypeOrderCart               = "OrderCart"
	TypeOrderFinanceLog         = "OrderFinanceLog"
	TypeOrderItem               = "OrderItem"
	TypeOrderItemSetMealDetail  = "OrderItemSetMealDetail"
	TypeOrderLog                = "OrderLog"
	TypePayment                 = "Payment"
	TypePaymentCallback         = "PaymentCallback"
	TypePointSettlement         = "PointSettlement"
	TypeProduct                 = "Product"
	TypeProductSpec             = "ProductSpec"
	TypeRecipe                  = "Recipe"
	TypeReconciliationRecord    = "ReconciliationRecord"
	TypeSetMealDetail           = "SetMealDetail"
	TypeSpec                    = "Spec"
	TypeStore                   = "Store"
	TypeStoreAccount            = "StoreAccount"
	TypeStoreAccountTransaction = "StoreAccountTransaction"
	TypeStoreFinance            = "StoreFinance"
	TypeStoreInfo               = "StoreInfo"
	TypeStoreWithdraw           = "StoreWithdraw"
	TypeTableArea               = "TableArea"
	TypeUnit                    = "Unit"
)

// AdminUserMutation represents an operation that mutates the AdminUser nodes in the graph.
type AdminUserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AdminUser, error)
	predicates      []predicate.AdminUser
}

var _ ent.Mutation = (*AdminUserMutation)(nil)

// adminuserOption allows management of the mutation configuration using functional options.
type adminuserOption func(*AdminUserMutation)

// newAdminUserMutation creates new mutation for the AdminUser entity.
func newAdminUserMutation(c config, op Op, opts ...adminuserOption) *AdminUserMutation {
	m := &AdminUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminUserID sets the ID field of the mutation.
func withAdminUserID(id int) adminuserOption {
	return func(m *AdminUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminUser
		)
		m.oldValue = func(ctx context.Context) (*AdminUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminUser sets the old AdminUser of the mutation.
func withAdminUser(node *AdminUser) adminuserOption {
	return func(m *AdminUserMutation) {
		m.oldValue = func(context.Context) (*AdminUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AdminUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AdminUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *AdminUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *AdminUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *AdminUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *AdminUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AdminUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AdminUserMutation) ResetNickname() {
	m.nickname = nil
}

// Where appends a list predicates to the AdminUserMutation builder.
func (m *AdminUserMutation) Where(ps ...predicate.AdminUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminUser).
func (m *AdminUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminuser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, adminuser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, adminuser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, adminuser.FieldNickname)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.CreatedAt()
	case adminuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case adminuser.FieldDeletedAt:
		return m.DeletedAt()
	case adminuser.FieldUsername:
		return m.Username()
	case adminuser.FieldHashedPassword:
		return m.HashedPassword()
	case adminuser.FieldNickname:
		return m.Nickname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adminuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminuser.FieldUsername:
		return m.OldUsername(ctx)
	case adminuser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case adminuser.FieldNickname:
		return m.OldNickname(ctx)
	}
	return nil, fmt.Errorf("unknown AdminUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adminuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case adminuser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case adminuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, adminuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminUserMutation) ResetField(name string) error {
	switch name {
	case adminuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adminuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminuser.FieldUsername:
		m.ResetUsername()
		return nil
	case adminuser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case adminuser.FieldNickname:
		m.ResetNickname()
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdminUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdminUser edge %s", name)
}

// AttrMutation represents an operation that mutates the Attr nodes in the graph.
type AttrMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *int64
	adddeleted_at           *int64
	name                    *string
	store_id                *int
	addstore_id             *int
	clearedFields           map[string]struct{}
	products                map[int]struct{}
	removedproducts         map[int]struct{}
	clearedproducts         bool
	order_cart_items        map[int]struct{}
	removedorder_cart_items map[int]struct{}
	clearedorder_cart_items bool
	done                    bool
	oldValue                func(context.Context) (*Attr, error)
	predicates              []predicate.Attr
}

var _ ent.Mutation = (*AttrMutation)(nil)

// attrOption allows management of the mutation configuration using functional options.
type attrOption func(*AttrMutation)

// newAttrMutation creates new mutation for the Attr entity.
func newAttrMutation(c config, op Op, opts ...attrOption) *AttrMutation {
	m := &AttrMutation{
		config:        c,
		op:            op,
		typ:           TypeAttr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttrID sets the ID field of the mutation.
func withAttrID(id int) attrOption {
	return func(m *AttrMutation) {
		var (
			err   error
			once  sync.Once
			value *Attr
		)
		m.oldValue = func(ctx context.Context) (*Attr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttr sets the old Attr of the mutation.
func withAttr(node *Attr) attrOption {
	return func(m *AttrMutation) {
		m.oldValue = func(context.Context) (*Attr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttrMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttrMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttrMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttrMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attr entity.
// If the Attr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttrMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttrMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttrMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttrMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attr entity.
// If the Attr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttrMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttrMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttrMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttrMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attr entity.
// If the Attr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttrMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AttrMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AttrMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttrMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *AttrMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AttrMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Attr entity.
// If the Attr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttrMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttrMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *AttrMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AttrMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Attr entity.
// If the Attr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttrMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *AttrMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *AttrMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AttrMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *AttrMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *AttrMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *AttrMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *AttrMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *AttrMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *AttrMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *AttrMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddOrderCartItemIDs adds the "order_cart_items" edge to the OrderCart entity by ids.
func (m *AttrMutation) AddOrderCartItemIDs(ids ...int) {
	if m.order_cart_items == nil {
		m.order_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_cart_items[ids[i]] = struct{}{}
	}
}

// ClearOrderCartItems clears the "order_cart_items" edge to the OrderCart entity.
func (m *AttrMutation) ClearOrderCartItems() {
	m.clearedorder_cart_items = true
}

// OrderCartItemsCleared reports if the "order_cart_items" edge to the OrderCart entity was cleared.
func (m *AttrMutation) OrderCartItemsCleared() bool {
	return m.clearedorder_cart_items
}

// RemoveOrderCartItemIDs removes the "order_cart_items" edge to the OrderCart entity by IDs.
func (m *AttrMutation) RemoveOrderCartItemIDs(ids ...int) {
	if m.removedorder_cart_items == nil {
		m.removedorder_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_cart_items, ids[i])
		m.removedorder_cart_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderCartItems returns the removed IDs of the "order_cart_items" edge to the OrderCart entity.
func (m *AttrMutation) RemovedOrderCartItemsIDs() (ids []int) {
	for id := range m.removedorder_cart_items {
		ids = append(ids, id)
	}
	return
}

// OrderCartItemsIDs returns the "order_cart_items" edge IDs in the mutation.
func (m *AttrMutation) OrderCartItemsIDs() (ids []int) {
	for id := range m.order_cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderCartItems resets all changes to the "order_cart_items" edge.
func (m *AttrMutation) ResetOrderCartItems() {
	m.order_cart_items = nil
	m.clearedorder_cart_items = false
	m.removedorder_cart_items = nil
}

// Where appends a list predicates to the AttrMutation builder.
func (m *AttrMutation) Where(ps ...predicate.Attr) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttrMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttrMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attr, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttrMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttrMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attr).
func (m *AttrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttrMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, attr.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attr.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attr.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, attr.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, attr.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attr.FieldCreatedAt:
		return m.CreatedAt()
	case attr.FieldUpdatedAt:
		return m.UpdatedAt()
	case attr.FieldDeletedAt:
		return m.DeletedAt()
	case attr.FieldName:
		return m.Name()
	case attr.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attr.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attr.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attr.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attr.FieldName:
		return m.OldName(ctx)
	case attr.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Attr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attr.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attr.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attr.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attr.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case attr.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Attr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttrMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, attr.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, attr.FieldStoreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attr.FieldDeletedAt:
		return m.AddedDeletedAt()
	case attr.FieldStoreID:
		return m.AddedStoreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attr.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case attr.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Attr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttrMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttrMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Attr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttrMutation) ResetField(name string) error {
	switch name {
	case attr.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attr.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attr.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attr.FieldName:
		m.ResetName()
		return nil
	case attr.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Attr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttrMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, attr.EdgeProducts)
	}
	if m.order_cart_items != nil {
		edges = append(edges, attr.EdgeOrderCartItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttrMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attr.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case attr.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.order_cart_items))
		for id := range m.order_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, attr.EdgeProducts)
	}
	if m.removedorder_cart_items != nil {
		edges = append(edges, attr.EdgeOrderCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttrMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attr.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case attr.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.removedorder_cart_items))
		for id := range m.removedorder_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, attr.EdgeProducts)
	}
	if m.clearedorder_cart_items {
		edges = append(edges, attr.EdgeOrderCartItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttrMutation) EdgeCleared(name string) bool {
	switch name {
	case attr.EdgeProducts:
		return m.clearedproducts
	case attr.EdgeOrderCartItems:
		return m.clearedorder_cart_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttrMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Attr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttrMutation) ResetEdge(name string) error {
	switch name {
	case attr.EdgeProducts:
		m.ResetProducts()
		return nil
	case attr.EdgeOrderCartItems:
		m.ResetOrderCartItems()
		return nil
	}
	return fmt.Errorf("unknown Attr edge %s", name)
}

// BackendUserMutation represents an operation that mutates the BackendUser nodes in the graph.
type BackendUserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	clearedFields   map[string]struct{}
	store           *int
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*BackendUser, error)
	predicates      []predicate.BackendUser
}

var _ ent.Mutation = (*BackendUserMutation)(nil)

// backenduserOption allows management of the mutation configuration using functional options.
type backenduserOption func(*BackendUserMutation)

// newBackendUserMutation creates new mutation for the BackendUser entity.
func newBackendUserMutation(c config, op Op, opts ...backenduserOption) *BackendUserMutation {
	m := &BackendUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBackendUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackendUserID sets the ID field of the mutation.
func withBackendUserID(id int) backenduserOption {
	return func(m *BackendUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BackendUser
		)
		m.oldValue = func(ctx context.Context) (*BackendUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackendUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackendUser sets the old BackendUser of the mutation.
func withBackendUser(node *BackendUser) backenduserOption {
	return func(m *BackendUserMutation) {
		m.oldValue = func(context.Context) (*BackendUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackendUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackendUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackendUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackendUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackendUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BackendUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackendUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackendUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackendUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackendUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackendUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BackendUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BackendUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BackendUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BackendUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BackendUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *BackendUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *BackendUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *BackendUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *BackendUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *BackendUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *BackendUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *BackendUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *BackendUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *BackendUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetStoreID sets the "store_id" field.
func (m *BackendUserMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *BackendUserMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *BackendUserMutation) ResetStoreID() {
	m.store = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *BackendUserMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[backenduser.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *BackendUserMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *BackendUserMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *BackendUserMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the BackendUserMutation builder.
func (m *BackendUserMutation) Where(ps ...predicate.BackendUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackendUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackendUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackendUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackendUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackendUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackendUser).
func (m *BackendUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackendUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, backenduser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backenduser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, backenduser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, backenduser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, backenduser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, backenduser.FieldNickname)
	}
	if m.store != nil {
		fields = append(fields, backenduser.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackendUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backenduser.FieldCreatedAt:
		return m.CreatedAt()
	case backenduser.FieldUpdatedAt:
		return m.UpdatedAt()
	case backenduser.FieldDeletedAt:
		return m.DeletedAt()
	case backenduser.FieldUsername:
		return m.Username()
	case backenduser.FieldHashedPassword:
		return m.HashedPassword()
	case backenduser.FieldNickname:
		return m.Nickname()
	case backenduser.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackendUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backenduser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backenduser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backenduser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case backenduser.FieldUsername:
		return m.OldUsername(ctx)
	case backenduser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case backenduser.FieldNickname:
		return m.OldNickname(ctx)
	case backenduser.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown BackendUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackendUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backenduser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backenduser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case backenduser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case backenduser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case backenduser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case backenduser.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown BackendUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackendUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, backenduser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackendUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backenduser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackendUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackendUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackendUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackendUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackendUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BackendUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackendUserMutation) ResetField(name string) error {
	switch name {
	case backenduser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backenduser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backenduser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case backenduser.FieldUsername:
		m.ResetUsername()
		return nil
	case backenduser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case backenduser.FieldNickname:
		m.ResetNickname()
		return nil
	case backenduser.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown BackendUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackendUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, backenduser.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackendUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backenduser.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackendUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackendUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackendUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, backenduser.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackendUserMutation) EdgeCleared(name string) bool {
	switch name {
	case backenduser.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackendUserMutation) ClearEdge(name string) error {
	switch name {
	case backenduser.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown BackendUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackendUserMutation) ResetEdge(name string) error {
	switch name {
	case backenduser.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown BackendUser edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	store_id        *int
	addstore_id     *int
	parent_id       *int
	addparent_id    *int
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *CategoryMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CategoryMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *CategoryMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *CategoryMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *CategoryMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *CategoryMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *CategoryMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *CategoryMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CategoryMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, category.FieldParentID)
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CategoryMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CategoryMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CategoryMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CategoryMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, category.FieldStoreID)
	}
	if m.parent_id != nil {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldStoreID:
		return m.StoreID()
	case category.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldStoreID:
		return m.OldStoreID(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, category.FieldStoreID)
	}
	if m.addparent_id != nil {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldDeletedAt:
		return m.AddedDeletedAt()
	case category.FieldStoreID:
		return m.AddedStoreID()
	case category.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case category.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldStoreID:
		m.ResetStoreID()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int64
	adddeleted_at *int64
	nickname      *string
	phone         *string
	avatar        *string
	gender        *domain.Gender
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Customer, error)
	predicates    []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *CustomerMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CustomerMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetNickname sets the "nickname" field.
func (m *CustomerMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *CustomerMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *CustomerMutation) ResetNickname() {
	m.nickname = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetAvatar sets the "avatar" field.
func (m *CustomerMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *CustomerMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *CustomerMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[customer.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *CustomerMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[customer.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *CustomerMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, customer.FieldAvatar)
}

// SetGender sets the "gender" field.
func (m *CustomerMutation) SetGender(d domain.Gender) {
	m.gender = &d
}

// Gender returns the value of the "gender" field in the mutation.
func (m *CustomerMutation) Gender() (r domain.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldGender(ctx context.Context) (v domain.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *CustomerMutation) ResetGender() {
	m.gender = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.nickname != nil {
		fields = append(fields, customer.FieldNickname)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.avatar != nil {
		fields = append(fields, customer.FieldAvatar)
	}
	if m.gender != nil {
		fields = append(fields, customer.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldNickname:
		return m.Nickname()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldAvatar:
		return m.Avatar()
	case customer.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldNickname:
		return m.OldNickname(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldAvatar:
		return m.OldAvatar(ctx)
	case customer.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case customer.FieldGender:
		v, ok := value.(domain.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customer.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldAvatar) {
		fields = append(fields, customer.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldNickname:
		m.ResetNickname()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldAvatar:
		m.ResetAvatar()
		return nil
	case customer.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Customer edge %s", name)
}

// DataExportMutation represents an operation that mutates the DataExport nodes in the graph.
type DataExportMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int64
	adddeleted_at  *int64
	store_id       *int
	addstore_id    *int
	_type          *domain.DataExportType
	status         *domain.DataExportStatus
	params         *json.RawMessage
	appendparams   json.RawMessage
	failed_reason  *string
	operator_type  *domain.OperatorType
	operator_id    *int
	addoperator_id *int
	operator_name  *string
	file_name      *string
	url            *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*DataExport, error)
	predicates     []predicate.DataExport
}

var _ ent.Mutation = (*DataExportMutation)(nil)

// dataexportOption allows management of the mutation configuration using functional options.
type dataexportOption func(*DataExportMutation)

// newDataExportMutation creates new mutation for the DataExport entity.
func newDataExportMutation(c config, op Op, opts ...dataexportOption) *DataExportMutation {
	m := &DataExportMutation{
		config:        c,
		op:            op,
		typ:           TypeDataExport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataExportID sets the ID field of the mutation.
func withDataExportID(id int) dataexportOption {
	return func(m *DataExportMutation) {
		var (
			err   error
			once  sync.Once
			value *DataExport
		)
		m.oldValue = func(ctx context.Context) (*DataExport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataExport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataExport sets the old DataExport of the mutation.
func withDataExport(node *DataExport) dataexportOption {
	return func(m *DataExportMutation) {
		m.oldValue = func(context.Context) (*DataExport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataExportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataExportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataExportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataExportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataExport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DataExportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DataExportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DataExportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DataExportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DataExportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DataExportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DataExportMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DataExportMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DataExportMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DataExportMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DataExportMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetStoreID sets the "store_id" field.
func (m *DataExportMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *DataExportMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *DataExportMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *DataExportMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *DataExportMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetType sets the "type" field.
func (m *DataExportMutation) SetType(det domain.DataExportType) {
	m._type = &det
}

// GetType returns the value of the "type" field in the mutation.
func (m *DataExportMutation) GetType() (r domain.DataExportType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldType(ctx context.Context) (v domain.DataExportType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DataExportMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *DataExportMutation) SetStatus(des domain.DataExportStatus) {
	m.status = &des
}

// Status returns the value of the "status" field in the mutation.
func (m *DataExportMutation) Status() (r domain.DataExportStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldStatus(ctx context.Context) (v domain.DataExportStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DataExportMutation) ResetStatus() {
	m.status = nil
}

// SetParams sets the "params" field.
func (m *DataExportMutation) SetParams(jm json.RawMessage) {
	m.params = &jm
	m.appendparams = nil
}

// Params returns the value of the "params" field in the mutation.
func (m *DataExportMutation) Params() (r json.RawMessage, exists bool) {
	v := m.params
	if v == nil {
		return
	}
	return *v, true
}

// OldParams returns the old "params" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldParams(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParams: %w", err)
	}
	return oldValue.Params, nil
}

// AppendParams adds jm to the "params" field.
func (m *DataExportMutation) AppendParams(jm json.RawMessage) {
	m.appendparams = append(m.appendparams, jm...)
}

// AppendedParams returns the list of values that were appended to the "params" field in this mutation.
func (m *DataExportMutation) AppendedParams() (json.RawMessage, bool) {
	if len(m.appendparams) == 0 {
		return nil, false
	}
	return m.appendparams, true
}

// ResetParams resets all changes to the "params" field.
func (m *DataExportMutation) ResetParams() {
	m.params = nil
	m.appendparams = nil
}

// SetFailedReason sets the "failed_reason" field.
func (m *DataExportMutation) SetFailedReason(s string) {
	m.failed_reason = &s
}

// FailedReason returns the value of the "failed_reason" field in the mutation.
func (m *DataExportMutation) FailedReason() (r string, exists bool) {
	v := m.failed_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedReason returns the old "failed_reason" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldFailedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedReason: %w", err)
	}
	return oldValue.FailedReason, nil
}

// ClearFailedReason clears the value of the "failed_reason" field.
func (m *DataExportMutation) ClearFailedReason() {
	m.failed_reason = nil
	m.clearedFields[dataexport.FieldFailedReason] = struct{}{}
}

// FailedReasonCleared returns if the "failed_reason" field was cleared in this mutation.
func (m *DataExportMutation) FailedReasonCleared() bool {
	_, ok := m.clearedFields[dataexport.FieldFailedReason]
	return ok
}

// ResetFailedReason resets all changes to the "failed_reason" field.
func (m *DataExportMutation) ResetFailedReason() {
	m.failed_reason = nil
	delete(m.clearedFields, dataexport.FieldFailedReason)
}

// SetOperatorType sets the "operator_type" field.
func (m *DataExportMutation) SetOperatorType(dt domain.OperatorType) {
	m.operator_type = &dt
}

// OperatorType returns the value of the "operator_type" field in the mutation.
func (m *DataExportMutation) OperatorType() (r domain.OperatorType, exists bool) {
	v := m.operator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorType returns the old "operator_type" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldOperatorType(ctx context.Context) (v domain.OperatorType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorType: %w", err)
	}
	return oldValue.OperatorType, nil
}

// ResetOperatorType resets all changes to the "operator_type" field.
func (m *DataExportMutation) ResetOperatorType() {
	m.operator_type = nil
}

// SetOperatorID sets the "operator_id" field.
func (m *DataExportMutation) SetOperatorID(i int) {
	m.operator_id = &i
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *DataExportMutation) OperatorID() (r int, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldOperatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds i to the "operator_id" field.
func (m *DataExportMutation) AddOperatorID(i int) {
	if m.addoperator_id != nil {
		*m.addoperator_id += i
	} else {
		m.addoperator_id = &i
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *DataExportMutation) AddedOperatorID() (r int, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *DataExportMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
}

// SetOperatorName sets the "operator_name" field.
func (m *DataExportMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *DataExportMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *DataExportMutation) ResetOperatorName() {
	m.operator_name = nil
}

// SetFileName sets the "file_name" field.
func (m *DataExportMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *DataExportMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *DataExportMutation) ResetFileName() {
	m.file_name = nil
}

// SetURL sets the "url" field.
func (m *DataExportMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DataExportMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DataExport entity.
// If the DataExport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataExportMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *DataExportMutation) ClearURL() {
	m.url = nil
	m.clearedFields[dataexport.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *DataExportMutation) URLCleared() bool {
	_, ok := m.clearedFields[dataexport.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *DataExportMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, dataexport.FieldURL)
}

// Where appends a list predicates to the DataExportMutation builder.
func (m *DataExportMutation) Where(ps ...predicate.DataExport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DataExportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DataExportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DataExport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DataExportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DataExportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DataExport).
func (m *DataExportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataExportMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, dataexport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dataexport.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dataexport.FieldDeletedAt)
	}
	if m.store_id != nil {
		fields = append(fields, dataexport.FieldStoreID)
	}
	if m._type != nil {
		fields = append(fields, dataexport.FieldType)
	}
	if m.status != nil {
		fields = append(fields, dataexport.FieldStatus)
	}
	if m.params != nil {
		fields = append(fields, dataexport.FieldParams)
	}
	if m.failed_reason != nil {
		fields = append(fields, dataexport.FieldFailedReason)
	}
	if m.operator_type != nil {
		fields = append(fields, dataexport.FieldOperatorType)
	}
	if m.operator_id != nil {
		fields = append(fields, dataexport.FieldOperatorID)
	}
	if m.operator_name != nil {
		fields = append(fields, dataexport.FieldOperatorName)
	}
	if m.file_name != nil {
		fields = append(fields, dataexport.FieldFileName)
	}
	if m.url != nil {
		fields = append(fields, dataexport.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataExportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dataexport.FieldCreatedAt:
		return m.CreatedAt()
	case dataexport.FieldUpdatedAt:
		return m.UpdatedAt()
	case dataexport.FieldDeletedAt:
		return m.DeletedAt()
	case dataexport.FieldStoreID:
		return m.StoreID()
	case dataexport.FieldType:
		return m.GetType()
	case dataexport.FieldStatus:
		return m.Status()
	case dataexport.FieldParams:
		return m.Params()
	case dataexport.FieldFailedReason:
		return m.FailedReason()
	case dataexport.FieldOperatorType:
		return m.OperatorType()
	case dataexport.FieldOperatorID:
		return m.OperatorID()
	case dataexport.FieldOperatorName:
		return m.OperatorName()
	case dataexport.FieldFileName:
		return m.FileName()
	case dataexport.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataExportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dataexport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dataexport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dataexport.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dataexport.FieldStoreID:
		return m.OldStoreID(ctx)
	case dataexport.FieldType:
		return m.OldType(ctx)
	case dataexport.FieldStatus:
		return m.OldStatus(ctx)
	case dataexport.FieldParams:
		return m.OldParams(ctx)
	case dataexport.FieldFailedReason:
		return m.OldFailedReason(ctx)
	case dataexport.FieldOperatorType:
		return m.OldOperatorType(ctx)
	case dataexport.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case dataexport.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case dataexport.FieldFileName:
		return m.OldFileName(ctx)
	case dataexport.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown DataExport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataExportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dataexport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dataexport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dataexport.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dataexport.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case dataexport.FieldType:
		v, ok := value.(domain.DataExportType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dataexport.FieldStatus:
		v, ok := value.(domain.DataExportStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dataexport.FieldParams:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParams(v)
		return nil
	case dataexport.FieldFailedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedReason(v)
		return nil
	case dataexport.FieldOperatorType:
		v, ok := value.(domain.OperatorType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorType(v)
		return nil
	case dataexport.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case dataexport.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case dataexport.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case dataexport.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown DataExport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataExportMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, dataexport.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, dataexport.FieldStoreID)
	}
	if m.addoperator_id != nil {
		fields = append(fields, dataexport.FieldOperatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataExportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dataexport.FieldDeletedAt:
		return m.AddedDeletedAt()
	case dataexport.FieldStoreID:
		return m.AddedStoreID()
	case dataexport.FieldOperatorID:
		return m.AddedOperatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataExportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dataexport.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case dataexport.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case dataexport.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	}
	return fmt.Errorf("unknown DataExport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataExportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dataexport.FieldFailedReason) {
		fields = append(fields, dataexport.FieldFailedReason)
	}
	if m.FieldCleared(dataexport.FieldURL) {
		fields = append(fields, dataexport.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataExportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataExportMutation) ClearField(name string) error {
	switch name {
	case dataexport.FieldFailedReason:
		m.ClearFailedReason()
		return nil
	case dataexport.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown DataExport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataExportMutation) ResetField(name string) error {
	switch name {
	case dataexport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dataexport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dataexport.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dataexport.FieldStoreID:
		m.ResetStoreID()
		return nil
	case dataexport.FieldType:
		m.ResetType()
		return nil
	case dataexport.FieldStatus:
		m.ResetStatus()
		return nil
	case dataexport.FieldParams:
		m.ResetParams()
		return nil
	case dataexport.FieldFailedReason:
		m.ResetFailedReason()
		return nil
	case dataexport.FieldOperatorType:
		m.ResetOperatorType()
		return nil
	case dataexport.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case dataexport.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case dataexport.FieldFileName:
		m.ResetFileName()
		return nil
	case dataexport.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown DataExport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataExportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataExportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataExportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataExportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataExportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataExportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataExportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DataExport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataExportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DataExport edge %s", name)
}

// DineTableMutation represents an operation that mutates the DineTable nodes in the graph.
type DineTableMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	store_id         *int
	addstore_id      *int
	seat_count       *int
	addseat_count    *int
	status           *int
	addstatus        *int
	clearedFields    map[string]struct{}
	tablearea        *int
	clearedtablearea bool
	_order           *int
	cleared_order    bool
	orders           map[int]struct{}
	removedorders    map[int]struct{}
	clearedorders    bool
	done             bool
	oldValue         func(context.Context) (*DineTable, error)
	predicates       []predicate.DineTable
}

var _ ent.Mutation = (*DineTableMutation)(nil)

// dinetableOption allows management of the mutation configuration using functional options.
type dinetableOption func(*DineTableMutation)

// newDineTableMutation creates new mutation for the DineTable entity.
func newDineTableMutation(c config, op Op, opts ...dinetableOption) *DineTableMutation {
	m := &DineTableMutation{
		config:        c,
		op:            op,
		typ:           TypeDineTable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDineTableID sets the ID field of the mutation.
func withDineTableID(id int) dinetableOption {
	return func(m *DineTableMutation) {
		var (
			err   error
			once  sync.Once
			value *DineTable
		)
		m.oldValue = func(ctx context.Context) (*DineTable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DineTable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDineTable sets the old DineTable of the mutation.
func withDineTable(node *DineTable) dinetableOption {
	return func(m *DineTableMutation) {
		m.oldValue = func(context.Context) (*DineTable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DineTableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DineTableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DineTableMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DineTableMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DineTable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DineTableMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DineTableMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DineTableMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DineTableMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DineTableMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DineTableMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DineTableMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DineTableMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DineTableMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DineTableMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DineTableMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *DineTableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DineTableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DineTableMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *DineTableMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *DineTableMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *DineTableMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *DineTableMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *DineTableMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetSeatCount sets the "seat_count" field.
func (m *DineTableMutation) SetSeatCount(i int) {
	m.seat_count = &i
	m.addseat_count = nil
}

// SeatCount returns the value of the "seat_count" field in the mutation.
func (m *DineTableMutation) SeatCount() (r int, exists bool) {
	v := m.seat_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatCount returns the old "seat_count" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldSeatCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatCount: %w", err)
	}
	return oldValue.SeatCount, nil
}

// AddSeatCount adds i to the "seat_count" field.
func (m *DineTableMutation) AddSeatCount(i int) {
	if m.addseat_count != nil {
		*m.addseat_count += i
	} else {
		m.addseat_count = &i
	}
}

// AddedSeatCount returns the value that was added to the "seat_count" field in this mutation.
func (m *DineTableMutation) AddedSeatCount() (r int, exists bool) {
	v := m.addseat_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeatCount resets all changes to the "seat_count" field.
func (m *DineTableMutation) ResetSeatCount() {
	m.seat_count = nil
	m.addseat_count = nil
}

// SetStatus sets the "status" field.
func (m *DineTableMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DineTableMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DineTableMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DineTableMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DineTableMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAreaID sets the "area_id" field.
func (m *DineTableMutation) SetAreaID(i int) {
	m.tablearea = &i
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *DineTableMutation) AreaID() (r int, exists bool) {
	v := m.tablearea
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *DineTableMutation) ResetAreaID() {
	m.tablearea = nil
}

// SetOrderID sets the "order_id" field.
func (m *DineTableMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *DineTableMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the DineTable entity.
// If the DineTable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DineTableMutation) OldOrderID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *DineTableMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[dinetable.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *DineTableMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[dinetable.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *DineTableMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, dinetable.FieldOrderID)
}

// SetTableareaID sets the "tablearea" edge to the TableArea entity by id.
func (m *DineTableMutation) SetTableareaID(id int) {
	m.tablearea = &id
}

// ClearTablearea clears the "tablearea" edge to the TableArea entity.
func (m *DineTableMutation) ClearTablearea() {
	m.clearedtablearea = true
	m.clearedFields[dinetable.FieldAreaID] = struct{}{}
}

// TableareaCleared reports if the "tablearea" edge to the TableArea entity was cleared.
func (m *DineTableMutation) TableareaCleared() bool {
	return m.clearedtablearea
}

// TableareaID returns the "tablearea" edge ID in the mutation.
func (m *DineTableMutation) TableareaID() (id int, exists bool) {
	if m.tablearea != nil {
		return *m.tablearea, true
	}
	return
}

// TableareaIDs returns the "tablearea" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TableareaID instead. It exists only for internal usage by the builders.
func (m *DineTableMutation) TableareaIDs() (ids []int) {
	if id := m.tablearea; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTablearea resets all changes to the "tablearea" edge.
func (m *DineTableMutation) ResetTablearea() {
	m.tablearea = nil
	m.clearedtablearea = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *DineTableMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[dinetable.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *DineTableMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *DineTableMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *DineTableMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *DineTableMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *DineTableMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *DineTableMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *DineTableMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *DineTableMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *DineTableMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *DineTableMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the DineTableMutation builder.
func (m *DineTableMutation) Where(ps ...predicate.DineTable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DineTableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DineTableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DineTable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DineTableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DineTableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DineTable).
func (m *DineTableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DineTableMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, dinetable.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dinetable.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dinetable.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, dinetable.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, dinetable.FieldStoreID)
	}
	if m.seat_count != nil {
		fields = append(fields, dinetable.FieldSeatCount)
	}
	if m.status != nil {
		fields = append(fields, dinetable.FieldStatus)
	}
	if m.tablearea != nil {
		fields = append(fields, dinetable.FieldAreaID)
	}
	if m._order != nil {
		fields = append(fields, dinetable.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DineTableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dinetable.FieldCreatedAt:
		return m.CreatedAt()
	case dinetable.FieldUpdatedAt:
		return m.UpdatedAt()
	case dinetable.FieldDeletedAt:
		return m.DeletedAt()
	case dinetable.FieldName:
		return m.Name()
	case dinetable.FieldStoreID:
		return m.StoreID()
	case dinetable.FieldSeatCount:
		return m.SeatCount()
	case dinetable.FieldStatus:
		return m.Status()
	case dinetable.FieldAreaID:
		return m.AreaID()
	case dinetable.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DineTableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dinetable.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dinetable.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dinetable.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dinetable.FieldName:
		return m.OldName(ctx)
	case dinetable.FieldStoreID:
		return m.OldStoreID(ctx)
	case dinetable.FieldSeatCount:
		return m.OldSeatCount(ctx)
	case dinetable.FieldStatus:
		return m.OldStatus(ctx)
	case dinetable.FieldAreaID:
		return m.OldAreaID(ctx)
	case dinetable.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown DineTable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DineTableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dinetable.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dinetable.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dinetable.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dinetable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dinetable.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case dinetable.FieldSeatCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatCount(v)
		return nil
	case dinetable.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dinetable.FieldAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case dinetable.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown DineTable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DineTableMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, dinetable.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, dinetable.FieldStoreID)
	}
	if m.addseat_count != nil {
		fields = append(fields, dinetable.FieldSeatCount)
	}
	if m.addstatus != nil {
		fields = append(fields, dinetable.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DineTableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dinetable.FieldDeletedAt:
		return m.AddedDeletedAt()
	case dinetable.FieldStoreID:
		return m.AddedStoreID()
	case dinetable.FieldSeatCount:
		return m.AddedSeatCount()
	case dinetable.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DineTableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dinetable.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case dinetable.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case dinetable.FieldSeatCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeatCount(v)
		return nil
	case dinetable.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DineTable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DineTableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dinetable.FieldOrderID) {
		fields = append(fields, dinetable.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DineTableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DineTableMutation) ClearField(name string) error {
	switch name {
	case dinetable.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown DineTable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DineTableMutation) ResetField(name string) error {
	switch name {
	case dinetable.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dinetable.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dinetable.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dinetable.FieldName:
		m.ResetName()
		return nil
	case dinetable.FieldStoreID:
		m.ResetStoreID()
		return nil
	case dinetable.FieldSeatCount:
		m.ResetSeatCount()
		return nil
	case dinetable.FieldStatus:
		m.ResetStatus()
		return nil
	case dinetable.FieldAreaID:
		m.ResetAreaID()
		return nil
	case dinetable.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown DineTable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DineTableMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tablearea != nil {
		edges = append(edges, dinetable.EdgeTablearea)
	}
	if m._order != nil {
		edges = append(edges, dinetable.EdgeOrder)
	}
	if m.orders != nil {
		edges = append(edges, dinetable.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DineTableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dinetable.EdgeTablearea:
		if id := m.tablearea; id != nil {
			return []ent.Value{*id}
		}
	case dinetable.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case dinetable.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DineTableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorders != nil {
		edges = append(edges, dinetable.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DineTableMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dinetable.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DineTableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtablearea {
		edges = append(edges, dinetable.EdgeTablearea)
	}
	if m.cleared_order {
		edges = append(edges, dinetable.EdgeOrder)
	}
	if m.clearedorders {
		edges = append(edges, dinetable.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DineTableMutation) EdgeCleared(name string) bool {
	switch name {
	case dinetable.EdgeTablearea:
		return m.clearedtablearea
	case dinetable.EdgeOrder:
		return m.cleared_order
	case dinetable.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DineTableMutation) ClearEdge(name string) error {
	switch name {
	case dinetable.EdgeTablearea:
		m.ClearTablearea()
		return nil
	case dinetable.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown DineTable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DineTableMutation) ResetEdge(name string) error {
	switch name {
	case dinetable.EdgeTablearea:
		m.ResetTablearea()
		return nil
	case dinetable.EdgeOrder:
		m.ResetOrder()
		return nil
	case dinetable.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown DineTable edge %s", name)
}

// FrontendUserMutation represents an operation that mutates the FrontendUser nodes in the graph.
type FrontendUserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	clearedFields   map[string]struct{}
	store           *int
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*FrontendUser, error)
	predicates      []predicate.FrontendUser
}

var _ ent.Mutation = (*FrontendUserMutation)(nil)

// frontenduserOption allows management of the mutation configuration using functional options.
type frontenduserOption func(*FrontendUserMutation)

// newFrontendUserMutation creates new mutation for the FrontendUser entity.
func newFrontendUserMutation(c config, op Op, opts ...frontenduserOption) *FrontendUserMutation {
	m := &FrontendUserMutation{
		config:        c,
		op:            op,
		typ:           TypeFrontendUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrontendUserID sets the ID field of the mutation.
func withFrontendUserID(id int) frontenduserOption {
	return func(m *FrontendUserMutation) {
		var (
			err   error
			once  sync.Once
			value *FrontendUser
		)
		m.oldValue = func(ctx context.Context) (*FrontendUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrontendUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrontendUser sets the old FrontendUser of the mutation.
func withFrontendUser(node *FrontendUser) frontenduserOption {
	return func(m *FrontendUserMutation) {
		m.oldValue = func(context.Context) (*FrontendUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrontendUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrontendUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrontendUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrontendUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FrontendUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FrontendUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FrontendUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FrontendUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FrontendUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FrontendUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FrontendUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FrontendUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FrontendUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FrontendUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FrontendUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FrontendUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *FrontendUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *FrontendUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *FrontendUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *FrontendUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *FrontendUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *FrontendUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *FrontendUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *FrontendUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *FrontendUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetStoreID sets the "store_id" field.
func (m *FrontendUserMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *FrontendUserMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the FrontendUser entity.
// If the FrontendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontendUserMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *FrontendUserMutation) ResetStoreID() {
	m.store = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *FrontendUserMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[frontenduser.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *FrontendUserMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *FrontendUserMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *FrontendUserMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the FrontendUserMutation builder.
func (m *FrontendUserMutation) Where(ps ...predicate.FrontendUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FrontendUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FrontendUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FrontendUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FrontendUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FrontendUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FrontendUser).
func (m *FrontendUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrontendUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, frontenduser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, frontenduser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, frontenduser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, frontenduser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, frontenduser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, frontenduser.FieldNickname)
	}
	if m.store != nil {
		fields = append(fields, frontenduser.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrontendUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frontenduser.FieldCreatedAt:
		return m.CreatedAt()
	case frontenduser.FieldUpdatedAt:
		return m.UpdatedAt()
	case frontenduser.FieldDeletedAt:
		return m.DeletedAt()
	case frontenduser.FieldUsername:
		return m.Username()
	case frontenduser.FieldHashedPassword:
		return m.HashedPassword()
	case frontenduser.FieldNickname:
		return m.Nickname()
	case frontenduser.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrontendUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frontenduser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frontenduser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case frontenduser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case frontenduser.FieldUsername:
		return m.OldUsername(ctx)
	case frontenduser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case frontenduser.FieldNickname:
		return m.OldNickname(ctx)
	case frontenduser.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown FrontendUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrontendUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frontenduser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frontenduser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case frontenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case frontenduser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case frontenduser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case frontenduser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case frontenduser.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown FrontendUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrontendUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, frontenduser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrontendUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frontenduser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrontendUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frontenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FrontendUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrontendUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrontendUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrontendUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FrontendUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrontendUserMutation) ResetField(name string) error {
	switch name {
	case frontenduser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frontenduser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case frontenduser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case frontenduser.FieldUsername:
		m.ResetUsername()
		return nil
	case frontenduser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case frontenduser.FieldNickname:
		m.ResetNickname()
		return nil
	case frontenduser.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown FrontendUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrontendUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, frontenduser.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrontendUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frontenduser.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrontendUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrontendUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrontendUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, frontenduser.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrontendUserMutation) EdgeCleared(name string) bool {
	switch name {
	case frontenduser.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrontendUserMutation) ClearEdge(name string) error {
	switch name {
	case frontenduser.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown FrontendUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrontendUserMutation) ResetEdge(name string) error {
	switch name {
	case frontenduser.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown FrontendUser edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *int64
	adddeleted_at            *int64
	no                       *string
	_type                    *domain.OrderType
	source                   *domain.OrderSource
	status                   *domain.OrderStatus
	total_price              *decimal.Decimal
	discount                 *decimal.Decimal
	real_price               *decimal.Decimal
	points_available         *decimal.Decimal
	paid                     *decimal.Decimal
	refunded                 *decimal.Decimal
	paid_channels            *domain.OrderPaidChannels
	appendpaid_channels      domain.OrderPaidChannels
	cash_paid                *decimal.Decimal
	cash_refunded            *decimal.Decimal
	wechat_paid              *decimal.Decimal
	wechat_refunded          *decimal.Decimal
	alipay_paid              *decimal.Decimal
	alipay_refunded          *decimal.Decimal
	points_paid              *decimal.Decimal
	points_refunded          *decimal.Decimal
	points_wallet_paid       *decimal.Decimal
	points_wallet_refunded   *decimal.Decimal
	last_paid_at             *time.Time
	finished_at              *time.Time
	member_id                *int
	addmember_id             *int
	member_name              *string
	member_phone             *string
	store_id                 *int
	addstore_id              *int
	store_name               *string
	table_name               *string
	people_number            *int
	addpeople_number         *int
	creator_id               *int
	addcreator_id            *int
	creator_name             *string
	creator_type             *domain.OperatorType
	clearedFields            map[string]struct{}
	items                    map[int]struct{}
	removeditems             map[int]struct{}
	cleareditems             bool
	logs                     map[int]struct{}
	removedlogs              map[int]struct{}
	clearedlogs              bool
	current_dinetable        *int
	clearedcurrent_dinetable bool
	dinetable                *int
	cleareddinetable         bool
	done                     bool
	oldValue                 func(context.Context) (*Order, error)
	predicates               []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetNo sets the "no" field.
func (m *OrderMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *OrderMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *OrderMutation) ResetNo() {
	m.no = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(dt domain.OrderType) {
	m._type = &dt
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r domain.OrderType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v domain.OrderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *OrderMutation) SetSource(ds domain.OrderSource) {
	m.source = &ds
}

// Source returns the value of the "source" field in the mutation.
func (m *OrderMutation) Source() (r domain.OrderSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSource(ctx context.Context) (v domain.OrderSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *OrderMutation) ResetSource() {
	m.source = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(ds domain.OrderStatus) {
	m.status = &ds
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r domain.OrderStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v domain.OrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *OrderMutation) SetTotalPrice(d decimal.Decimal) {
	m.total_price = &d
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *OrderMutation) TotalPrice() (r decimal.Decimal, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *OrderMutation) ResetTotalPrice() {
	m.total_price = nil
}

// SetDiscount sets the "discount" field.
func (m *OrderMutation) SetDiscount(d decimal.Decimal) {
	m.discount = &d
}

// Discount returns the value of the "discount" field in the mutation.
func (m *OrderMutation) Discount() (r decimal.Decimal, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDiscount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// ResetDiscount resets all changes to the "discount" field.
func (m *OrderMutation) ResetDiscount() {
	m.discount = nil
}

// SetRealPrice sets the "real_price" field.
func (m *OrderMutation) SetRealPrice(d decimal.Decimal) {
	m.real_price = &d
}

// RealPrice returns the value of the "real_price" field in the mutation.
func (m *OrderMutation) RealPrice() (r decimal.Decimal, exists bool) {
	v := m.real_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRealPrice returns the old "real_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRealPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealPrice: %w", err)
	}
	return oldValue.RealPrice, nil
}

// ResetRealPrice resets all changes to the "real_price" field.
func (m *OrderMutation) ResetRealPrice() {
	m.real_price = nil
}

// SetPointsAvailable sets the "points_available" field.
func (m *OrderMutation) SetPointsAvailable(d decimal.Decimal) {
	m.points_available = &d
}

// PointsAvailable returns the value of the "points_available" field in the mutation.
func (m *OrderMutation) PointsAvailable() (r decimal.Decimal, exists bool) {
	v := m.points_available
	if v == nil {
		return
	}
	return *v, true
}

// OldPointsAvailable returns the old "points_available" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPointsAvailable(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointsAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointsAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointsAvailable: %w", err)
	}
	return oldValue.PointsAvailable, nil
}

// ResetPointsAvailable resets all changes to the "points_available" field.
func (m *OrderMutation) ResetPointsAvailable() {
	m.points_available = nil
}

// SetPaid sets the "paid" field.
func (m *OrderMutation) SetPaid(d decimal.Decimal) {
	m.paid = &d
}

// Paid returns the value of the "paid" field in the mutation.
func (m *OrderMutation) Paid() (r decimal.Decimal, exists bool) {
	v := m.paid
	if v == nil {
		return
	}
	return *v, true
}

// OldPaid returns the old "paid" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaid(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaid: %w", err)
	}
	return oldValue.Paid, nil
}

// ResetPaid resets all changes to the "paid" field.
func (m *OrderMutation) ResetPaid() {
	m.paid = nil
}

// SetRefunded sets the "refunded" field.
func (m *OrderMutation) SetRefunded(d decimal.Decimal) {
	m.refunded = &d
}

// Refunded returns the value of the "refunded" field in the mutation.
func (m *OrderMutation) Refunded() (r decimal.Decimal, exists bool) {
	v := m.refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldRefunded returns the old "refunded" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefunded: %w", err)
	}
	return oldValue.Refunded, nil
}

// ResetRefunded resets all changes to the "refunded" field.
func (m *OrderMutation) ResetRefunded() {
	m.refunded = nil
}

// SetPaidChannels sets the "paid_channels" field.
func (m *OrderMutation) SetPaidChannels(dpc domain.OrderPaidChannels) {
	m.paid_channels = &dpc
	m.appendpaid_channels = nil
}

// PaidChannels returns the value of the "paid_channels" field in the mutation.
func (m *OrderMutation) PaidChannels() (r domain.OrderPaidChannels, exists bool) {
	v := m.paid_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidChannels returns the old "paid_channels" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaidChannels(ctx context.Context) (v domain.OrderPaidChannels, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidChannels: %w", err)
	}
	return oldValue.PaidChannels, nil
}

// AppendPaidChannels adds dpc to the "paid_channels" field.
func (m *OrderMutation) AppendPaidChannels(dpc domain.OrderPaidChannels) {
	m.appendpaid_channels = append(m.appendpaid_channels, dpc...)
}

// AppendedPaidChannels returns the list of values that were appended to the "paid_channels" field in this mutation.
func (m *OrderMutation) AppendedPaidChannels() (domain.OrderPaidChannels, bool) {
	if len(m.appendpaid_channels) == 0 {
		return nil, false
	}
	return m.appendpaid_channels, true
}

// ClearPaidChannels clears the value of the "paid_channels" field.
func (m *OrderMutation) ClearPaidChannels() {
	m.paid_channels = nil
	m.appendpaid_channels = nil
	m.clearedFields[order.FieldPaidChannels] = struct{}{}
}

// PaidChannelsCleared returns if the "paid_channels" field was cleared in this mutation.
func (m *OrderMutation) PaidChannelsCleared() bool {
	_, ok := m.clearedFields[order.FieldPaidChannels]
	return ok
}

// ResetPaidChannels resets all changes to the "paid_channels" field.
func (m *OrderMutation) ResetPaidChannels() {
	m.paid_channels = nil
	m.appendpaid_channels = nil
	delete(m.clearedFields, order.FieldPaidChannels)
}

// SetCashPaid sets the "cash_paid" field.
func (m *OrderMutation) SetCashPaid(d decimal.Decimal) {
	m.cash_paid = &d
}

// CashPaid returns the value of the "cash_paid" field in the mutation.
func (m *OrderMutation) CashPaid() (r decimal.Decimal, exists bool) {
	v := m.cash_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldCashPaid returns the old "cash_paid" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCashPaid(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashPaid: %w", err)
	}
	return oldValue.CashPaid, nil
}

// ResetCashPaid resets all changes to the "cash_paid" field.
func (m *OrderMutation) ResetCashPaid() {
	m.cash_paid = nil
}

// SetCashRefunded sets the "cash_refunded" field.
func (m *OrderMutation) SetCashRefunded(d decimal.Decimal) {
	m.cash_refunded = &d
}

// CashRefunded returns the value of the "cash_refunded" field in the mutation.
func (m *OrderMutation) CashRefunded() (r decimal.Decimal, exists bool) {
	v := m.cash_refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldCashRefunded returns the old "cash_refunded" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCashRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashRefunded: %w", err)
	}
	return oldValue.CashRefunded, nil
}

// ResetCashRefunded resets all changes to the "cash_refunded" field.
func (m *OrderMutation) ResetCashRefunded() {
	m.cash_refunded = nil
}

// SetWechatPaid sets the "wechat_paid" field.
func (m *OrderMutation) SetWechatPaid(d decimal.Decimal) {
	m.wechat_paid = &d
}

// WechatPaid returns the value of the "wechat_paid" field in the mutation.
func (m *OrderMutation) WechatPaid() (r decimal.Decimal, exists bool) {
	v := m.wechat_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldWechatPaid returns the old "wechat_paid" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldWechatPaid(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWechatPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWechatPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWechatPaid: %w", err)
	}
	return oldValue.WechatPaid, nil
}

// ResetWechatPaid resets all changes to the "wechat_paid" field.
func (m *OrderMutation) ResetWechatPaid() {
	m.wechat_paid = nil
}

// SetWechatRefunded sets the "wechat_refunded" field.
func (m *OrderMutation) SetWechatRefunded(d decimal.Decimal) {
	m.wechat_refunded = &d
}

// WechatRefunded returns the value of the "wechat_refunded" field in the mutation.
func (m *OrderMutation) WechatRefunded() (r decimal.Decimal, exists bool) {
	v := m.wechat_refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldWechatRefunded returns the old "wechat_refunded" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldWechatRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWechatRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWechatRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWechatRefunded: %w", err)
	}
	return oldValue.WechatRefunded, nil
}

// ResetWechatRefunded resets all changes to the "wechat_refunded" field.
func (m *OrderMutation) ResetWechatRefunded() {
	m.wechat_refunded = nil
}

// SetAlipayPaid sets the "alipay_paid" field.
func (m *OrderMutation) SetAlipayPaid(d decimal.Decimal) {
	m.alipay_paid = &d
}

// AlipayPaid returns the value of the "alipay_paid" field in the mutation.
func (m *OrderMutation) AlipayPaid() (r decimal.Decimal, exists bool) {
	v := m.alipay_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldAlipayPaid returns the old "alipay_paid" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAlipayPaid(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlipayPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlipayPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlipayPaid: %w", err)
	}
	return oldValue.AlipayPaid, nil
}

// ResetAlipayPaid resets all changes to the "alipay_paid" field.
func (m *OrderMutation) ResetAlipayPaid() {
	m.alipay_paid = nil
}

// SetAlipayRefunded sets the "alipay_refunded" field.
func (m *OrderMutation) SetAlipayRefunded(d decimal.Decimal) {
	m.alipay_refunded = &d
}

// AlipayRefunded returns the value of the "alipay_refunded" field in the mutation.
func (m *OrderMutation) AlipayRefunded() (r decimal.Decimal, exists bool) {
	v := m.alipay_refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldAlipayRefunded returns the old "alipay_refunded" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAlipayRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlipayRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlipayRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlipayRefunded: %w", err)
	}
	return oldValue.AlipayRefunded, nil
}

// ResetAlipayRefunded resets all changes to the "alipay_refunded" field.
func (m *OrderMutation) ResetAlipayRefunded() {
	m.alipay_refunded = nil
}

// SetPointsPaid sets the "points_paid" field.
func (m *OrderMutation) SetPointsPaid(d decimal.Decimal) {
	m.points_paid = &d
}

// PointsPaid returns the value of the "points_paid" field in the mutation.
func (m *OrderMutation) PointsPaid() (r decimal.Decimal, exists bool) {
	v := m.points_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldPointsPaid returns the old "points_paid" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPointsPaid(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointsPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointsPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointsPaid: %w", err)
	}
	return oldValue.PointsPaid, nil
}

// ResetPointsPaid resets all changes to the "points_paid" field.
func (m *OrderMutation) ResetPointsPaid() {
	m.points_paid = nil
}

// SetPointsRefunded sets the "points_refunded" field.
func (m *OrderMutation) SetPointsRefunded(d decimal.Decimal) {
	m.points_refunded = &d
}

// PointsRefunded returns the value of the "points_refunded" field in the mutation.
func (m *OrderMutation) PointsRefunded() (r decimal.Decimal, exists bool) {
	v := m.points_refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldPointsRefunded returns the old "points_refunded" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPointsRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointsRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointsRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointsRefunded: %w", err)
	}
	return oldValue.PointsRefunded, nil
}

// ResetPointsRefunded resets all changes to the "points_refunded" field.
func (m *OrderMutation) ResetPointsRefunded() {
	m.points_refunded = nil
}

// SetPointsWalletPaid sets the "points_wallet_paid" field.
func (m *OrderMutation) SetPointsWalletPaid(d decimal.Decimal) {
	m.points_wallet_paid = &d
}

// PointsWalletPaid returns the value of the "points_wallet_paid" field in the mutation.
func (m *OrderMutation) PointsWalletPaid() (r decimal.Decimal, exists bool) {
	v := m.points_wallet_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldPointsWalletPaid returns the old "points_wallet_paid" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPointsWalletPaid(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointsWalletPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointsWalletPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointsWalletPaid: %w", err)
	}
	return oldValue.PointsWalletPaid, nil
}

// ResetPointsWalletPaid resets all changes to the "points_wallet_paid" field.
func (m *OrderMutation) ResetPointsWalletPaid() {
	m.points_wallet_paid = nil
}

// SetPointsWalletRefunded sets the "points_wallet_refunded" field.
func (m *OrderMutation) SetPointsWalletRefunded(d decimal.Decimal) {
	m.points_wallet_refunded = &d
}

// PointsWalletRefunded returns the value of the "points_wallet_refunded" field in the mutation.
func (m *OrderMutation) PointsWalletRefunded() (r decimal.Decimal, exists bool) {
	v := m.points_wallet_refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldPointsWalletRefunded returns the old "points_wallet_refunded" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPointsWalletRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointsWalletRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointsWalletRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointsWalletRefunded: %w", err)
	}
	return oldValue.PointsWalletRefunded, nil
}

// ResetPointsWalletRefunded resets all changes to the "points_wallet_refunded" field.
func (m *OrderMutation) ResetPointsWalletRefunded() {
	m.points_wallet_refunded = nil
}

// SetLastPaidAt sets the "last_paid_at" field.
func (m *OrderMutation) SetLastPaidAt(t time.Time) {
	m.last_paid_at = &t
}

// LastPaidAt returns the value of the "last_paid_at" field in the mutation.
func (m *OrderMutation) LastPaidAt() (r time.Time, exists bool) {
	v := m.last_paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPaidAt returns the old "last_paid_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldLastPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPaidAt: %w", err)
	}
	return oldValue.LastPaidAt, nil
}

// ClearLastPaidAt clears the value of the "last_paid_at" field.
func (m *OrderMutation) ClearLastPaidAt() {
	m.last_paid_at = nil
	m.clearedFields[order.FieldLastPaidAt] = struct{}{}
}

// LastPaidAtCleared returns if the "last_paid_at" field was cleared in this mutation.
func (m *OrderMutation) LastPaidAtCleared() bool {
	_, ok := m.clearedFields[order.FieldLastPaidAt]
	return ok
}

// ResetLastPaidAt resets all changes to the "last_paid_at" field.
func (m *OrderMutation) ResetLastPaidAt() {
	m.last_paid_at = nil
	delete(m.clearedFields, order.FieldLastPaidAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *OrderMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *OrderMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *OrderMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[order.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *OrderMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *OrderMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, order.FieldFinishedAt)
}

// SetMemberID sets the "member_id" field.
func (m *OrderMutation) SetMemberID(i int) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderMutation) MemberID() (r int, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *OrderMutation) AddMemberID(i int) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *OrderMutation) AddedMemberID() (r int, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
}

// SetMemberName sets the "member_name" field.
func (m *OrderMutation) SetMemberName(s string) {
	m.member_name = &s
}

// MemberName returns the value of the "member_name" field in the mutation.
func (m *OrderMutation) MemberName() (r string, exists bool) {
	v := m.member_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberName returns the old "member_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberName: %w", err)
	}
	return oldValue.MemberName, nil
}

// ResetMemberName resets all changes to the "member_name" field.
func (m *OrderMutation) ResetMemberName() {
	m.member_name = nil
}

// SetMemberPhone sets the "member_phone" field.
func (m *OrderMutation) SetMemberPhone(s string) {
	m.member_phone = &s
}

// MemberPhone returns the value of the "member_phone" field in the mutation.
func (m *OrderMutation) MemberPhone() (r string, exists bool) {
	v := m.member_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPhone returns the old "member_phone" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPhone: %w", err)
	}
	return oldValue.MemberPhone, nil
}

// ResetMemberPhone resets all changes to the "member_phone" field.
func (m *OrderMutation) ResetMemberPhone() {
	m.member_phone = nil
}

// SetStoreID sets the "store_id" field.
func (m *OrderMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *OrderMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *OrderMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *OrderMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *OrderMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetStoreName sets the "store_name" field.
func (m *OrderMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *OrderMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *OrderMutation) ResetStoreName() {
	m.store_name = nil
}

// SetTableID sets the "table_id" field.
func (m *OrderMutation) SetTableID(i int) {
	m.dinetable = &i
}

// TableID returns the value of the "table_id" field in the mutation.
func (m *OrderMutation) TableID() (r int, exists bool) {
	v := m.dinetable
	if v == nil {
		return
	}
	return *v, true
}

// OldTableID returns the old "table_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTableID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableID: %w", err)
	}
	return oldValue.TableID, nil
}

// ClearTableID clears the value of the "table_id" field.
func (m *OrderMutation) ClearTableID() {
	m.dinetable = nil
	m.clearedFields[order.FieldTableID] = struct{}{}
}

// TableIDCleared returns if the "table_id" field was cleared in this mutation.
func (m *OrderMutation) TableIDCleared() bool {
	_, ok := m.clearedFields[order.FieldTableID]
	return ok
}

// ResetTableID resets all changes to the "table_id" field.
func (m *OrderMutation) ResetTableID() {
	m.dinetable = nil
	delete(m.clearedFields, order.FieldTableID)
}

// SetTableName sets the "table_name" field.
func (m *OrderMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *OrderMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ResetTableName resets all changes to the "table_name" field.
func (m *OrderMutation) ResetTableName() {
	m.table_name = nil
}

// SetPeopleNumber sets the "people_number" field.
func (m *OrderMutation) SetPeopleNumber(i int) {
	m.people_number = &i
	m.addpeople_number = nil
}

// PeopleNumber returns the value of the "people_number" field in the mutation.
func (m *OrderMutation) PeopleNumber() (r int, exists bool) {
	v := m.people_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPeopleNumber returns the old "people_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPeopleNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeopleNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeopleNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeopleNumber: %w", err)
	}
	return oldValue.PeopleNumber, nil
}

// AddPeopleNumber adds i to the "people_number" field.
func (m *OrderMutation) AddPeopleNumber(i int) {
	if m.addpeople_number != nil {
		*m.addpeople_number += i
	} else {
		m.addpeople_number = &i
	}
}

// AddedPeopleNumber returns the value that was added to the "people_number" field in this mutation.
func (m *OrderMutation) AddedPeopleNumber() (r int, exists bool) {
	v := m.addpeople_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeopleNumber resets all changes to the "people_number" field.
func (m *OrderMutation) ResetPeopleNumber() {
	m.people_number = nil
	m.addpeople_number = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *OrderMutation) SetCreatorID(i int) {
	m.creator_id = &i
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *OrderMutation) CreatorID() (r int, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds i to the "creator_id" field.
func (m *OrderMutation) AddCreatorID(i int) {
	if m.addcreator_id != nil {
		*m.addcreator_id += i
	} else {
		m.addcreator_id = &i
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *OrderMutation) AddedCreatorID() (r int, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *OrderMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
}

// SetCreatorName sets the "creator_name" field.
func (m *OrderMutation) SetCreatorName(s string) {
	m.creator_name = &s
}

// CreatorName returns the value of the "creator_name" field in the mutation.
func (m *OrderMutation) CreatorName() (r string, exists bool) {
	v := m.creator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorName returns the old "creator_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorName: %w", err)
	}
	return oldValue.CreatorName, nil
}

// ResetCreatorName resets all changes to the "creator_name" field.
func (m *OrderMutation) ResetCreatorName() {
	m.creator_name = nil
}

// SetCreatorType sets the "creator_type" field.
func (m *OrderMutation) SetCreatorType(dt domain.OperatorType) {
	m.creator_type = &dt
}

// CreatorType returns the value of the "creator_type" field in the mutation.
func (m *OrderMutation) CreatorType() (r domain.OperatorType, exists bool) {
	v := m.creator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorType returns the old "creator_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatorType(ctx context.Context) (v domain.OperatorType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorType: %w", err)
	}
	return oldValue.CreatorType, nil
}

// ResetCreatorType resets all changes to the "creator_type" field.
func (m *OrderMutation) ResetCreatorType() {
	m.creator_type = nil
}

// AddItemIDs adds the "items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the OrderItem entity.
func (m *OrderMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *OrderMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *OrderMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddLogIDs adds the "logs" edge to the OrderLog entity by ids.
func (m *OrderMutation) AddLogIDs(ids ...int) {
	if m.logs == nil {
		m.logs = make(map[int]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the OrderLog entity.
func (m *OrderMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the OrderLog entity was cleared.
func (m *OrderMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the OrderLog entity by IDs.
func (m *OrderMutation) RemoveLogIDs(ids ...int) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the OrderLog entity.
func (m *OrderMutation) RemovedLogsIDs() (ids []int) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *OrderMutation) LogsIDs() (ids []int) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *OrderMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// SetCurrentDinetableID sets the "current_dinetable" edge to the DineTable entity by id.
func (m *OrderMutation) SetCurrentDinetableID(id int) {
	m.current_dinetable = &id
}

// ClearCurrentDinetable clears the "current_dinetable" edge to the DineTable entity.
func (m *OrderMutation) ClearCurrentDinetable() {
	m.clearedcurrent_dinetable = true
}

// CurrentDinetableCleared reports if the "current_dinetable" edge to the DineTable entity was cleared.
func (m *OrderMutation) CurrentDinetableCleared() bool {
	return m.clearedcurrent_dinetable
}

// CurrentDinetableID returns the "current_dinetable" edge ID in the mutation.
func (m *OrderMutation) CurrentDinetableID() (id int, exists bool) {
	if m.current_dinetable != nil {
		return *m.current_dinetable, true
	}
	return
}

// CurrentDinetableIDs returns the "current_dinetable" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrentDinetableID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CurrentDinetableIDs() (ids []int) {
	if id := m.current_dinetable; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrentDinetable resets all changes to the "current_dinetable" edge.
func (m *OrderMutation) ResetCurrentDinetable() {
	m.current_dinetable = nil
	m.clearedcurrent_dinetable = false
}

// SetDinetableID sets the "dinetable" edge to the DineTable entity by id.
func (m *OrderMutation) SetDinetableID(id int) {
	m.dinetable = &id
}

// ClearDinetable clears the "dinetable" edge to the DineTable entity.
func (m *OrderMutation) ClearDinetable() {
	m.cleareddinetable = true
	m.clearedFields[order.FieldTableID] = struct{}{}
}

// DinetableCleared reports if the "dinetable" edge to the DineTable entity was cleared.
func (m *OrderMutation) DinetableCleared() bool {
	return m.TableIDCleared() || m.cleareddinetable
}

// DinetableID returns the "dinetable" edge ID in the mutation.
func (m *OrderMutation) DinetableID() (id int, exists bool) {
	if m.dinetable != nil {
		return *m.dinetable, true
	}
	return
}

// DinetableIDs returns the "dinetable" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DinetableID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) DinetableIDs() (ids []int) {
	if id := m.dinetable; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDinetable resets all changes to the "dinetable" edge.
func (m *OrderMutation) ResetDinetable() {
	m.dinetable = nil
	m.cleareddinetable = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.no != nil {
		fields = append(fields, order.FieldNo)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.source != nil {
		fields = append(fields, order.FieldSource)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.total_price != nil {
		fields = append(fields, order.FieldTotalPrice)
	}
	if m.discount != nil {
		fields = append(fields, order.FieldDiscount)
	}
	if m.real_price != nil {
		fields = append(fields, order.FieldRealPrice)
	}
	if m.points_available != nil {
		fields = append(fields, order.FieldPointsAvailable)
	}
	if m.paid != nil {
		fields = append(fields, order.FieldPaid)
	}
	if m.refunded != nil {
		fields = append(fields, order.FieldRefunded)
	}
	if m.paid_channels != nil {
		fields = append(fields, order.FieldPaidChannels)
	}
	if m.cash_paid != nil {
		fields = append(fields, order.FieldCashPaid)
	}
	if m.cash_refunded != nil {
		fields = append(fields, order.FieldCashRefunded)
	}
	if m.wechat_paid != nil {
		fields = append(fields, order.FieldWechatPaid)
	}
	if m.wechat_refunded != nil {
		fields = append(fields, order.FieldWechatRefunded)
	}
	if m.alipay_paid != nil {
		fields = append(fields, order.FieldAlipayPaid)
	}
	if m.alipay_refunded != nil {
		fields = append(fields, order.FieldAlipayRefunded)
	}
	if m.points_paid != nil {
		fields = append(fields, order.FieldPointsPaid)
	}
	if m.points_refunded != nil {
		fields = append(fields, order.FieldPointsRefunded)
	}
	if m.points_wallet_paid != nil {
		fields = append(fields, order.FieldPointsWalletPaid)
	}
	if m.points_wallet_refunded != nil {
		fields = append(fields, order.FieldPointsWalletRefunded)
	}
	if m.last_paid_at != nil {
		fields = append(fields, order.FieldLastPaidAt)
	}
	if m.finished_at != nil {
		fields = append(fields, order.FieldFinishedAt)
	}
	if m.member_id != nil {
		fields = append(fields, order.FieldMemberID)
	}
	if m.member_name != nil {
		fields = append(fields, order.FieldMemberName)
	}
	if m.member_phone != nil {
		fields = append(fields, order.FieldMemberPhone)
	}
	if m.store_id != nil {
		fields = append(fields, order.FieldStoreID)
	}
	if m.store_name != nil {
		fields = append(fields, order.FieldStoreName)
	}
	if m.dinetable != nil {
		fields = append(fields, order.FieldTableID)
	}
	if m.table_name != nil {
		fields = append(fields, order.FieldTableName)
	}
	if m.people_number != nil {
		fields = append(fields, order.FieldPeopleNumber)
	}
	if m.creator_id != nil {
		fields = append(fields, order.FieldCreatorID)
	}
	if m.creator_name != nil {
		fields = append(fields, order.FieldCreatorName)
	}
	if m.creator_type != nil {
		fields = append(fields, order.FieldCreatorType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldNo:
		return m.No()
	case order.FieldType:
		return m.GetType()
	case order.FieldSource:
		return m.Source()
	case order.FieldStatus:
		return m.Status()
	case order.FieldTotalPrice:
		return m.TotalPrice()
	case order.FieldDiscount:
		return m.Discount()
	case order.FieldRealPrice:
		return m.RealPrice()
	case order.FieldPointsAvailable:
		return m.PointsAvailable()
	case order.FieldPaid:
		return m.Paid()
	case order.FieldRefunded:
		return m.Refunded()
	case order.FieldPaidChannels:
		return m.PaidChannels()
	case order.FieldCashPaid:
		return m.CashPaid()
	case order.FieldCashRefunded:
		return m.CashRefunded()
	case order.FieldWechatPaid:
		return m.WechatPaid()
	case order.FieldWechatRefunded:
		return m.WechatRefunded()
	case order.FieldAlipayPaid:
		return m.AlipayPaid()
	case order.FieldAlipayRefunded:
		return m.AlipayRefunded()
	case order.FieldPointsPaid:
		return m.PointsPaid()
	case order.FieldPointsRefunded:
		return m.PointsRefunded()
	case order.FieldPointsWalletPaid:
		return m.PointsWalletPaid()
	case order.FieldPointsWalletRefunded:
		return m.PointsWalletRefunded()
	case order.FieldLastPaidAt:
		return m.LastPaidAt()
	case order.FieldFinishedAt:
		return m.FinishedAt()
	case order.FieldMemberID:
		return m.MemberID()
	case order.FieldMemberName:
		return m.MemberName()
	case order.FieldMemberPhone:
		return m.MemberPhone()
	case order.FieldStoreID:
		return m.StoreID()
	case order.FieldStoreName:
		return m.StoreName()
	case order.FieldTableID:
		return m.TableID()
	case order.FieldTableName:
		return m.TableName()
	case order.FieldPeopleNumber:
		return m.PeopleNumber()
	case order.FieldCreatorID:
		return m.CreatorID()
	case order.FieldCreatorName:
		return m.CreatorName()
	case order.FieldCreatorType:
		return m.CreatorType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldNo:
		return m.OldNo(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldSource:
		return m.OldSource(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case order.FieldDiscount:
		return m.OldDiscount(ctx)
	case order.FieldRealPrice:
		return m.OldRealPrice(ctx)
	case order.FieldPointsAvailable:
		return m.OldPointsAvailable(ctx)
	case order.FieldPaid:
		return m.OldPaid(ctx)
	case order.FieldRefunded:
		return m.OldRefunded(ctx)
	case order.FieldPaidChannels:
		return m.OldPaidChannels(ctx)
	case order.FieldCashPaid:
		return m.OldCashPaid(ctx)
	case order.FieldCashRefunded:
		return m.OldCashRefunded(ctx)
	case order.FieldWechatPaid:
		return m.OldWechatPaid(ctx)
	case order.FieldWechatRefunded:
		return m.OldWechatRefunded(ctx)
	case order.FieldAlipayPaid:
		return m.OldAlipayPaid(ctx)
	case order.FieldAlipayRefunded:
		return m.OldAlipayRefunded(ctx)
	case order.FieldPointsPaid:
		return m.OldPointsPaid(ctx)
	case order.FieldPointsRefunded:
		return m.OldPointsRefunded(ctx)
	case order.FieldPointsWalletPaid:
		return m.OldPointsWalletPaid(ctx)
	case order.FieldPointsWalletRefunded:
		return m.OldPointsWalletRefunded(ctx)
	case order.FieldLastPaidAt:
		return m.OldLastPaidAt(ctx)
	case order.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case order.FieldMemberID:
		return m.OldMemberID(ctx)
	case order.FieldMemberName:
		return m.OldMemberName(ctx)
	case order.FieldMemberPhone:
		return m.OldMemberPhone(ctx)
	case order.FieldStoreID:
		return m.OldStoreID(ctx)
	case order.FieldStoreName:
		return m.OldStoreName(ctx)
	case order.FieldTableID:
		return m.OldTableID(ctx)
	case order.FieldTableName:
		return m.OldTableName(ctx)
	case order.FieldPeopleNumber:
		return m.OldPeopleNumber(ctx)
	case order.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case order.FieldCreatorName:
		return m.OldCreatorName(ctx)
	case order.FieldCreatorType:
		return m.OldCreatorType(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case order.FieldType:
		v, ok := value.(domain.OrderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldSource:
		v, ok := value.(domain.OrderSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(domain.OrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldTotalPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case order.FieldDiscount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case order.FieldRealPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealPrice(v)
		return nil
	case order.FieldPointsAvailable:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointsAvailable(v)
		return nil
	case order.FieldPaid:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaid(v)
		return nil
	case order.FieldRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefunded(v)
		return nil
	case order.FieldPaidChannels:
		v, ok := value.(domain.OrderPaidChannels)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidChannels(v)
		return nil
	case order.FieldCashPaid:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashPaid(v)
		return nil
	case order.FieldCashRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashRefunded(v)
		return nil
	case order.FieldWechatPaid:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWechatPaid(v)
		return nil
	case order.FieldWechatRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWechatRefunded(v)
		return nil
	case order.FieldAlipayPaid:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlipayPaid(v)
		return nil
	case order.FieldAlipayRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlipayRefunded(v)
		return nil
	case order.FieldPointsPaid:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointsPaid(v)
		return nil
	case order.FieldPointsRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointsRefunded(v)
		return nil
	case order.FieldPointsWalletPaid:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointsWalletPaid(v)
		return nil
	case order.FieldPointsWalletRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointsWalletRefunded(v)
		return nil
	case order.FieldLastPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPaidAt(v)
		return nil
	case order.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case order.FieldMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case order.FieldMemberName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberName(v)
		return nil
	case order.FieldMemberPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPhone(v)
		return nil
	case order.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case order.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case order.FieldTableID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableID(v)
		return nil
	case order.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case order.FieldPeopleNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeopleNumber(v)
		return nil
	case order.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case order.FieldCreatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorName(v)
		return nil
	case order.FieldCreatorType:
		v, ok := value.(domain.OperatorType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorType(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.addmember_id != nil {
		fields = append(fields, order.FieldMemberID)
	}
	if m.addstore_id != nil {
		fields = append(fields, order.FieldStoreID)
	}
	if m.addpeople_number != nil {
		fields = append(fields, order.FieldPeopleNumber)
	}
	if m.addcreator_id != nil {
		fields = append(fields, order.FieldCreatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldDeletedAt:
		return m.AddedDeletedAt()
	case order.FieldMemberID:
		return m.AddedMemberID()
	case order.FieldStoreID:
		return m.AddedStoreID()
	case order.FieldPeopleNumber:
		return m.AddedPeopleNumber()
	case order.FieldCreatorID:
		return m.AddedCreatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case order.FieldMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case order.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case order.FieldPeopleNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeopleNumber(v)
		return nil
	case order.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldPaidChannels) {
		fields = append(fields, order.FieldPaidChannels)
	}
	if m.FieldCleared(order.FieldLastPaidAt) {
		fields = append(fields, order.FieldLastPaidAt)
	}
	if m.FieldCleared(order.FieldFinishedAt) {
		fields = append(fields, order.FieldFinishedAt)
	}
	if m.FieldCleared(order.FieldTableID) {
		fields = append(fields, order.FieldTableID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldPaidChannels:
		m.ClearPaidChannels()
		return nil
	case order.FieldLastPaidAt:
		m.ClearLastPaidAt()
		return nil
	case order.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case order.FieldTableID:
		m.ClearTableID()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldNo:
		m.ResetNo()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldSource:
		m.ResetSource()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case order.FieldDiscount:
		m.ResetDiscount()
		return nil
	case order.FieldRealPrice:
		m.ResetRealPrice()
		return nil
	case order.FieldPointsAvailable:
		m.ResetPointsAvailable()
		return nil
	case order.FieldPaid:
		m.ResetPaid()
		return nil
	case order.FieldRefunded:
		m.ResetRefunded()
		return nil
	case order.FieldPaidChannels:
		m.ResetPaidChannels()
		return nil
	case order.FieldCashPaid:
		m.ResetCashPaid()
		return nil
	case order.FieldCashRefunded:
		m.ResetCashRefunded()
		return nil
	case order.FieldWechatPaid:
		m.ResetWechatPaid()
		return nil
	case order.FieldWechatRefunded:
		m.ResetWechatRefunded()
		return nil
	case order.FieldAlipayPaid:
		m.ResetAlipayPaid()
		return nil
	case order.FieldAlipayRefunded:
		m.ResetAlipayRefunded()
		return nil
	case order.FieldPointsPaid:
		m.ResetPointsPaid()
		return nil
	case order.FieldPointsRefunded:
		m.ResetPointsRefunded()
		return nil
	case order.FieldPointsWalletPaid:
		m.ResetPointsWalletPaid()
		return nil
	case order.FieldPointsWalletRefunded:
		m.ResetPointsWalletRefunded()
		return nil
	case order.FieldLastPaidAt:
		m.ResetLastPaidAt()
		return nil
	case order.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case order.FieldMemberID:
		m.ResetMemberID()
		return nil
	case order.FieldMemberName:
		m.ResetMemberName()
		return nil
	case order.FieldMemberPhone:
		m.ResetMemberPhone()
		return nil
	case order.FieldStoreID:
		m.ResetStoreID()
		return nil
	case order.FieldStoreName:
		m.ResetStoreName()
		return nil
	case order.FieldTableID:
		m.ResetTableID()
		return nil
	case order.FieldTableName:
		m.ResetTableName()
		return nil
	case order.FieldPeopleNumber:
		m.ResetPeopleNumber()
		return nil
	case order.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case order.FieldCreatorName:
		m.ResetCreatorName()
		return nil
	case order.FieldCreatorType:
		m.ResetCreatorType()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.items != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.logs != nil {
		edges = append(edges, order.EdgeLogs)
	}
	if m.current_dinetable != nil {
		edges = append(edges, order.EdgeCurrentDinetable)
	}
	if m.dinetable != nil {
		edges = append(edges, order.EdgeDinetable)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeCurrentDinetable:
		if id := m.current_dinetable; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeDinetable:
		if id := m.dinetable; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeditems != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.removedlogs != nil {
		edges = append(edges, order.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareditems {
		edges = append(edges, order.EdgeItems)
	}
	if m.clearedlogs {
		edges = append(edges, order.EdgeLogs)
	}
	if m.clearedcurrent_dinetable {
		edges = append(edges, order.EdgeCurrentDinetable)
	}
	if m.cleareddinetable {
		edges = append(edges, order.EdgeDinetable)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeItems:
		return m.cleareditems
	case order.EdgeLogs:
		return m.clearedlogs
	case order.EdgeCurrentDinetable:
		return m.clearedcurrent_dinetable
	case order.EdgeDinetable:
		return m.cleareddinetable
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeCurrentDinetable:
		m.ClearCurrentDinetable()
		return nil
	case order.EdgeDinetable:
		m.ClearDinetable()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeItems:
		m.ResetItems()
		return nil
	case order.EdgeLogs:
		m.ResetLogs()
		return nil
	case order.EdgeCurrentDinetable:
		m.ResetCurrentDinetable()
		return nil
	case order.EdgeDinetable:
		m.ResetDinetable()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderCartMutation represents an operation that mutates the OrderCart nodes in the graph.
type OrderCartMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *int64
	adddeleted_at       *int64
	table_id            *int
	addtable_id         *int
	quantity            *decimal.Decimal
	clearedFields       map[string]struct{}
	product             *int
	clearedproduct      bool
	product_spec        *int
	clearedproduct_spec bool
	attr                *int
	clearedattr         bool
	recipe              *int
	clearedrecipe       bool
	done                bool
	oldValue            func(context.Context) (*OrderCart, error)
	predicates          []predicate.OrderCart
}

var _ ent.Mutation = (*OrderCartMutation)(nil)

// ordercartOption allows management of the mutation configuration using functional options.
type ordercartOption func(*OrderCartMutation)

// newOrderCartMutation creates new mutation for the OrderCart entity.
func newOrderCartMutation(c config, op Op, opts ...ordercartOption) *OrderCartMutation {
	m := &OrderCartMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderCart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderCartID sets the ID field of the mutation.
func withOrderCartID(id int) ordercartOption {
	return func(m *OrderCartMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderCart
		)
		m.oldValue = func(ctx context.Context) (*OrderCart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderCart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderCart sets the old OrderCart of the mutation.
func withOrderCart(node *OrderCart) ordercartOption {
	return func(m *OrderCartMutation) {
		m.oldValue = func(context.Context) (*OrderCart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderCartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderCartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderCartMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderCartMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderCart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderCartMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderCartMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderCartMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderCartMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderCartMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderCartMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderCartMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderCartMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderCartMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderCartMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderCartMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTableID sets the "table_id" field.
func (m *OrderCartMutation) SetTableID(i int) {
	m.table_id = &i
	m.addtable_id = nil
}

// TableID returns the value of the "table_id" field in the mutation.
func (m *OrderCartMutation) TableID() (r int, exists bool) {
	v := m.table_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTableID returns the old "table_id" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldTableID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableID: %w", err)
	}
	return oldValue.TableID, nil
}

// AddTableID adds i to the "table_id" field.
func (m *OrderCartMutation) AddTableID(i int) {
	if m.addtable_id != nil {
		*m.addtable_id += i
	} else {
		m.addtable_id = &i
	}
}

// AddedTableID returns the value that was added to the "table_id" field in this mutation.
func (m *OrderCartMutation) AddedTableID() (r int, exists bool) {
	v := m.addtable_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTableID resets all changes to the "table_id" field.
func (m *OrderCartMutation) ResetTableID() {
	m.table_id = nil
	m.addtable_id = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderCartMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderCartMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderCartMutation) ResetProductID() {
	m.product = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderCartMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderCartMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderCartMutation) ResetQuantity() {
	m.quantity = nil
}

// SetProductSpecID sets the "product_spec_id" field.
func (m *OrderCartMutation) SetProductSpecID(i int) {
	m.product_spec = &i
}

// ProductSpecID returns the value of the "product_spec_id" field in the mutation.
func (m *OrderCartMutation) ProductSpecID() (r int, exists bool) {
	v := m.product_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSpecID returns the old "product_spec_id" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldProductSpecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSpecID: %w", err)
	}
	return oldValue.ProductSpecID, nil
}

// ClearProductSpecID clears the value of the "product_spec_id" field.
func (m *OrderCartMutation) ClearProductSpecID() {
	m.product_spec = nil
	m.clearedFields[ordercart.FieldProductSpecID] = struct{}{}
}

// ProductSpecIDCleared returns if the "product_spec_id" field was cleared in this mutation.
func (m *OrderCartMutation) ProductSpecIDCleared() bool {
	_, ok := m.clearedFields[ordercart.FieldProductSpecID]
	return ok
}

// ResetProductSpecID resets all changes to the "product_spec_id" field.
func (m *OrderCartMutation) ResetProductSpecID() {
	m.product_spec = nil
	delete(m.clearedFields, ordercart.FieldProductSpecID)
}

// SetAttrID sets the "attr_id" field.
func (m *OrderCartMutation) SetAttrID(i int) {
	m.attr = &i
}

// AttrID returns the value of the "attr_id" field in the mutation.
func (m *OrderCartMutation) AttrID() (r int, exists bool) {
	v := m.attr
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrID returns the old "attr_id" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldAttrID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrID: %w", err)
	}
	return oldValue.AttrID, nil
}

// ClearAttrID clears the value of the "attr_id" field.
func (m *OrderCartMutation) ClearAttrID() {
	m.attr = nil
	m.clearedFields[ordercart.FieldAttrID] = struct{}{}
}

// AttrIDCleared returns if the "attr_id" field was cleared in this mutation.
func (m *OrderCartMutation) AttrIDCleared() bool {
	_, ok := m.clearedFields[ordercart.FieldAttrID]
	return ok
}

// ResetAttrID resets all changes to the "attr_id" field.
func (m *OrderCartMutation) ResetAttrID() {
	m.attr = nil
	delete(m.clearedFields, ordercart.FieldAttrID)
}

// SetRecipeID sets the "recipe_id" field.
func (m *OrderCartMutation) SetRecipeID(i int) {
	m.recipe = &i
}

// RecipeID returns the value of the "recipe_id" field in the mutation.
func (m *OrderCartMutation) RecipeID() (r int, exists bool) {
	v := m.recipe
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipeID returns the old "recipe_id" field's value of the OrderCart entity.
// If the OrderCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderCartMutation) OldRecipeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipeID: %w", err)
	}
	return oldValue.RecipeID, nil
}

// ClearRecipeID clears the value of the "recipe_id" field.
func (m *OrderCartMutation) ClearRecipeID() {
	m.recipe = nil
	m.clearedFields[ordercart.FieldRecipeID] = struct{}{}
}

// RecipeIDCleared returns if the "recipe_id" field was cleared in this mutation.
func (m *OrderCartMutation) RecipeIDCleared() bool {
	_, ok := m.clearedFields[ordercart.FieldRecipeID]
	return ok
}

// ResetRecipeID resets all changes to the "recipe_id" field.
func (m *OrderCartMutation) ResetRecipeID() {
	m.recipe = nil
	delete(m.clearedFields, ordercart.FieldRecipeID)
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderCartMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[ordercart.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderCartMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderCartMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderCartMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearProductSpec clears the "product_spec" edge to the ProductSpec entity.
func (m *OrderCartMutation) ClearProductSpec() {
	m.clearedproduct_spec = true
	m.clearedFields[ordercart.FieldProductSpecID] = struct{}{}
}

// ProductSpecCleared reports if the "product_spec" edge to the ProductSpec entity was cleared.
func (m *OrderCartMutation) ProductSpecCleared() bool {
	return m.ProductSpecIDCleared() || m.clearedproduct_spec
}

// ProductSpecIDs returns the "product_spec" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductSpecID instead. It exists only for internal usage by the builders.
func (m *OrderCartMutation) ProductSpecIDs() (ids []int) {
	if id := m.product_spec; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductSpec resets all changes to the "product_spec" edge.
func (m *OrderCartMutation) ResetProductSpec() {
	m.product_spec = nil
	m.clearedproduct_spec = false
}

// ClearAttr clears the "attr" edge to the Attr entity.
func (m *OrderCartMutation) ClearAttr() {
	m.clearedattr = true
	m.clearedFields[ordercart.FieldAttrID] = struct{}{}
}

// AttrCleared reports if the "attr" edge to the Attr entity was cleared.
func (m *OrderCartMutation) AttrCleared() bool {
	return m.AttrIDCleared() || m.clearedattr
}

// AttrIDs returns the "attr" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttrID instead. It exists only for internal usage by the builders.
func (m *OrderCartMutation) AttrIDs() (ids []int) {
	if id := m.attr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttr resets all changes to the "attr" edge.
func (m *OrderCartMutation) ResetAttr() {
	m.attr = nil
	m.clearedattr = false
}

// ClearRecipe clears the "recipe" edge to the Recipe entity.
func (m *OrderCartMutation) ClearRecipe() {
	m.clearedrecipe = true
	m.clearedFields[ordercart.FieldRecipeID] = struct{}{}
}

// RecipeCleared reports if the "recipe" edge to the Recipe entity was cleared.
func (m *OrderCartMutation) RecipeCleared() bool {
	return m.RecipeIDCleared() || m.clearedrecipe
}

// RecipeIDs returns the "recipe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipeID instead. It exists only for internal usage by the builders.
func (m *OrderCartMutation) RecipeIDs() (ids []int) {
	if id := m.recipe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipe resets all changes to the "recipe" edge.
func (m *OrderCartMutation) ResetRecipe() {
	m.recipe = nil
	m.clearedrecipe = false
}

// Where appends a list predicates to the OrderCartMutation builder.
func (m *OrderCartMutation) Where(ps ...predicate.OrderCart) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderCartMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderCartMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderCart, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderCartMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderCartMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderCart).
func (m *OrderCartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderCartMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, ordercart.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordercart.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ordercart.FieldDeletedAt)
	}
	if m.table_id != nil {
		fields = append(fields, ordercart.FieldTableID)
	}
	if m.product != nil {
		fields = append(fields, ordercart.FieldProductID)
	}
	if m.quantity != nil {
		fields = append(fields, ordercart.FieldQuantity)
	}
	if m.product_spec != nil {
		fields = append(fields, ordercart.FieldProductSpecID)
	}
	if m.attr != nil {
		fields = append(fields, ordercart.FieldAttrID)
	}
	if m.recipe != nil {
		fields = append(fields, ordercart.FieldRecipeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderCartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordercart.FieldCreatedAt:
		return m.CreatedAt()
	case ordercart.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordercart.FieldDeletedAt:
		return m.DeletedAt()
	case ordercart.FieldTableID:
		return m.TableID()
	case ordercart.FieldProductID:
		return m.ProductID()
	case ordercart.FieldQuantity:
		return m.Quantity()
	case ordercart.FieldProductSpecID:
		return m.ProductSpecID()
	case ordercart.FieldAttrID:
		return m.AttrID()
	case ordercart.FieldRecipeID:
		return m.RecipeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderCartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordercart.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordercart.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordercart.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ordercart.FieldTableID:
		return m.OldTableID(ctx)
	case ordercart.FieldProductID:
		return m.OldProductID(ctx)
	case ordercart.FieldQuantity:
		return m.OldQuantity(ctx)
	case ordercart.FieldProductSpecID:
		return m.OldProductSpecID(ctx)
	case ordercart.FieldAttrID:
		return m.OldAttrID(ctx)
	case ordercart.FieldRecipeID:
		return m.OldRecipeID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderCart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderCartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordercart.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordercart.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordercart.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ordercart.FieldTableID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableID(v)
		return nil
	case ordercart.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case ordercart.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case ordercart.FieldProductSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSpecID(v)
		return nil
	case ordercart.FieldAttrID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrID(v)
		return nil
	case ordercart.FieldRecipeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipeID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderCart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderCartMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, ordercart.FieldDeletedAt)
	}
	if m.addtable_id != nil {
		fields = append(fields, ordercart.FieldTableID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderCartMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordercart.FieldDeletedAt:
		return m.AddedDeletedAt()
	case ordercart.FieldTableID:
		return m.AddedTableID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderCartMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordercart.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case ordercart.FieldTableID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTableID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderCart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderCartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordercart.FieldProductSpecID) {
		fields = append(fields, ordercart.FieldProductSpecID)
	}
	if m.FieldCleared(ordercart.FieldAttrID) {
		fields = append(fields, ordercart.FieldAttrID)
	}
	if m.FieldCleared(ordercart.FieldRecipeID) {
		fields = append(fields, ordercart.FieldRecipeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderCartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderCartMutation) ClearField(name string) error {
	switch name {
	case ordercart.FieldProductSpecID:
		m.ClearProductSpecID()
		return nil
	case ordercart.FieldAttrID:
		m.ClearAttrID()
		return nil
	case ordercart.FieldRecipeID:
		m.ClearRecipeID()
		return nil
	}
	return fmt.Errorf("unknown OrderCart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderCartMutation) ResetField(name string) error {
	switch name {
	case ordercart.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordercart.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordercart.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ordercart.FieldTableID:
		m.ResetTableID()
		return nil
	case ordercart.FieldProductID:
		m.ResetProductID()
		return nil
	case ordercart.FieldQuantity:
		m.ResetQuantity()
		return nil
	case ordercart.FieldProductSpecID:
		m.ResetProductSpecID()
		return nil
	case ordercart.FieldAttrID:
		m.ResetAttrID()
		return nil
	case ordercart.FieldRecipeID:
		m.ResetRecipeID()
		return nil
	}
	return fmt.Errorf("unknown OrderCart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderCartMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.product != nil {
		edges = append(edges, ordercart.EdgeProduct)
	}
	if m.product_spec != nil {
		edges = append(edges, ordercart.EdgeProductSpec)
	}
	if m.attr != nil {
		edges = append(edges, ordercart.EdgeAttr)
	}
	if m.recipe != nil {
		edges = append(edges, ordercart.EdgeRecipe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderCartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordercart.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case ordercart.EdgeProductSpec:
		if id := m.product_spec; id != nil {
			return []ent.Value{*id}
		}
	case ordercart.EdgeAttr:
		if id := m.attr; id != nil {
			return []ent.Value{*id}
		}
	case ordercart.EdgeRecipe:
		if id := m.recipe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderCartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderCartMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderCartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproduct {
		edges = append(edges, ordercart.EdgeProduct)
	}
	if m.clearedproduct_spec {
		edges = append(edges, ordercart.EdgeProductSpec)
	}
	if m.clearedattr {
		edges = append(edges, ordercart.EdgeAttr)
	}
	if m.clearedrecipe {
		edges = append(edges, ordercart.EdgeRecipe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderCartMutation) EdgeCleared(name string) bool {
	switch name {
	case ordercart.EdgeProduct:
		return m.clearedproduct
	case ordercart.EdgeProductSpec:
		return m.clearedproduct_spec
	case ordercart.EdgeAttr:
		return m.clearedattr
	case ordercart.EdgeRecipe:
		return m.clearedrecipe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderCartMutation) ClearEdge(name string) error {
	switch name {
	case ordercart.EdgeProduct:
		m.ClearProduct()
		return nil
	case ordercart.EdgeProductSpec:
		m.ClearProductSpec()
		return nil
	case ordercart.EdgeAttr:
		m.ClearAttr()
		return nil
	case ordercart.EdgeRecipe:
		m.ClearRecipe()
		return nil
	}
	return fmt.Errorf("unknown OrderCart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderCartMutation) ResetEdge(name string) error {
	switch name {
	case ordercart.EdgeProduct:
		m.ResetProduct()
		return nil
	case ordercart.EdgeProductSpec:
		m.ResetProductSpec()
		return nil
	case ordercart.EdgeAttr:
		m.ResetAttr()
		return nil
	case ordercart.EdgeRecipe:
		m.ResetRecipe()
		return nil
	}
	return fmt.Errorf("unknown OrderCart edge %s", name)
}

// OrderFinanceLogMutation represents an operation that mutates the OrderFinanceLog nodes in the graph.
type OrderFinanceLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int64
	adddeleted_at *int64
	order_id      *int
	addorder_id   *int
	amount        *decimal.Decimal
	_type         *domain.OrderFinanceLogType
	channel       *domain.OrderPaidChannel
	seq_no        *string
	creator_type  *domain.OperatorType
	creator_id    *int
	addcreator_id *int
	creator_name  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OrderFinanceLog, error)
	predicates    []predicate.OrderFinanceLog
}

var _ ent.Mutation = (*OrderFinanceLogMutation)(nil)

// orderfinancelogOption allows management of the mutation configuration using functional options.
type orderfinancelogOption func(*OrderFinanceLogMutation)

// newOrderFinanceLogMutation creates new mutation for the OrderFinanceLog entity.
func newOrderFinanceLogMutation(c config, op Op, opts ...orderfinancelogOption) *OrderFinanceLogMutation {
	m := &OrderFinanceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderFinanceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderFinanceLogID sets the ID field of the mutation.
func withOrderFinanceLogID(id int) orderfinancelogOption {
	return func(m *OrderFinanceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderFinanceLog
		)
		m.oldValue = func(ctx context.Context) (*OrderFinanceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderFinanceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderFinanceLog sets the old OrderFinanceLog of the mutation.
func withOrderFinanceLog(node *OrderFinanceLog) orderfinancelogOption {
	return func(m *OrderFinanceLogMutation) {
		m.oldValue = func(context.Context) (*OrderFinanceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderFinanceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderFinanceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderFinanceLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderFinanceLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderFinanceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderFinanceLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderFinanceLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderFinanceLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderFinanceLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderFinanceLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderFinanceLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderFinanceLogMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderFinanceLogMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderFinanceLogMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderFinanceLogMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderFinanceLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderFinanceLogMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderFinanceLogMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *OrderFinanceLogMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *OrderFinanceLogMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderFinanceLogMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetAmount sets the "amount" field.
func (m *OrderFinanceLogMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderFinanceLogMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderFinanceLogMutation) ResetAmount() {
	m.amount = nil
}

// SetType sets the "type" field.
func (m *OrderFinanceLogMutation) SetType(dflt domain.OrderFinanceLogType) {
	m._type = &dflt
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderFinanceLogMutation) GetType() (r domain.OrderFinanceLogType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldType(ctx context.Context) (v domain.OrderFinanceLogType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderFinanceLogMutation) ResetType() {
	m._type = nil
}

// SetChannel sets the "channel" field.
func (m *OrderFinanceLogMutation) SetChannel(dpc domain.OrderPaidChannel) {
	m.channel = &dpc
}

// Channel returns the value of the "channel" field in the mutation.
func (m *OrderFinanceLogMutation) Channel() (r domain.OrderPaidChannel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldChannel(ctx context.Context) (v domain.OrderPaidChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *OrderFinanceLogMutation) ResetChannel() {
	m.channel = nil
}

// SetSeqNo sets the "seq_no" field.
func (m *OrderFinanceLogMutation) SetSeqNo(s string) {
	m.seq_no = &s
}

// SeqNo returns the value of the "seq_no" field in the mutation.
func (m *OrderFinanceLogMutation) SeqNo() (r string, exists bool) {
	v := m.seq_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNo returns the old "seq_no" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldSeqNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNo: %w", err)
	}
	return oldValue.SeqNo, nil
}

// ResetSeqNo resets all changes to the "seq_no" field.
func (m *OrderFinanceLogMutation) ResetSeqNo() {
	m.seq_no = nil
}

// SetCreatorType sets the "creator_type" field.
func (m *OrderFinanceLogMutation) SetCreatorType(dt domain.OperatorType) {
	m.creator_type = &dt
}

// CreatorType returns the value of the "creator_type" field in the mutation.
func (m *OrderFinanceLogMutation) CreatorType() (r domain.OperatorType, exists bool) {
	v := m.creator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorType returns the old "creator_type" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldCreatorType(ctx context.Context) (v domain.OperatorType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorType: %w", err)
	}
	return oldValue.CreatorType, nil
}

// ResetCreatorType resets all changes to the "creator_type" field.
func (m *OrderFinanceLogMutation) ResetCreatorType() {
	m.creator_type = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *OrderFinanceLogMutation) SetCreatorID(i int) {
	m.creator_id = &i
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *OrderFinanceLogMutation) CreatorID() (r int, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds i to the "creator_id" field.
func (m *OrderFinanceLogMutation) AddCreatorID(i int) {
	if m.addcreator_id != nil {
		*m.addcreator_id += i
	} else {
		m.addcreator_id = &i
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *OrderFinanceLogMutation) AddedCreatorID() (r int, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *OrderFinanceLogMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
}

// SetCreatorName sets the "creator_name" field.
func (m *OrderFinanceLogMutation) SetCreatorName(s string) {
	m.creator_name = &s
}

// CreatorName returns the value of the "creator_name" field in the mutation.
func (m *OrderFinanceLogMutation) CreatorName() (r string, exists bool) {
	v := m.creator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorName returns the old "creator_name" field's value of the OrderFinanceLog entity.
// If the OrderFinanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderFinanceLogMutation) OldCreatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorName: %w", err)
	}
	return oldValue.CreatorName, nil
}

// ResetCreatorName resets all changes to the "creator_name" field.
func (m *OrderFinanceLogMutation) ResetCreatorName() {
	m.creator_name = nil
}

// Where appends a list predicates to the OrderFinanceLogMutation builder.
func (m *OrderFinanceLogMutation) Where(ps ...predicate.OrderFinanceLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderFinanceLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderFinanceLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderFinanceLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderFinanceLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderFinanceLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderFinanceLog).
func (m *OrderFinanceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderFinanceLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, orderfinancelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderfinancelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderfinancelog.FieldDeletedAt)
	}
	if m.order_id != nil {
		fields = append(fields, orderfinancelog.FieldOrderID)
	}
	if m.amount != nil {
		fields = append(fields, orderfinancelog.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, orderfinancelog.FieldType)
	}
	if m.channel != nil {
		fields = append(fields, orderfinancelog.FieldChannel)
	}
	if m.seq_no != nil {
		fields = append(fields, orderfinancelog.FieldSeqNo)
	}
	if m.creator_type != nil {
		fields = append(fields, orderfinancelog.FieldCreatorType)
	}
	if m.creator_id != nil {
		fields = append(fields, orderfinancelog.FieldCreatorID)
	}
	if m.creator_name != nil {
		fields = append(fields, orderfinancelog.FieldCreatorName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderFinanceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderfinancelog.FieldCreatedAt:
		return m.CreatedAt()
	case orderfinancelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderfinancelog.FieldDeletedAt:
		return m.DeletedAt()
	case orderfinancelog.FieldOrderID:
		return m.OrderID()
	case orderfinancelog.FieldAmount:
		return m.Amount()
	case orderfinancelog.FieldType:
		return m.GetType()
	case orderfinancelog.FieldChannel:
		return m.Channel()
	case orderfinancelog.FieldSeqNo:
		return m.SeqNo()
	case orderfinancelog.FieldCreatorType:
		return m.CreatorType()
	case orderfinancelog.FieldCreatorID:
		return m.CreatorID()
	case orderfinancelog.FieldCreatorName:
		return m.CreatorName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderFinanceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderfinancelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderfinancelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderfinancelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderfinancelog.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderfinancelog.FieldAmount:
		return m.OldAmount(ctx)
	case orderfinancelog.FieldType:
		return m.OldType(ctx)
	case orderfinancelog.FieldChannel:
		return m.OldChannel(ctx)
	case orderfinancelog.FieldSeqNo:
		return m.OldSeqNo(ctx)
	case orderfinancelog.FieldCreatorType:
		return m.OldCreatorType(ctx)
	case orderfinancelog.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case orderfinancelog.FieldCreatorName:
		return m.OldCreatorName(ctx)
	}
	return nil, fmt.Errorf("unknown OrderFinanceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderFinanceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderfinancelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderfinancelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderfinancelog.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderfinancelog.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderfinancelog.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderfinancelog.FieldType:
		v, ok := value.(domain.OrderFinanceLogType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderfinancelog.FieldChannel:
		v, ok := value.(domain.OrderPaidChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case orderfinancelog.FieldSeqNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNo(v)
		return nil
	case orderfinancelog.FieldCreatorType:
		v, ok := value.(domain.OperatorType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorType(v)
		return nil
	case orderfinancelog.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case orderfinancelog.FieldCreatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorName(v)
		return nil
	}
	return fmt.Errorf("unknown OrderFinanceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderFinanceLogMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, orderfinancelog.FieldDeletedAt)
	}
	if m.addorder_id != nil {
		fields = append(fields, orderfinancelog.FieldOrderID)
	}
	if m.addcreator_id != nil {
		fields = append(fields, orderfinancelog.FieldCreatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderFinanceLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderfinancelog.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderfinancelog.FieldOrderID:
		return m.AddedOrderID()
	case orderfinancelog.FieldCreatorID:
		return m.AddedCreatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderFinanceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderfinancelog.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderfinancelog.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case orderfinancelog.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderFinanceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderFinanceLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderFinanceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderFinanceLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderFinanceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderFinanceLogMutation) ResetField(name string) error {
	switch name {
	case orderfinancelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderfinancelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderfinancelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderfinancelog.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderfinancelog.FieldAmount:
		m.ResetAmount()
		return nil
	case orderfinancelog.FieldType:
		m.ResetType()
		return nil
	case orderfinancelog.FieldChannel:
		m.ResetChannel()
		return nil
	case orderfinancelog.FieldSeqNo:
		m.ResetSeqNo()
		return nil
	case orderfinancelog.FieldCreatorType:
		m.ResetCreatorType()
		return nil
	case orderfinancelog.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case orderfinancelog.FieldCreatorName:
		m.ResetCreatorName()
		return nil
	}
	return fmt.Errorf("unknown OrderFinanceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderFinanceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderFinanceLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderFinanceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderFinanceLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderFinanceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderFinanceLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderFinanceLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderFinanceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderFinanceLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderFinanceLog edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *int64
	adddeleted_at           *int64
	product_id              *int
	addproduct_id           *int
	name                    *string
	_type                   *int
	add_type                *int
	allow_point_pay         *bool
	quantity                *decimal.Decimal
	price                   *decimal.Decimal
	amount                  *decimal.Decimal
	remark                  *string
	product_snapshot        *domain.OrderProductInfoSnapshot
	clearedFields           map[string]struct{}
	_order                  *int
	cleared_order           bool
	set_meal_details        map[int]struct{}
	removedset_meal_details map[int]struct{}
	clearedset_meal_details bool
	done                    bool
	oldValue                func(context.Context) (*OrderItem, error)
	predicates              []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderItemMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderItemMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderItemMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderItemMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetName sets the "name" field.
func (m *OrderItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *OrderItemMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderItemMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderItemMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderItemMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderItemMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetAllowPointPay sets the "allow_point_pay" field.
func (m *OrderItemMutation) SetAllowPointPay(b bool) {
	m.allow_point_pay = &b
}

// AllowPointPay returns the value of the "allow_point_pay" field in the mutation.
func (m *OrderItemMutation) AllowPointPay() (r bool, exists bool) {
	v := m.allow_point_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowPointPay returns the old "allow_point_pay" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldAllowPointPay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowPointPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowPointPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowPointPay: %w", err)
	}
	return oldValue.AllowPointPay, nil
}

// ResetAllowPointPay resets all changes to the "allow_point_pay" field.
func (m *OrderItemMutation) ResetAllowPointPay() {
	m.allow_point_pay = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
}

// SetPrice sets the "price" field.
func (m *OrderItemMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderItemMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderItemMutation) ResetPrice() {
	m.price = nil
}

// SetAmount sets the "amount" field.
func (m *OrderItemMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderItemMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderItemMutation) ResetAmount() {
	m.amount = nil
}

// SetRemark sets the "remark" field.
func (m *OrderItemMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderItemMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderItemMutation) ResetRemark() {
	m.remark = nil
}

// SetProductSnapshot sets the "product_snapshot" field.
func (m *OrderItemMutation) SetProductSnapshot(dpis domain.OrderProductInfoSnapshot) {
	m.product_snapshot = &dpis
}

// ProductSnapshot returns the value of the "product_snapshot" field in the mutation.
func (m *OrderItemMutation) ProductSnapshot() (r domain.OrderProductInfoSnapshot, exists bool) {
	v := m.product_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSnapshot returns the old "product_snapshot" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductSnapshot(ctx context.Context) (v domain.OrderProductInfoSnapshot, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSnapshot: %w", err)
	}
	return oldValue.ProductSnapshot, nil
}

// ResetProductSnapshot resets all changes to the "product_snapshot" field.
func (m *OrderItemMutation) ResetProductSnapshot() {
	m.product_snapshot = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// AddSetMealDetailIDs adds the "set_meal_details" edge to the OrderItemSetMealDetail entity by ids.
func (m *OrderItemMutation) AddSetMealDetailIDs(ids ...int) {
	if m.set_meal_details == nil {
		m.set_meal_details = make(map[int]struct{})
	}
	for i := range ids {
		m.set_meal_details[ids[i]] = struct{}{}
	}
}

// ClearSetMealDetails clears the "set_meal_details" edge to the OrderItemSetMealDetail entity.
func (m *OrderItemMutation) ClearSetMealDetails() {
	m.clearedset_meal_details = true
}

// SetMealDetailsCleared reports if the "set_meal_details" edge to the OrderItemSetMealDetail entity was cleared.
func (m *OrderItemMutation) SetMealDetailsCleared() bool {
	return m.clearedset_meal_details
}

// RemoveSetMealDetailIDs removes the "set_meal_details" edge to the OrderItemSetMealDetail entity by IDs.
func (m *OrderItemMutation) RemoveSetMealDetailIDs(ids ...int) {
	if m.removedset_meal_details == nil {
		m.removedset_meal_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.set_meal_details, ids[i])
		m.removedset_meal_details[ids[i]] = struct{}{}
	}
}

// RemovedSetMealDetails returns the removed IDs of the "set_meal_details" edge to the OrderItemSetMealDetail entity.
func (m *OrderItemMutation) RemovedSetMealDetailsIDs() (ids []int) {
	for id := range m.removedset_meal_details {
		ids = append(ids, id)
	}
	return
}

// SetMealDetailsIDs returns the "set_meal_details" edge IDs in the mutation.
func (m *OrderItemMutation) SetMealDetailsIDs() (ids []int) {
	for id := range m.set_meal_details {
		ids = append(ids, id)
	}
	return
}

// ResetSetMealDetails resets all changes to the "set_meal_details" edge.
func (m *OrderItemMutation) ResetSetMealDetails() {
	m.set_meal_details = nil
	m.clearedset_meal_details = false
	m.removedset_meal_details = nil
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderitem.FieldDeletedAt)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.name != nil {
		fields = append(fields, orderitem.FieldName)
	}
	if m._type != nil {
		fields = append(fields, orderitem.FieldType)
	}
	if m.allow_point_pay != nil {
		fields = append(fields, orderitem.FieldAllowPointPay)
	}
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.price != nil {
		fields = append(fields, orderitem.FieldPrice)
	}
	if m.amount != nil {
		fields = append(fields, orderitem.FieldAmount)
	}
	if m.remark != nil {
		fields = append(fields, orderitem.FieldRemark)
	}
	if m.product_snapshot != nil {
		fields = append(fields, orderitem.FieldProductSnapshot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldDeletedAt:
		return m.DeletedAt()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldName:
		return m.Name()
	case orderitem.FieldType:
		return m.GetType()
	case orderitem.FieldAllowPointPay:
		return m.AllowPointPay()
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldPrice:
		return m.Price()
	case orderitem.FieldAmount:
		return m.Amount()
	case orderitem.FieldRemark:
		return m.Remark()
	case orderitem.FieldProductSnapshot:
		return m.ProductSnapshot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldName:
		return m.OldName(ctx)
	case orderitem.FieldType:
		return m.OldType(ctx)
	case orderitem.FieldAllowPointPay:
		return m.OldAllowPointPay(ctx)
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldPrice:
		return m.OldPrice(ctx)
	case orderitem.FieldAmount:
		return m.OldAmount(ctx)
	case orderitem.FieldRemark:
		return m.OldRemark(ctx)
	case orderitem.FieldProductSnapshot:
		return m.OldProductSnapshot(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderitem.FieldAllowPointPay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowPointPay(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case orderitem.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderitem.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case orderitem.FieldProductSnapshot:
		v, ok := value.(domain.OrderProductInfoSnapshot)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSnapshot(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, orderitem.FieldDeletedAt)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.add_type != nil {
		fields = append(fields, orderitem.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldName:
		m.ResetName()
		return nil
	case orderitem.FieldType:
		m.ResetType()
		return nil
	case orderitem.FieldAllowPointPay:
		m.ResetAllowPointPay()
		return nil
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldPrice:
		m.ResetPrice()
		return nil
	case orderitem.FieldAmount:
		m.ResetAmount()
		return nil
	case orderitem.FieldRemark:
		m.ResetRemark()
		return nil
	case orderitem.FieldProductSnapshot:
		m.ResetProductSnapshot()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.set_meal_details != nil {
		edges = append(edges, orderitem.EdgeSetMealDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.set_meal_details))
		for id := range m.set_meal_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedset_meal_details != nil {
		edges = append(edges, orderitem.EdgeSetMealDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.removedset_meal_details))
		for id := range m.removedset_meal_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.clearedset_meal_details {
		edges = append(edges, orderitem.EdgeSetMealDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	case orderitem.EdgeSetMealDetails:
		return m.clearedset_meal_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderitem.EdgeSetMealDetails:
		m.ResetSetMealDetails()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderItemSetMealDetailMutation represents an operation that mutates the OrderItemSetMealDetail nodes in the graph.
type OrderItemSetMealDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int64
	adddeleted_at     *int64
	name              *string
	_type             *int
	add_type          *int
	set_meal_price    *decimal.Decimal
	set_meal_id       *int
	addset_meal_id    *int
	product_id        *int
	addproduct_id     *int
	quantity          *decimal.Decimal
	product_snapshot  *domain.OrderProductInfoSnapshot
	clearedFields     map[string]struct{}
	order_item        *int
	clearedorder_item bool
	done              bool
	oldValue          func(context.Context) (*OrderItemSetMealDetail, error)
	predicates        []predicate.OrderItemSetMealDetail
}

var _ ent.Mutation = (*OrderItemSetMealDetailMutation)(nil)

// orderitemsetmealdetailOption allows management of the mutation configuration using functional options.
type orderitemsetmealdetailOption func(*OrderItemSetMealDetailMutation)

// newOrderItemSetMealDetailMutation creates new mutation for the OrderItemSetMealDetail entity.
func newOrderItemSetMealDetailMutation(c config, op Op, opts ...orderitemsetmealdetailOption) *OrderItemSetMealDetailMutation {
	m := &OrderItemSetMealDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItemSetMealDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemSetMealDetailID sets the ID field of the mutation.
func withOrderItemSetMealDetailID(id int) orderitemsetmealdetailOption {
	return func(m *OrderItemSetMealDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItemSetMealDetail
		)
		m.oldValue = func(ctx context.Context) (*OrderItemSetMealDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItemSetMealDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItemSetMealDetail sets the old OrderItemSetMealDetail of the mutation.
func withOrderItemSetMealDetail(node *OrderItemSetMealDetail) orderitemsetmealdetailOption {
	return func(m *OrderItemSetMealDetailMutation) {
		m.oldValue = func(context.Context) (*OrderItemSetMealDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemSetMealDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemSetMealDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemSetMealDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemSetMealDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItemSetMealDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemSetMealDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemSetMealDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemSetMealDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemSetMealDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemSetMealDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemSetMealDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderItemSetMealDetailMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderItemSetMealDetailMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderItemSetMealDetailMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderItemSetMealDetailMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderItemSetMealDetailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetOrderItemID sets the "order_item_id" field.
func (m *OrderItemSetMealDetailMutation) SetOrderItemID(i int) {
	m.order_item = &i
}

// OrderItemID returns the value of the "order_item_id" field in the mutation.
func (m *OrderItemSetMealDetailMutation) OrderItemID() (r int, exists bool) {
	v := m.order_item
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemID returns the old "order_item_id" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldOrderItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemID: %w", err)
	}
	return oldValue.OrderItemID, nil
}

// ResetOrderItemID resets all changes to the "order_item_id" field.
func (m *OrderItemSetMealDetailMutation) ResetOrderItemID() {
	m.order_item = nil
}

// SetName sets the "name" field.
func (m *OrderItemSetMealDetailMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemSetMealDetailMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemSetMealDetailMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *OrderItemSetMealDetailMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderItemSetMealDetailMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderItemSetMealDetailMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderItemSetMealDetailMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderItemSetMealDetailMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetSetMealPrice sets the "set_meal_price" field.
func (m *OrderItemSetMealDetailMutation) SetSetMealPrice(d decimal.Decimal) {
	m.set_meal_price = &d
}

// SetMealPrice returns the value of the "set_meal_price" field in the mutation.
func (m *OrderItemSetMealDetailMutation) SetMealPrice() (r decimal.Decimal, exists bool) {
	v := m.set_meal_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSetMealPrice returns the old "set_meal_price" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldSetMealPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetMealPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetMealPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetMealPrice: %w", err)
	}
	return oldValue.SetMealPrice, nil
}

// ResetSetMealPrice resets all changes to the "set_meal_price" field.
func (m *OrderItemSetMealDetailMutation) ResetSetMealPrice() {
	m.set_meal_price = nil
}

// SetSetMealID sets the "set_meal_id" field.
func (m *OrderItemSetMealDetailMutation) SetSetMealID(i int) {
	m.set_meal_id = &i
	m.addset_meal_id = nil
}

// SetMealID returns the value of the "set_meal_id" field in the mutation.
func (m *OrderItemSetMealDetailMutation) SetMealID() (r int, exists bool) {
	v := m.set_meal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSetMealID returns the old "set_meal_id" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldSetMealID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetMealID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetMealID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetMealID: %w", err)
	}
	return oldValue.SetMealID, nil
}

// AddSetMealID adds i to the "set_meal_id" field.
func (m *OrderItemSetMealDetailMutation) AddSetMealID(i int) {
	if m.addset_meal_id != nil {
		*m.addset_meal_id += i
	} else {
		m.addset_meal_id = &i
	}
}

// AddedSetMealID returns the value that was added to the "set_meal_id" field in this mutation.
func (m *OrderItemSetMealDetailMutation) AddedSetMealID() (r int, exists bool) {
	v := m.addset_meal_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSetMealID resets all changes to the "set_meal_id" field.
func (m *OrderItemSetMealDetailMutation) ResetSetMealID() {
	m.set_meal_id = nil
	m.addset_meal_id = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderItemSetMealDetailMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemSetMealDetailMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemSetMealDetailMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemSetMealDetailMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemSetMealDetailMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemSetMealDetailMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemSetMealDetailMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemSetMealDetailMutation) ResetQuantity() {
	m.quantity = nil
}

// SetProductSnapshot sets the "product_snapshot" field.
func (m *OrderItemSetMealDetailMutation) SetProductSnapshot(dpis domain.OrderProductInfoSnapshot) {
	m.product_snapshot = &dpis
}

// ProductSnapshot returns the value of the "product_snapshot" field in the mutation.
func (m *OrderItemSetMealDetailMutation) ProductSnapshot() (r domain.OrderProductInfoSnapshot, exists bool) {
	v := m.product_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSnapshot returns the old "product_snapshot" field's value of the OrderItemSetMealDetail entity.
// If the OrderItemSetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemSetMealDetailMutation) OldProductSnapshot(ctx context.Context) (v domain.OrderProductInfoSnapshot, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSnapshot: %w", err)
	}
	return oldValue.ProductSnapshot, nil
}

// ResetProductSnapshot resets all changes to the "product_snapshot" field.
func (m *OrderItemSetMealDetailMutation) ResetProductSnapshot() {
	m.product_snapshot = nil
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *OrderItemSetMealDetailMutation) ClearOrderItem() {
	m.clearedorder_item = true
	m.clearedFields[orderitemsetmealdetail.FieldOrderItemID] = struct{}{}
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *OrderItemSetMealDetailMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemSetMealDetailMutation) OrderItemIDs() (ids []int) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *OrderItemSetMealDetailMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// Where appends a list predicates to the OrderItemSetMealDetailMutation builder.
func (m *OrderItemSetMealDetailMutation) Where(ps ...predicate.OrderItemSetMealDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemSetMealDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemSetMealDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItemSetMealDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemSetMealDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemSetMealDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItemSetMealDetail).
func (m *OrderItemSetMealDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemSetMealDetailMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, orderitemsetmealdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitemsetmealdetail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderitemsetmealdetail.FieldDeletedAt)
	}
	if m.order_item != nil {
		fields = append(fields, orderitemsetmealdetail.FieldOrderItemID)
	}
	if m.name != nil {
		fields = append(fields, orderitemsetmealdetail.FieldName)
	}
	if m._type != nil {
		fields = append(fields, orderitemsetmealdetail.FieldType)
	}
	if m.set_meal_price != nil {
		fields = append(fields, orderitemsetmealdetail.FieldSetMealPrice)
	}
	if m.set_meal_id != nil {
		fields = append(fields, orderitemsetmealdetail.FieldSetMealID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitemsetmealdetail.FieldProductID)
	}
	if m.quantity != nil {
		fields = append(fields, orderitemsetmealdetail.FieldQuantity)
	}
	if m.product_snapshot != nil {
		fields = append(fields, orderitemsetmealdetail.FieldProductSnapshot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemSetMealDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitemsetmealdetail.FieldCreatedAt:
		return m.CreatedAt()
	case orderitemsetmealdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitemsetmealdetail.FieldDeletedAt:
		return m.DeletedAt()
	case orderitemsetmealdetail.FieldOrderItemID:
		return m.OrderItemID()
	case orderitemsetmealdetail.FieldName:
		return m.Name()
	case orderitemsetmealdetail.FieldType:
		return m.GetType()
	case orderitemsetmealdetail.FieldSetMealPrice:
		return m.SetMealPrice()
	case orderitemsetmealdetail.FieldSetMealID:
		return m.SetMealID()
	case orderitemsetmealdetail.FieldProductID:
		return m.ProductID()
	case orderitemsetmealdetail.FieldQuantity:
		return m.Quantity()
	case orderitemsetmealdetail.FieldProductSnapshot:
		return m.ProductSnapshot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemSetMealDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitemsetmealdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitemsetmealdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitemsetmealdetail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderitemsetmealdetail.FieldOrderItemID:
		return m.OldOrderItemID(ctx)
	case orderitemsetmealdetail.FieldName:
		return m.OldName(ctx)
	case orderitemsetmealdetail.FieldType:
		return m.OldType(ctx)
	case orderitemsetmealdetail.FieldSetMealPrice:
		return m.OldSetMealPrice(ctx)
	case orderitemsetmealdetail.FieldSetMealID:
		return m.OldSetMealID(ctx)
	case orderitemsetmealdetail.FieldProductID:
		return m.OldProductID(ctx)
	case orderitemsetmealdetail.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitemsetmealdetail.FieldProductSnapshot:
		return m.OldProductSnapshot(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItemSetMealDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemSetMealDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitemsetmealdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitemsetmealdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitemsetmealdetail.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderitemsetmealdetail.FieldOrderItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemID(v)
		return nil
	case orderitemsetmealdetail.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitemsetmealdetail.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderitemsetmealdetail.FieldSetMealPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetMealPrice(v)
		return nil
	case orderitemsetmealdetail.FieldSetMealID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetMealID(v)
		return nil
	case orderitemsetmealdetail.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitemsetmealdetail.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitemsetmealdetail.FieldProductSnapshot:
		v, ok := value.(domain.OrderProductInfoSnapshot)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSnapshot(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemSetMealDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemSetMealDetailMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, orderitemsetmealdetail.FieldDeletedAt)
	}
	if m.add_type != nil {
		fields = append(fields, orderitemsetmealdetail.FieldType)
	}
	if m.addset_meal_id != nil {
		fields = append(fields, orderitemsetmealdetail.FieldSetMealID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderitemsetmealdetail.FieldProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemSetMealDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitemsetmealdetail.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderitemsetmealdetail.FieldType:
		return m.AddedType()
	case orderitemsetmealdetail.FieldSetMealID:
		return m.AddedSetMealID()
	case orderitemsetmealdetail.FieldProductID:
		return m.AddedProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemSetMealDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitemsetmealdetail.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderitemsetmealdetail.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case orderitemsetmealdetail.FieldSetMealID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSetMealID(v)
		return nil
	case orderitemsetmealdetail.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemSetMealDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemSetMealDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemSetMealDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemSetMealDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderItemSetMealDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemSetMealDetailMutation) ResetField(name string) error {
	switch name {
	case orderitemsetmealdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitemsetmealdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitemsetmealdetail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderitemsetmealdetail.FieldOrderItemID:
		m.ResetOrderItemID()
		return nil
	case orderitemsetmealdetail.FieldName:
		m.ResetName()
		return nil
	case orderitemsetmealdetail.FieldType:
		m.ResetType()
		return nil
	case orderitemsetmealdetail.FieldSetMealPrice:
		m.ResetSetMealPrice()
		return nil
	case orderitemsetmealdetail.FieldSetMealID:
		m.ResetSetMealID()
		return nil
	case orderitemsetmealdetail.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitemsetmealdetail.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitemsetmealdetail.FieldProductSnapshot:
		m.ResetProductSnapshot()
		return nil
	}
	return fmt.Errorf("unknown OrderItemSetMealDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemSetMealDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order_item != nil {
		edges = append(edges, orderitemsetmealdetail.EdgeOrderItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemSetMealDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitemsetmealdetail.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemSetMealDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemSetMealDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemSetMealDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder_item {
		edges = append(edges, orderitemsetmealdetail.EdgeOrderItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemSetMealDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitemsetmealdetail.EdgeOrderItem:
		return m.clearedorder_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemSetMealDetailMutation) ClearEdge(name string) error {
	switch name {
	case orderitemsetmealdetail.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItemSetMealDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemSetMealDetailMutation) ResetEdge(name string) error {
	switch name {
	case orderitemsetmealdetail.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItemSetMealDetail edge %s", name)
}

// OrderLogMutation represents an operation that mutates the OrderLog nodes in the graph.
type OrderLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int64
	adddeleted_at  *int64
	event          *domain.OrderLogEvent
	operator_type  *domain.OperatorType
	operator_id    *int
	addoperator_id *int
	operator_name  *string
	clearedFields  map[string]struct{}
	_order         *int
	cleared_order  bool
	done           bool
	oldValue       func(context.Context) (*OrderLog, error)
	predicates     []predicate.OrderLog
}

var _ ent.Mutation = (*OrderLogMutation)(nil)

// orderlogOption allows management of the mutation configuration using functional options.
type orderlogOption func(*OrderLogMutation)

// newOrderLogMutation creates new mutation for the OrderLog entity.
func newOrderLogMutation(c config, op Op, opts ...orderlogOption) *OrderLogMutation {
	m := &OrderLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderLogID sets the ID field of the mutation.
func withOrderLogID(id int) orderlogOption {
	return func(m *OrderLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderLog
		)
		m.oldValue = func(ctx context.Context) (*OrderLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderLog sets the old OrderLog of the mutation.
func withOrderLog(node *OrderLog) orderlogOption {
	return func(m *OrderLogMutation) {
		m.oldValue = func(context.Context) (*OrderLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderLogMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderLogMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderLogMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderLogMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderLogMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderLogMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderLogMutation) ResetOrderID() {
	m._order = nil
}

// SetEvent sets the "event" field.
func (m *OrderLogMutation) SetEvent(dle domain.OrderLogEvent) {
	m.event = &dle
}

// Event returns the value of the "event" field in the mutation.
func (m *OrderLogMutation) Event() (r domain.OrderLogEvent, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldEvent(ctx context.Context) (v domain.OrderLogEvent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *OrderLogMutation) ResetEvent() {
	m.event = nil
}

// SetOperatorType sets the "operator_type" field.
func (m *OrderLogMutation) SetOperatorType(dt domain.OperatorType) {
	m.operator_type = &dt
}

// OperatorType returns the value of the "operator_type" field in the mutation.
func (m *OrderLogMutation) OperatorType() (r domain.OperatorType, exists bool) {
	v := m.operator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorType returns the old "operator_type" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldOperatorType(ctx context.Context) (v domain.OperatorType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorType: %w", err)
	}
	return oldValue.OperatorType, nil
}

// ResetOperatorType resets all changes to the "operator_type" field.
func (m *OrderLogMutation) ResetOperatorType() {
	m.operator_type = nil
}

// SetOperatorID sets the "operator_id" field.
func (m *OrderLogMutation) SetOperatorID(i int) {
	m.operator_id = &i
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *OrderLogMutation) OperatorID() (r int, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldOperatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds i to the "operator_id" field.
func (m *OrderLogMutation) AddOperatorID(i int) {
	if m.addoperator_id != nil {
		*m.addoperator_id += i
	} else {
		m.addoperator_id = &i
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *OrderLogMutation) AddedOperatorID() (r int, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *OrderLogMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
}

// SetOperatorName sets the "operator_name" field.
func (m *OrderLogMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *OrderLogMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the OrderLog entity.
// If the OrderLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLogMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *OrderLogMutation) ResetOperatorName() {
	m.operator_name = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderLogMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderlog.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderLogMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderLogMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderLogMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderLogMutation builder.
func (m *OrderLogMutation) Where(ps ...predicate.OrderLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderLog).
func (m *OrderLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, orderlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderlog.FieldDeletedAt)
	}
	if m._order != nil {
		fields = append(fields, orderlog.FieldOrderID)
	}
	if m.event != nil {
		fields = append(fields, orderlog.FieldEvent)
	}
	if m.operator_type != nil {
		fields = append(fields, orderlog.FieldOperatorType)
	}
	if m.operator_id != nil {
		fields = append(fields, orderlog.FieldOperatorID)
	}
	if m.operator_name != nil {
		fields = append(fields, orderlog.FieldOperatorName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderlog.FieldCreatedAt:
		return m.CreatedAt()
	case orderlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderlog.FieldDeletedAt:
		return m.DeletedAt()
	case orderlog.FieldOrderID:
		return m.OrderID()
	case orderlog.FieldEvent:
		return m.Event()
	case orderlog.FieldOperatorType:
		return m.OperatorType()
	case orderlog.FieldOperatorID:
		return m.OperatorID()
	case orderlog.FieldOperatorName:
		return m.OperatorName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderlog.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderlog.FieldEvent:
		return m.OldEvent(ctx)
	case orderlog.FieldOperatorType:
		return m.OldOperatorType(ctx)
	case orderlog.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case orderlog.FieldOperatorName:
		return m.OldOperatorName(ctx)
	}
	return nil, fmt.Errorf("unknown OrderLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderlog.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderlog.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderlog.FieldEvent:
		v, ok := value.(domain.OrderLogEvent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case orderlog.FieldOperatorType:
		v, ok := value.(domain.OperatorType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorType(v)
		return nil
	case orderlog.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case orderlog.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	}
	return fmt.Errorf("unknown OrderLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderLogMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, orderlog.FieldDeletedAt)
	}
	if m.addoperator_id != nil {
		fields = append(fields, orderlog.FieldOperatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderlog.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderlog.FieldOperatorID:
		return m.AddedOperatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderlog.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderlog.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderLogMutation) ResetField(name string) error {
	switch name {
	case orderlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderlog.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderlog.FieldEvent:
		m.ResetEvent()
		return nil
	case orderlog.FieldOperatorType:
		m.ResetOperatorType()
		return nil
	case orderlog.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case orderlog.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	}
	return fmt.Errorf("unknown OrderLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderlog.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderlog.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderlog.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderLogMutation) EdgeCleared(name string) bool {
	switch name {
	case orderlog.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderLogMutation) ClearEdge(name string) error {
	switch name {
	case orderlog.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderLogMutation) ResetEdge(name string) error {
	switch name {
	case orderlog.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderLog edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int64
	adddeleted_at  *int64
	seq_no         *string
	provider       *domain.PayProvider
	channel        *domain.PayChannel
	state          *domain.PayState
	amount         *decimal.Decimal
	goods_desc     *string
	mch_id         *string
	ip_addr        *string
	req            *json.RawMessage
	appendreq      json.RawMessage
	resp           *json.RawMessage
	appendresp     json.RawMessage
	callback       *json.RawMessage
	appendcallback json.RawMessage
	finished_at    *time.Time
	refunded       *decimal.Decimal
	fail_reason    *string
	pay_biz_type   *domain.PayBizType
	biz_id         *int
	addbiz_id      *int
	creator_type   *domain.OperatorType
	creator_id     *int
	addcreator_id  *int
	creator_name   *string
	store_id       *int
	addstore_id    *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PaymentMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PaymentMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PaymentMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PaymentMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PaymentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetSeqNo sets the "seq_no" field.
func (m *PaymentMutation) SetSeqNo(s string) {
	m.seq_no = &s
}

// SeqNo returns the value of the "seq_no" field in the mutation.
func (m *PaymentMutation) SeqNo() (r string, exists bool) {
	v := m.seq_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNo returns the old "seq_no" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldSeqNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNo: %w", err)
	}
	return oldValue.SeqNo, nil
}

// ResetSeqNo resets all changes to the "seq_no" field.
func (m *PaymentMutation) ResetSeqNo() {
	m.seq_no = nil
}

// SetProvider sets the "provider" field.
func (m *PaymentMutation) SetProvider(dp domain.PayProvider) {
	m.provider = &dp
}

// Provider returns the value of the "provider" field in the mutation.
func (m *PaymentMutation) Provider() (r domain.PayProvider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldProvider(ctx context.Context) (v domain.PayProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *PaymentMutation) ResetProvider() {
	m.provider = nil
}

// SetChannel sets the "channel" field.
func (m *PaymentMutation) SetChannel(dc domain.PayChannel) {
	m.channel = &dc
}

// Channel returns the value of the "channel" field in the mutation.
func (m *PaymentMutation) Channel() (r domain.PayChannel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldChannel(ctx context.Context) (v domain.PayChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *PaymentMutation) ResetChannel() {
	m.channel = nil
}

// SetState sets the "state" field.
func (m *PaymentMutation) SetState(ds domain.PayState) {
	m.state = &ds
}

// State returns the value of the "state" field in the mutation.
func (m *PaymentMutation) State() (r domain.PayState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldState(ctx context.Context) (v domain.PayState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PaymentMutation) ResetState() {
	m.state = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
}

// SetGoodsDesc sets the "goods_desc" field.
func (m *PaymentMutation) SetGoodsDesc(s string) {
	m.goods_desc = &s
}

// GoodsDesc returns the value of the "goods_desc" field in the mutation.
func (m *PaymentMutation) GoodsDesc() (r string, exists bool) {
	v := m.goods_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodsDesc returns the old "goods_desc" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldGoodsDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodsDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodsDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodsDesc: %w", err)
	}
	return oldValue.GoodsDesc, nil
}

// ResetGoodsDesc resets all changes to the "goods_desc" field.
func (m *PaymentMutation) ResetGoodsDesc() {
	m.goods_desc = nil
}

// SetMchID sets the "mch_id" field.
func (m *PaymentMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *PaymentMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *PaymentMutation) ResetMchID() {
	m.mch_id = nil
}

// SetIPAddr sets the "ip_addr" field.
func (m *PaymentMutation) SetIPAddr(s string) {
	m.ip_addr = &s
}

// IPAddr returns the value of the "ip_addr" field in the mutation.
func (m *PaymentMutation) IPAddr() (r string, exists bool) {
	v := m.ip_addr
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddr returns the old "ip_addr" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldIPAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddr: %w", err)
	}
	return oldValue.IPAddr, nil
}

// ResetIPAddr resets all changes to the "ip_addr" field.
func (m *PaymentMutation) ResetIPAddr() {
	m.ip_addr = nil
}

// SetReq sets the "req" field.
func (m *PaymentMutation) SetReq(jm json.RawMessage) {
	m.req = &jm
	m.appendreq = nil
}

// Req returns the value of the "req" field in the mutation.
func (m *PaymentMutation) Req() (r json.RawMessage, exists bool) {
	v := m.req
	if v == nil {
		return
	}
	return *v, true
}

// OldReq returns the old "req" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldReq(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReq: %w", err)
	}
	return oldValue.Req, nil
}

// AppendReq adds jm to the "req" field.
func (m *PaymentMutation) AppendReq(jm json.RawMessage) {
	m.appendreq = append(m.appendreq, jm...)
}

// AppendedReq returns the list of values that were appended to the "req" field in this mutation.
func (m *PaymentMutation) AppendedReq() (json.RawMessage, bool) {
	if len(m.appendreq) == 0 {
		return nil, false
	}
	return m.appendreq, true
}

// ResetReq resets all changes to the "req" field.
func (m *PaymentMutation) ResetReq() {
	m.req = nil
	m.appendreq = nil
}

// SetResp sets the "resp" field.
func (m *PaymentMutation) SetResp(jm json.RawMessage) {
	m.resp = &jm
	m.appendresp = nil
}

// Resp returns the value of the "resp" field in the mutation.
func (m *PaymentMutation) Resp() (r json.RawMessage, exists bool) {
	v := m.resp
	if v == nil {
		return
	}
	return *v, true
}

// OldResp returns the old "resp" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldResp(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResp: %w", err)
	}
	return oldValue.Resp, nil
}

// AppendResp adds jm to the "resp" field.
func (m *PaymentMutation) AppendResp(jm json.RawMessage) {
	m.appendresp = append(m.appendresp, jm...)
}

// AppendedResp returns the list of values that were appended to the "resp" field in this mutation.
func (m *PaymentMutation) AppendedResp() (json.RawMessage, bool) {
	if len(m.appendresp) == 0 {
		return nil, false
	}
	return m.appendresp, true
}

// ClearResp clears the value of the "resp" field.
func (m *PaymentMutation) ClearResp() {
	m.resp = nil
	m.appendresp = nil
	m.clearedFields[payment.FieldResp] = struct{}{}
}

// RespCleared returns if the "resp" field was cleared in this mutation.
func (m *PaymentMutation) RespCleared() bool {
	_, ok := m.clearedFields[payment.FieldResp]
	return ok
}

// ResetResp resets all changes to the "resp" field.
func (m *PaymentMutation) ResetResp() {
	m.resp = nil
	m.appendresp = nil
	delete(m.clearedFields, payment.FieldResp)
}

// SetCallback sets the "callback" field.
func (m *PaymentMutation) SetCallback(jm json.RawMessage) {
	m.callback = &jm
	m.appendcallback = nil
}

// Callback returns the value of the "callback" field in the mutation.
func (m *PaymentMutation) Callback() (r json.RawMessage, exists bool) {
	v := m.callback
	if v == nil {
		return
	}
	return *v, true
}

// OldCallback returns the old "callback" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCallback(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallback: %w", err)
	}
	return oldValue.Callback, nil
}

// AppendCallback adds jm to the "callback" field.
func (m *PaymentMutation) AppendCallback(jm json.RawMessage) {
	m.appendcallback = append(m.appendcallback, jm...)
}

// AppendedCallback returns the list of values that were appended to the "callback" field in this mutation.
func (m *PaymentMutation) AppendedCallback() (json.RawMessage, bool) {
	if len(m.appendcallback) == 0 {
		return nil, false
	}
	return m.appendcallback, true
}

// ResetCallback resets all changes to the "callback" field.
func (m *PaymentMutation) ResetCallback() {
	m.callback = nil
	m.appendcallback = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *PaymentMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *PaymentMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *PaymentMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[payment.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *PaymentMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[payment.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *PaymentMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, payment.FieldFinishedAt)
}

// SetRefunded sets the "refunded" field.
func (m *PaymentMutation) SetRefunded(d decimal.Decimal) {
	m.refunded = &d
}

// Refunded returns the value of the "refunded" field in the mutation.
func (m *PaymentMutation) Refunded() (r decimal.Decimal, exists bool) {
	v := m.refunded
	if v == nil {
		return
	}
	return *v, true
}

// OldRefunded returns the old "refunded" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldRefunded(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefunded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefunded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefunded: %w", err)
	}
	return oldValue.Refunded, nil
}

// ResetRefunded resets all changes to the "refunded" field.
func (m *PaymentMutation) ResetRefunded() {
	m.refunded = nil
}

// SetFailReason sets the "fail_reason" field.
func (m *PaymentMutation) SetFailReason(s string) {
	m.fail_reason = &s
}

// FailReason returns the value of the "fail_reason" field in the mutation.
func (m *PaymentMutation) FailReason() (r string, exists bool) {
	v := m.fail_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailReason returns the old "fail_reason" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldFailReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailReason: %w", err)
	}
	return oldValue.FailReason, nil
}

// ClearFailReason clears the value of the "fail_reason" field.
func (m *PaymentMutation) ClearFailReason() {
	m.fail_reason = nil
	m.clearedFields[payment.FieldFailReason] = struct{}{}
}

// FailReasonCleared returns if the "fail_reason" field was cleared in this mutation.
func (m *PaymentMutation) FailReasonCleared() bool {
	_, ok := m.clearedFields[payment.FieldFailReason]
	return ok
}

// ResetFailReason resets all changes to the "fail_reason" field.
func (m *PaymentMutation) ResetFailReason() {
	m.fail_reason = nil
	delete(m.clearedFields, payment.FieldFailReason)
}

// SetPayBizType sets the "pay_biz_type" field.
func (m *PaymentMutation) SetPayBizType(dbt domain.PayBizType) {
	m.pay_biz_type = &dbt
}

// PayBizType returns the value of the "pay_biz_type" field in the mutation.
func (m *PaymentMutation) PayBizType() (r domain.PayBizType, exists bool) {
	v := m.pay_biz_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayBizType returns the old "pay_biz_type" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPayBizType(ctx context.Context) (v domain.PayBizType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayBizType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayBizType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayBizType: %w", err)
	}
	return oldValue.PayBizType, nil
}

// ResetPayBizType resets all changes to the "pay_biz_type" field.
func (m *PaymentMutation) ResetPayBizType() {
	m.pay_biz_type = nil
}

// SetBizID sets the "biz_id" field.
func (m *PaymentMutation) SetBizID(i int) {
	m.biz_id = &i
	m.addbiz_id = nil
}

// BizID returns the value of the "biz_id" field in the mutation.
func (m *PaymentMutation) BizID() (r int, exists bool) {
	v := m.biz_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBizID returns the old "biz_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldBizID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizID: %w", err)
	}
	return oldValue.BizID, nil
}

// AddBizID adds i to the "biz_id" field.
func (m *PaymentMutation) AddBizID(i int) {
	if m.addbiz_id != nil {
		*m.addbiz_id += i
	} else {
		m.addbiz_id = &i
	}
}

// AddedBizID returns the value that was added to the "biz_id" field in this mutation.
func (m *PaymentMutation) AddedBizID() (r int, exists bool) {
	v := m.addbiz_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBizID resets all changes to the "biz_id" field.
func (m *PaymentMutation) ResetBizID() {
	m.biz_id = nil
	m.addbiz_id = nil
}

// SetCreatorType sets the "creator_type" field.
func (m *PaymentMutation) SetCreatorType(dt domain.OperatorType) {
	m.creator_type = &dt
}

// CreatorType returns the value of the "creator_type" field in the mutation.
func (m *PaymentMutation) CreatorType() (r domain.OperatorType, exists bool) {
	v := m.creator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorType returns the old "creator_type" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatorType(ctx context.Context) (v domain.OperatorType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorType: %w", err)
	}
	return oldValue.CreatorType, nil
}

// ResetCreatorType resets all changes to the "creator_type" field.
func (m *PaymentMutation) ResetCreatorType() {
	m.creator_type = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *PaymentMutation) SetCreatorID(i int) {
	m.creator_id = &i
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *PaymentMutation) CreatorID() (r int, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds i to the "creator_id" field.
func (m *PaymentMutation) AddCreatorID(i int) {
	if m.addcreator_id != nil {
		*m.addcreator_id += i
	} else {
		m.addcreator_id = &i
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *PaymentMutation) AddedCreatorID() (r int, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *PaymentMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
}

// SetCreatorName sets the "creator_name" field.
func (m *PaymentMutation) SetCreatorName(s string) {
	m.creator_name = &s
}

// CreatorName returns the value of the "creator_name" field in the mutation.
func (m *PaymentMutation) CreatorName() (r string, exists bool) {
	v := m.creator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorName returns the old "creator_name" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorName: %w", err)
	}
	return oldValue.CreatorName, nil
}

// ResetCreatorName resets all changes to the "creator_name" field.
func (m *PaymentMutation) ResetCreatorName() {
	m.creator_name = nil
}

// SetStoreID sets the "store_id" field.
func (m *PaymentMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *PaymentMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *PaymentMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *PaymentMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *PaymentMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, payment.FieldDeletedAt)
	}
	if m.seq_no != nil {
		fields = append(fields, payment.FieldSeqNo)
	}
	if m.provider != nil {
		fields = append(fields, payment.FieldProvider)
	}
	if m.channel != nil {
		fields = append(fields, payment.FieldChannel)
	}
	if m.state != nil {
		fields = append(fields, payment.FieldState)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.goods_desc != nil {
		fields = append(fields, payment.FieldGoodsDesc)
	}
	if m.mch_id != nil {
		fields = append(fields, payment.FieldMchID)
	}
	if m.ip_addr != nil {
		fields = append(fields, payment.FieldIPAddr)
	}
	if m.req != nil {
		fields = append(fields, payment.FieldReq)
	}
	if m.resp != nil {
		fields = append(fields, payment.FieldResp)
	}
	if m.callback != nil {
		fields = append(fields, payment.FieldCallback)
	}
	if m.finished_at != nil {
		fields = append(fields, payment.FieldFinishedAt)
	}
	if m.refunded != nil {
		fields = append(fields, payment.FieldRefunded)
	}
	if m.fail_reason != nil {
		fields = append(fields, payment.FieldFailReason)
	}
	if m.pay_biz_type != nil {
		fields = append(fields, payment.FieldPayBizType)
	}
	if m.biz_id != nil {
		fields = append(fields, payment.FieldBizID)
	}
	if m.creator_type != nil {
		fields = append(fields, payment.FieldCreatorType)
	}
	if m.creator_id != nil {
		fields = append(fields, payment.FieldCreatorID)
	}
	if m.creator_name != nil {
		fields = append(fields, payment.FieldCreatorName)
	}
	if m.store_id != nil {
		fields = append(fields, payment.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	case payment.FieldUpdatedAt:
		return m.UpdatedAt()
	case payment.FieldDeletedAt:
		return m.DeletedAt()
	case payment.FieldSeqNo:
		return m.SeqNo()
	case payment.FieldProvider:
		return m.Provider()
	case payment.FieldChannel:
		return m.Channel()
	case payment.FieldState:
		return m.State()
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldGoodsDesc:
		return m.GoodsDesc()
	case payment.FieldMchID:
		return m.MchID()
	case payment.FieldIPAddr:
		return m.IPAddr()
	case payment.FieldReq:
		return m.Req()
	case payment.FieldResp:
		return m.Resp()
	case payment.FieldCallback:
		return m.Callback()
	case payment.FieldFinishedAt:
		return m.FinishedAt()
	case payment.FieldRefunded:
		return m.Refunded()
	case payment.FieldFailReason:
		return m.FailReason()
	case payment.FieldPayBizType:
		return m.PayBizType()
	case payment.FieldBizID:
		return m.BizID()
	case payment.FieldCreatorType:
		return m.CreatorType()
	case payment.FieldCreatorID:
		return m.CreatorID()
	case payment.FieldCreatorName:
		return m.CreatorName()
	case payment.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case payment.FieldSeqNo:
		return m.OldSeqNo(ctx)
	case payment.FieldProvider:
		return m.OldProvider(ctx)
	case payment.FieldChannel:
		return m.OldChannel(ctx)
	case payment.FieldState:
		return m.OldState(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldGoodsDesc:
		return m.OldGoodsDesc(ctx)
	case payment.FieldMchID:
		return m.OldMchID(ctx)
	case payment.FieldIPAddr:
		return m.OldIPAddr(ctx)
	case payment.FieldReq:
		return m.OldReq(ctx)
	case payment.FieldResp:
		return m.OldResp(ctx)
	case payment.FieldCallback:
		return m.OldCallback(ctx)
	case payment.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case payment.FieldRefunded:
		return m.OldRefunded(ctx)
	case payment.FieldFailReason:
		return m.OldFailReason(ctx)
	case payment.FieldPayBizType:
		return m.OldPayBizType(ctx)
	case payment.FieldBizID:
		return m.OldBizID(ctx)
	case payment.FieldCreatorType:
		return m.OldCreatorType(ctx)
	case payment.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case payment.FieldCreatorName:
		return m.OldCreatorName(ctx)
	case payment.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case payment.FieldSeqNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNo(v)
		return nil
	case payment.FieldProvider:
		v, ok := value.(domain.PayProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case payment.FieldChannel:
		v, ok := value.(domain.PayChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case payment.FieldState:
		v, ok := value.(domain.PayState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldGoodsDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodsDesc(v)
		return nil
	case payment.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case payment.FieldIPAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddr(v)
		return nil
	case payment.FieldReq:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReq(v)
		return nil
	case payment.FieldResp:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResp(v)
		return nil
	case payment.FieldCallback:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallback(v)
		return nil
	case payment.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case payment.FieldRefunded:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefunded(v)
		return nil
	case payment.FieldFailReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailReason(v)
		return nil
	case payment.FieldPayBizType:
		v, ok := value.(domain.PayBizType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayBizType(v)
		return nil
	case payment.FieldBizID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizID(v)
		return nil
	case payment.FieldCreatorType:
		v, ok := value.(domain.OperatorType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorType(v)
		return nil
	case payment.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case payment.FieldCreatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorName(v)
		return nil
	case payment.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, payment.FieldDeletedAt)
	}
	if m.addbiz_id != nil {
		fields = append(fields, payment.FieldBizID)
	}
	if m.addcreator_id != nil {
		fields = append(fields, payment.FieldCreatorID)
	}
	if m.addstore_id != nil {
		fields = append(fields, payment.FieldStoreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldDeletedAt:
		return m.AddedDeletedAt()
	case payment.FieldBizID:
		return m.AddedBizID()
	case payment.FieldCreatorID:
		return m.AddedCreatorID()
	case payment.FieldStoreID:
		return m.AddedStoreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case payment.FieldBizID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBizID(v)
		return nil
	case payment.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	case payment.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldResp) {
		fields = append(fields, payment.FieldResp)
	}
	if m.FieldCleared(payment.FieldFinishedAt) {
		fields = append(fields, payment.FieldFinishedAt)
	}
	if m.FieldCleared(payment.FieldFailReason) {
		fields = append(fields, payment.FieldFailReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldResp:
		m.ClearResp()
		return nil
	case payment.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case payment.FieldFailReason:
		m.ClearFailReason()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case payment.FieldSeqNo:
		m.ResetSeqNo()
		return nil
	case payment.FieldProvider:
		m.ResetProvider()
		return nil
	case payment.FieldChannel:
		m.ResetChannel()
		return nil
	case payment.FieldState:
		m.ResetState()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldGoodsDesc:
		m.ResetGoodsDesc()
		return nil
	case payment.FieldMchID:
		m.ResetMchID()
		return nil
	case payment.FieldIPAddr:
		m.ResetIPAddr()
		return nil
	case payment.FieldReq:
		m.ResetReq()
		return nil
	case payment.FieldResp:
		m.ResetResp()
		return nil
	case payment.FieldCallback:
		m.ResetCallback()
		return nil
	case payment.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case payment.FieldRefunded:
		m.ResetRefunded()
		return nil
	case payment.FieldFailReason:
		m.ResetFailReason()
		return nil
	case payment.FieldPayBizType:
		m.ResetPayBizType()
		return nil
	case payment.FieldBizID:
		m.ResetBizID()
		return nil
	case payment.FieldCreatorType:
		m.ResetCreatorType()
		return nil
	case payment.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case payment.FieldCreatorName:
		m.ResetCreatorName()
		return nil
	case payment.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentCallbackMutation represents an operation that mutates the PaymentCallback nodes in the graph.
type PaymentCallbackMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int64
	adddeleted_at *int64
	seq_no        *string
	_type         *domain.PaymentCallbackType
	raw           *json.RawMessage
	appendraw     json.RawMessage
	provider      *domain.PayProvider
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PaymentCallback, error)
	predicates    []predicate.PaymentCallback
}

var _ ent.Mutation = (*PaymentCallbackMutation)(nil)

// paymentcallbackOption allows management of the mutation configuration using functional options.
type paymentcallbackOption func(*PaymentCallbackMutation)

// newPaymentCallbackMutation creates new mutation for the PaymentCallback entity.
func newPaymentCallbackMutation(c config, op Op, opts ...paymentcallbackOption) *PaymentCallbackMutation {
	m := &PaymentCallbackMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentCallback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentCallbackID sets the ID field of the mutation.
func withPaymentCallbackID(id int) paymentcallbackOption {
	return func(m *PaymentCallbackMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentCallback
		)
		m.oldValue = func(ctx context.Context) (*PaymentCallback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentCallback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentCallback sets the old PaymentCallback of the mutation.
func withPaymentCallback(node *PaymentCallback) paymentcallbackOption {
	return func(m *PaymentCallbackMutation) {
		m.oldValue = func(context.Context) (*PaymentCallback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentCallbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentCallbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentCallbackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentCallbackMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentCallback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentCallbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentCallbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentCallbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentCallbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentCallbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentCallbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PaymentCallbackMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PaymentCallbackMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PaymentCallbackMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PaymentCallbackMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PaymentCallbackMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetSeqNo sets the "seq_no" field.
func (m *PaymentCallbackMutation) SetSeqNo(s string) {
	m.seq_no = &s
}

// SeqNo returns the value of the "seq_no" field in the mutation.
func (m *PaymentCallbackMutation) SeqNo() (r string, exists bool) {
	v := m.seq_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNo returns the old "seq_no" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldSeqNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNo: %w", err)
	}
	return oldValue.SeqNo, nil
}

// ResetSeqNo resets all changes to the "seq_no" field.
func (m *PaymentCallbackMutation) ResetSeqNo() {
	m.seq_no = nil
}

// SetType sets the "type" field.
func (m *PaymentCallbackMutation) SetType(dct domain.PaymentCallbackType) {
	m._type = &dct
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentCallbackMutation) GetType() (r domain.PaymentCallbackType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldType(ctx context.Context) (v domain.PaymentCallbackType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PaymentCallbackMutation) ResetType() {
	m._type = nil
}

// SetRaw sets the "raw" field.
func (m *PaymentCallbackMutation) SetRaw(jm json.RawMessage) {
	m.raw = &jm
	m.appendraw = nil
}

// Raw returns the value of the "raw" field in the mutation.
func (m *PaymentCallbackMutation) Raw() (r json.RawMessage, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldRaw(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// AppendRaw adds jm to the "raw" field.
func (m *PaymentCallbackMutation) AppendRaw(jm json.RawMessage) {
	m.appendraw = append(m.appendraw, jm...)
}

// AppendedRaw returns the list of values that were appended to the "raw" field in this mutation.
func (m *PaymentCallbackMutation) AppendedRaw() (json.RawMessage, bool) {
	if len(m.appendraw) == 0 {
		return nil, false
	}
	return m.appendraw, true
}

// ResetRaw resets all changes to the "raw" field.
func (m *PaymentCallbackMutation) ResetRaw() {
	m.raw = nil
	m.appendraw = nil
}

// SetProvider sets the "provider" field.
func (m *PaymentCallbackMutation) SetProvider(dp domain.PayProvider) {
	m.provider = &dp
}

// Provider returns the value of the "provider" field in the mutation.
func (m *PaymentCallbackMutation) Provider() (r domain.PayProvider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the PaymentCallback entity.
// If the PaymentCallback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCallbackMutation) OldProvider(ctx context.Context) (v domain.PayProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *PaymentCallbackMutation) ResetProvider() {
	m.provider = nil
}

// Where appends a list predicates to the PaymentCallbackMutation builder.
func (m *PaymentCallbackMutation) Where(ps ...predicate.PaymentCallback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentCallbackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentCallbackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentCallback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentCallbackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentCallbackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentCallback).
func (m *PaymentCallbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentCallbackMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, paymentcallback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentcallback.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, paymentcallback.FieldDeletedAt)
	}
	if m.seq_no != nil {
		fields = append(fields, paymentcallback.FieldSeqNo)
	}
	if m._type != nil {
		fields = append(fields, paymentcallback.FieldType)
	}
	if m.raw != nil {
		fields = append(fields, paymentcallback.FieldRaw)
	}
	if m.provider != nil {
		fields = append(fields, paymentcallback.FieldProvider)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentCallbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentcallback.FieldCreatedAt:
		return m.CreatedAt()
	case paymentcallback.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentcallback.FieldDeletedAt:
		return m.DeletedAt()
	case paymentcallback.FieldSeqNo:
		return m.SeqNo()
	case paymentcallback.FieldType:
		return m.GetType()
	case paymentcallback.FieldRaw:
		return m.Raw()
	case paymentcallback.FieldProvider:
		return m.Provider()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentCallbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentcallback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentcallback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentcallback.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case paymentcallback.FieldSeqNo:
		return m.OldSeqNo(ctx)
	case paymentcallback.FieldType:
		return m.OldType(ctx)
	case paymentcallback.FieldRaw:
		return m.OldRaw(ctx)
	case paymentcallback.FieldProvider:
		return m.OldProvider(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentCallback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentCallbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentcallback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentcallback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentcallback.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case paymentcallback.FieldSeqNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNo(v)
		return nil
	case paymentcallback.FieldType:
		v, ok := value.(domain.PaymentCallbackType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case paymentcallback.FieldRaw:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	case paymentcallback.FieldProvider:
		v, ok := value.(domain.PayProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentCallback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentCallbackMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, paymentcallback.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentCallbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentcallback.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentCallbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentcallback.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentCallback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentCallbackMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentCallbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentCallbackMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentCallback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentCallbackMutation) ResetField(name string) error {
	switch name {
	case paymentcallback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentcallback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentcallback.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case paymentcallback.FieldSeqNo:
		m.ResetSeqNo()
		return nil
	case paymentcallback.FieldType:
		m.ResetType()
		return nil
	case paymentcallback.FieldRaw:
		m.ResetRaw()
		return nil
	case paymentcallback.FieldProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown PaymentCallback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentCallbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentCallbackMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentCallbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentCallbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentCallbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentCallbackMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentCallbackMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentCallback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentCallbackMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentCallback edge %s", name)
}

// PointSettlementMutation represents an operation that mutates the PointSettlement nodes in the graph.
type PointSettlementMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	no                    *string
	store_id              *int
	addstore_id           *int
	store_name            *string
	order_count           *int
	addorder_count        *int
	amount                *decimal.Decimal
	total_points          *decimal.Decimal
	date                  *time.Time
	status                *int
	addstatus             *int
	point_settlement_rate *decimal.Decimal
	approved_at           *time.Time
	approver_id           *int
	addapprover_id        *int
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*PointSettlement, error)
	predicates            []predicate.PointSettlement
}

var _ ent.Mutation = (*PointSettlementMutation)(nil)

// pointsettlementOption allows management of the mutation configuration using functional options.
type pointsettlementOption func(*PointSettlementMutation)

// newPointSettlementMutation creates new mutation for the PointSettlement entity.
func newPointSettlementMutation(c config, op Op, opts ...pointsettlementOption) *PointSettlementMutation {
	m := &PointSettlementMutation{
		config:        c,
		op:            op,
		typ:           TypePointSettlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointSettlementID sets the ID field of the mutation.
func withPointSettlementID(id int) pointsettlementOption {
	return func(m *PointSettlementMutation) {
		var (
			err   error
			once  sync.Once
			value *PointSettlement
		)
		m.oldValue = func(ctx context.Context) (*PointSettlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PointSettlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointSettlement sets the old PointSettlement of the mutation.
func withPointSettlement(node *PointSettlement) pointsettlementOption {
	return func(m *PointSettlementMutation) {
		m.oldValue = func(context.Context) (*PointSettlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointSettlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointSettlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PointSettlementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PointSettlementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PointSettlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PointSettlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PointSettlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PointSettlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PointSettlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PointSettlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PointSettlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNo sets the "no" field.
func (m *PointSettlementMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *PointSettlementMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *PointSettlementMutation) ResetNo() {
	m.no = nil
}

// SetStoreID sets the "store_id" field.
func (m *PointSettlementMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *PointSettlementMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *PointSettlementMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *PointSettlementMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *PointSettlementMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetStoreName sets the "store_name" field.
func (m *PointSettlementMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *PointSettlementMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *PointSettlementMutation) ResetStoreName() {
	m.store_name = nil
}

// SetOrderCount sets the "order_count" field.
func (m *PointSettlementMutation) SetOrderCount(i int) {
	m.order_count = &i
	m.addorder_count = nil
}

// OrderCount returns the value of the "order_count" field in the mutation.
func (m *PointSettlementMutation) OrderCount() (r int, exists bool) {
	v := m.order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCount returns the old "order_count" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCount: %w", err)
	}
	return oldValue.OrderCount, nil
}

// AddOrderCount adds i to the "order_count" field.
func (m *PointSettlementMutation) AddOrderCount(i int) {
	if m.addorder_count != nil {
		*m.addorder_count += i
	} else {
		m.addorder_count = &i
	}
}

// AddedOrderCount returns the value that was added to the "order_count" field in this mutation.
func (m *PointSettlementMutation) AddedOrderCount() (r int, exists bool) {
	v := m.addorder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCount resets all changes to the "order_count" field.
func (m *PointSettlementMutation) ResetOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
}

// SetAmount sets the "amount" field.
func (m *PointSettlementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PointSettlementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *PointSettlementMutation) ResetAmount() {
	m.amount = nil
}

// SetTotalPoints sets the "total_points" field.
func (m *PointSettlementMutation) SetTotalPoints(d decimal.Decimal) {
	m.total_points = &d
}

// TotalPoints returns the value of the "total_points" field in the mutation.
func (m *PointSettlementMutation) TotalPoints() (r decimal.Decimal, exists bool) {
	v := m.total_points
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPoints returns the old "total_points" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldTotalPoints(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPoints: %w", err)
	}
	return oldValue.TotalPoints, nil
}

// ResetTotalPoints resets all changes to the "total_points" field.
func (m *PointSettlementMutation) ResetTotalPoints() {
	m.total_points = nil
}

// SetDate sets the "date" field.
func (m *PointSettlementMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *PointSettlementMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *PointSettlementMutation) ResetDate() {
	m.date = nil
}

// SetStatus sets the "status" field.
func (m *PointSettlementMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PointSettlementMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PointSettlementMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PointSettlementMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PointSettlementMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPointSettlementRate sets the "point_settlement_rate" field.
func (m *PointSettlementMutation) SetPointSettlementRate(d decimal.Decimal) {
	m.point_settlement_rate = &d
}

// PointSettlementRate returns the value of the "point_settlement_rate" field in the mutation.
func (m *PointSettlementMutation) PointSettlementRate() (r decimal.Decimal, exists bool) {
	v := m.point_settlement_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldPointSettlementRate returns the old "point_settlement_rate" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldPointSettlementRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointSettlementRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointSettlementRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointSettlementRate: %w", err)
	}
	return oldValue.PointSettlementRate, nil
}

// ResetPointSettlementRate resets all changes to the "point_settlement_rate" field.
func (m *PointSettlementMutation) ResetPointSettlementRate() {
	m.point_settlement_rate = nil
}

// SetApprovedAt sets the "approved_at" field.
func (m *PointSettlementMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *PointSettlementMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *PointSettlementMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[pointsettlement.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *PointSettlementMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[pointsettlement.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *PointSettlementMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, pointsettlement.FieldApprovedAt)
}

// SetApproverID sets the "approver_id" field.
func (m *PointSettlementMutation) SetApproverID(i int) {
	m.approver_id = &i
	m.addapprover_id = nil
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *PointSettlementMutation) ApproverID() (r int, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the PointSettlement entity.
// If the PointSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointSettlementMutation) OldApproverID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// AddApproverID adds i to the "approver_id" field.
func (m *PointSettlementMutation) AddApproverID(i int) {
	if m.addapprover_id != nil {
		*m.addapprover_id += i
	} else {
		m.addapprover_id = &i
	}
}

// AddedApproverID returns the value that was added to the "approver_id" field in this mutation.
func (m *PointSettlementMutation) AddedApproverID() (r int, exists bool) {
	v := m.addapprover_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *PointSettlementMutation) ClearApproverID() {
	m.approver_id = nil
	m.addapprover_id = nil
	m.clearedFields[pointsettlement.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *PointSettlementMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[pointsettlement.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *PointSettlementMutation) ResetApproverID() {
	m.approver_id = nil
	m.addapprover_id = nil
	delete(m.clearedFields, pointsettlement.FieldApproverID)
}

// Where appends a list predicates to the PointSettlementMutation builder.
func (m *PointSettlementMutation) Where(ps ...predicate.PointSettlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PointSettlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PointSettlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PointSettlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PointSettlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PointSettlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PointSettlement).
func (m *PointSettlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointSettlementMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, pointsettlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pointsettlement.FieldUpdatedAt)
	}
	if m.no != nil {
		fields = append(fields, pointsettlement.FieldNo)
	}
	if m.store_id != nil {
		fields = append(fields, pointsettlement.FieldStoreID)
	}
	if m.store_name != nil {
		fields = append(fields, pointsettlement.FieldStoreName)
	}
	if m.order_count != nil {
		fields = append(fields, pointsettlement.FieldOrderCount)
	}
	if m.amount != nil {
		fields = append(fields, pointsettlement.FieldAmount)
	}
	if m.total_points != nil {
		fields = append(fields, pointsettlement.FieldTotalPoints)
	}
	if m.date != nil {
		fields = append(fields, pointsettlement.FieldDate)
	}
	if m.status != nil {
		fields = append(fields, pointsettlement.FieldStatus)
	}
	if m.point_settlement_rate != nil {
		fields = append(fields, pointsettlement.FieldPointSettlementRate)
	}
	if m.approved_at != nil {
		fields = append(fields, pointsettlement.FieldApprovedAt)
	}
	if m.approver_id != nil {
		fields = append(fields, pointsettlement.FieldApproverID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointSettlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointsettlement.FieldCreatedAt:
		return m.CreatedAt()
	case pointsettlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case pointsettlement.FieldNo:
		return m.No()
	case pointsettlement.FieldStoreID:
		return m.StoreID()
	case pointsettlement.FieldStoreName:
		return m.StoreName()
	case pointsettlement.FieldOrderCount:
		return m.OrderCount()
	case pointsettlement.FieldAmount:
		return m.Amount()
	case pointsettlement.FieldTotalPoints:
		return m.TotalPoints()
	case pointsettlement.FieldDate:
		return m.Date()
	case pointsettlement.FieldStatus:
		return m.Status()
	case pointsettlement.FieldPointSettlementRate:
		return m.PointSettlementRate()
	case pointsettlement.FieldApprovedAt:
		return m.ApprovedAt()
	case pointsettlement.FieldApproverID:
		return m.ApproverID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointSettlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointsettlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pointsettlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pointsettlement.FieldNo:
		return m.OldNo(ctx)
	case pointsettlement.FieldStoreID:
		return m.OldStoreID(ctx)
	case pointsettlement.FieldStoreName:
		return m.OldStoreName(ctx)
	case pointsettlement.FieldOrderCount:
		return m.OldOrderCount(ctx)
	case pointsettlement.FieldAmount:
		return m.OldAmount(ctx)
	case pointsettlement.FieldTotalPoints:
		return m.OldTotalPoints(ctx)
	case pointsettlement.FieldDate:
		return m.OldDate(ctx)
	case pointsettlement.FieldStatus:
		return m.OldStatus(ctx)
	case pointsettlement.FieldPointSettlementRate:
		return m.OldPointSettlementRate(ctx)
	case pointsettlement.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case pointsettlement.FieldApproverID:
		return m.OldApproverID(ctx)
	}
	return nil, fmt.Errorf("unknown PointSettlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointSettlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointsettlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pointsettlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pointsettlement.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case pointsettlement.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case pointsettlement.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case pointsettlement.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCount(v)
		return nil
	case pointsettlement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case pointsettlement.FieldTotalPoints:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPoints(v)
		return nil
	case pointsettlement.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case pointsettlement.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case pointsettlement.FieldPointSettlementRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointSettlementRate(v)
		return nil
	case pointsettlement.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case pointsettlement.FieldApproverID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	}
	return fmt.Errorf("unknown PointSettlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointSettlementMutation) AddedFields() []string {
	var fields []string
	if m.addstore_id != nil {
		fields = append(fields, pointsettlement.FieldStoreID)
	}
	if m.addorder_count != nil {
		fields = append(fields, pointsettlement.FieldOrderCount)
	}
	if m.addstatus != nil {
		fields = append(fields, pointsettlement.FieldStatus)
	}
	if m.addapprover_id != nil {
		fields = append(fields, pointsettlement.FieldApproverID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointSettlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointsettlement.FieldStoreID:
		return m.AddedStoreID()
	case pointsettlement.FieldOrderCount:
		return m.AddedOrderCount()
	case pointsettlement.FieldStatus:
		return m.AddedStatus()
	case pointsettlement.FieldApproverID:
		return m.AddedApproverID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointSettlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointsettlement.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case pointsettlement.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCount(v)
		return nil
	case pointsettlement.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case pointsettlement.FieldApproverID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApproverID(v)
		return nil
	}
	return fmt.Errorf("unknown PointSettlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointSettlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointsettlement.FieldApprovedAt) {
		fields = append(fields, pointsettlement.FieldApprovedAt)
	}
	if m.FieldCleared(pointsettlement.FieldApproverID) {
		fields = append(fields, pointsettlement.FieldApproverID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointSettlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointSettlementMutation) ClearField(name string) error {
	switch name {
	case pointsettlement.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case pointsettlement.FieldApproverID:
		m.ClearApproverID()
		return nil
	}
	return fmt.Errorf("unknown PointSettlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointSettlementMutation) ResetField(name string) error {
	switch name {
	case pointsettlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pointsettlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pointsettlement.FieldNo:
		m.ResetNo()
		return nil
	case pointsettlement.FieldStoreID:
		m.ResetStoreID()
		return nil
	case pointsettlement.FieldStoreName:
		m.ResetStoreName()
		return nil
	case pointsettlement.FieldOrderCount:
		m.ResetOrderCount()
		return nil
	case pointsettlement.FieldAmount:
		m.ResetAmount()
		return nil
	case pointsettlement.FieldTotalPoints:
		m.ResetTotalPoints()
		return nil
	case pointsettlement.FieldDate:
		m.ResetDate()
		return nil
	case pointsettlement.FieldStatus:
		m.ResetStatus()
		return nil
	case pointsettlement.FieldPointSettlementRate:
		m.ResetPointSettlementRate()
		return nil
	case pointsettlement.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case pointsettlement.FieldApproverID:
		m.ResetApproverID()
		return nil
	}
	return fmt.Errorf("unknown PointSettlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointSettlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointSettlementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointSettlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointSettlementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointSettlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointSettlementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointSettlementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PointSettlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointSettlementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PointSettlement edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *int64
	adddeleted_at                *int64
	name                         *string
	store_id                     *int
	addstore_id                  *int
	_type                        *int
	add_type                     *int
	images                       *[]string
	appendimages                 []string
	price                        *decimal.Decimal
	status                       *int
	addstatus                    *int
	sale_status                  *int
	addsale_status               *int
	allow_point_pay              *bool
	clearedFields                map[string]struct{}
	category                     *int
	clearedcategory              bool
	unit                         *int
	clearedunit                  bool
	attrs                        map[int]struct{}
	removedattrs                 map[int]struct{}
	clearedattrs                 bool
	recipes                      map[int]struct{}
	removedrecipes               map[int]struct{}
	clearedrecipes               bool
	product_specs                map[int]struct{}
	removedproduct_specs         map[int]struct{}
	clearedproduct_specs         bool
	set_meal_details             map[int]struct{}
	removedset_meal_details      map[int]struct{}
	clearedset_meal_details      bool
	included_in_set_meals        map[int]struct{}
	removedincluded_in_set_meals map[int]struct{}
	clearedincluded_in_set_meals bool
	order_cart_items             map[int]struct{}
	removedorder_cart_items      map[int]struct{}
	clearedorder_cart_items      bool
	done                         bool
	oldValue                     func(context.Context) (*Product, error)
	predicates                   []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *ProductMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *ProductMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetType sets the "type" field.
func (m *ProductMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ProductMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ProductMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ProductMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetImages sets the "images" field.
func (m *ProductMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *ProductMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *ProductMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *ProductMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *ProductMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[product.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *ProductMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[product.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *ProductMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, product.FieldImages)
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *ProductMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[product.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, product.FieldPrice)
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSaleStatus sets the "sale_status" field.
func (m *ProductMutation) SetSaleStatus(i int) {
	m.sale_status = &i
	m.addsale_status = nil
}

// SaleStatus returns the value of the "sale_status" field in the mutation.
func (m *ProductMutation) SaleStatus() (r int, exists bool) {
	v := m.sale_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStatus returns the old "sale_status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSaleStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStatus: %w", err)
	}
	return oldValue.SaleStatus, nil
}

// AddSaleStatus adds i to the "sale_status" field.
func (m *ProductMutation) AddSaleStatus(i int) {
	if m.addsale_status != nil {
		*m.addsale_status += i
	} else {
		m.addsale_status = &i
	}
}

// AddedSaleStatus returns the value that was added to the "sale_status" field in this mutation.
func (m *ProductMutation) AddedSaleStatus() (r int, exists bool) {
	v := m.addsale_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetSaleStatus resets all changes to the "sale_status" field.
func (m *ProductMutation) ResetSaleStatus() {
	m.sale_status = nil
	m.addsale_status = nil
}

// SetAllowPointPay sets the "allow_point_pay" field.
func (m *ProductMutation) SetAllowPointPay(b bool) {
	m.allow_point_pay = &b
}

// AllowPointPay returns the value of the "allow_point_pay" field in the mutation.
func (m *ProductMutation) AllowPointPay() (r bool, exists bool) {
	v := m.allow_point_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowPointPay returns the old "allow_point_pay" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAllowPointPay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowPointPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowPointPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowPointPay: %w", err)
	}
	return oldValue.AllowPointPay, nil
}

// ResetAllowPointPay resets all changes to the "allow_point_pay" field.
func (m *ProductMutation) ResetAllowPointPay() {
	m.allow_point_pay = nil
}

// SetUnitID sets the "unit_id" field.
func (m *ProductMutation) SetUnitID(i int) {
	m.unit = &i
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *ProductMutation) UnitID() (r int, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ClearUnitID clears the value of the "unit_id" field.
func (m *ProductMutation) ClearUnitID() {
	m.unit = nil
	m.clearedFields[product.FieldUnitID] = struct{}{}
}

// UnitIDCleared returns if the "unit_id" field was cleared in this mutation.
func (m *ProductMutation) UnitIDCleared() bool {
	_, ok := m.clearedFields[product.FieldUnitID]
	return ok
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *ProductMutation) ResetUnitID() {
	m.unit = nil
	delete(m.clearedFields, product.FieldUnitID)
}

// SetCategoryID sets the "category_id" field.
func (m *ProductMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ProductMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ProductMutation) ResetCategoryID() {
	m.category = nil
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ProductMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[product.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ProductMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *ProductMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[product.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *ProductMutation) UnitCleared() bool {
	return m.UnitIDCleared() || m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) UnitIDs() (ids []int) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *ProductMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// AddAttrIDs adds the "attrs" edge to the Attr entity by ids.
func (m *ProductMutation) AddAttrIDs(ids ...int) {
	if m.attrs == nil {
		m.attrs = make(map[int]struct{})
	}
	for i := range ids {
		m.attrs[ids[i]] = struct{}{}
	}
}

// ClearAttrs clears the "attrs" edge to the Attr entity.
func (m *ProductMutation) ClearAttrs() {
	m.clearedattrs = true
}

// AttrsCleared reports if the "attrs" edge to the Attr entity was cleared.
func (m *ProductMutation) AttrsCleared() bool {
	return m.clearedattrs
}

// RemoveAttrIDs removes the "attrs" edge to the Attr entity by IDs.
func (m *ProductMutation) RemoveAttrIDs(ids ...int) {
	if m.removedattrs == nil {
		m.removedattrs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attrs, ids[i])
		m.removedattrs[ids[i]] = struct{}{}
	}
}

// RemovedAttrs returns the removed IDs of the "attrs" edge to the Attr entity.
func (m *ProductMutation) RemovedAttrsIDs() (ids []int) {
	for id := range m.removedattrs {
		ids = append(ids, id)
	}
	return
}

// AttrsIDs returns the "attrs" edge IDs in the mutation.
func (m *ProductMutation) AttrsIDs() (ids []int) {
	for id := range m.attrs {
		ids = append(ids, id)
	}
	return
}

// ResetAttrs resets all changes to the "attrs" edge.
func (m *ProductMutation) ResetAttrs() {
	m.attrs = nil
	m.clearedattrs = false
	m.removedattrs = nil
}

// AddRecipeIDs adds the "recipes" edge to the Recipe entity by ids.
func (m *ProductMutation) AddRecipeIDs(ids ...int) {
	if m.recipes == nil {
		m.recipes = make(map[int]struct{})
	}
	for i := range ids {
		m.recipes[ids[i]] = struct{}{}
	}
}

// ClearRecipes clears the "recipes" edge to the Recipe entity.
func (m *ProductMutation) ClearRecipes() {
	m.clearedrecipes = true
}

// RecipesCleared reports if the "recipes" edge to the Recipe entity was cleared.
func (m *ProductMutation) RecipesCleared() bool {
	return m.clearedrecipes
}

// RemoveRecipeIDs removes the "recipes" edge to the Recipe entity by IDs.
func (m *ProductMutation) RemoveRecipeIDs(ids ...int) {
	if m.removedrecipes == nil {
		m.removedrecipes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recipes, ids[i])
		m.removedrecipes[ids[i]] = struct{}{}
	}
}

// RemovedRecipes returns the removed IDs of the "recipes" edge to the Recipe entity.
func (m *ProductMutation) RemovedRecipesIDs() (ids []int) {
	for id := range m.removedrecipes {
		ids = append(ids, id)
	}
	return
}

// RecipesIDs returns the "recipes" edge IDs in the mutation.
func (m *ProductMutation) RecipesIDs() (ids []int) {
	for id := range m.recipes {
		ids = append(ids, id)
	}
	return
}

// ResetRecipes resets all changes to the "recipes" edge.
func (m *ProductMutation) ResetRecipes() {
	m.recipes = nil
	m.clearedrecipes = false
	m.removedrecipes = nil
}

// AddProductSpecIDs adds the "product_specs" edge to the ProductSpec entity by ids.
func (m *ProductMutation) AddProductSpecIDs(ids ...int) {
	if m.product_specs == nil {
		m.product_specs = make(map[int]struct{})
	}
	for i := range ids {
		m.product_specs[ids[i]] = struct{}{}
	}
}

// ClearProductSpecs clears the "product_specs" edge to the ProductSpec entity.
func (m *ProductMutation) ClearProductSpecs() {
	m.clearedproduct_specs = true
}

// ProductSpecsCleared reports if the "product_specs" edge to the ProductSpec entity was cleared.
func (m *ProductMutation) ProductSpecsCleared() bool {
	return m.clearedproduct_specs
}

// RemoveProductSpecIDs removes the "product_specs" edge to the ProductSpec entity by IDs.
func (m *ProductMutation) RemoveProductSpecIDs(ids ...int) {
	if m.removedproduct_specs == nil {
		m.removedproduct_specs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_specs, ids[i])
		m.removedproduct_specs[ids[i]] = struct{}{}
	}
}

// RemovedProductSpecs returns the removed IDs of the "product_specs" edge to the ProductSpec entity.
func (m *ProductMutation) RemovedProductSpecsIDs() (ids []int) {
	for id := range m.removedproduct_specs {
		ids = append(ids, id)
	}
	return
}

// ProductSpecsIDs returns the "product_specs" edge IDs in the mutation.
func (m *ProductMutation) ProductSpecsIDs() (ids []int) {
	for id := range m.product_specs {
		ids = append(ids, id)
	}
	return
}

// ResetProductSpecs resets all changes to the "product_specs" edge.
func (m *ProductMutation) ResetProductSpecs() {
	m.product_specs = nil
	m.clearedproduct_specs = false
	m.removedproduct_specs = nil
}

// AddSetMealDetailIDs adds the "set_meal_details" edge to the SetMealDetail entity by ids.
func (m *ProductMutation) AddSetMealDetailIDs(ids ...int) {
	if m.set_meal_details == nil {
		m.set_meal_details = make(map[int]struct{})
	}
	for i := range ids {
		m.set_meal_details[ids[i]] = struct{}{}
	}
}

// ClearSetMealDetails clears the "set_meal_details" edge to the SetMealDetail entity.
func (m *ProductMutation) ClearSetMealDetails() {
	m.clearedset_meal_details = true
}

// SetMealDetailsCleared reports if the "set_meal_details" edge to the SetMealDetail entity was cleared.
func (m *ProductMutation) SetMealDetailsCleared() bool {
	return m.clearedset_meal_details
}

// RemoveSetMealDetailIDs removes the "set_meal_details" edge to the SetMealDetail entity by IDs.
func (m *ProductMutation) RemoveSetMealDetailIDs(ids ...int) {
	if m.removedset_meal_details == nil {
		m.removedset_meal_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.set_meal_details, ids[i])
		m.removedset_meal_details[ids[i]] = struct{}{}
	}
}

// RemovedSetMealDetails returns the removed IDs of the "set_meal_details" edge to the SetMealDetail entity.
func (m *ProductMutation) RemovedSetMealDetailsIDs() (ids []int) {
	for id := range m.removedset_meal_details {
		ids = append(ids, id)
	}
	return
}

// SetMealDetailsIDs returns the "set_meal_details" edge IDs in the mutation.
func (m *ProductMutation) SetMealDetailsIDs() (ids []int) {
	for id := range m.set_meal_details {
		ids = append(ids, id)
	}
	return
}

// ResetSetMealDetails resets all changes to the "set_meal_details" edge.
func (m *ProductMutation) ResetSetMealDetails() {
	m.set_meal_details = nil
	m.clearedset_meal_details = false
	m.removedset_meal_details = nil
}

// AddIncludedInSetMealIDs adds the "included_in_set_meals" edge to the SetMealDetail entity by ids.
func (m *ProductMutation) AddIncludedInSetMealIDs(ids ...int) {
	if m.included_in_set_meals == nil {
		m.included_in_set_meals = make(map[int]struct{})
	}
	for i := range ids {
		m.included_in_set_meals[ids[i]] = struct{}{}
	}
}

// ClearIncludedInSetMeals clears the "included_in_set_meals" edge to the SetMealDetail entity.
func (m *ProductMutation) ClearIncludedInSetMeals() {
	m.clearedincluded_in_set_meals = true
}

// IncludedInSetMealsCleared reports if the "included_in_set_meals" edge to the SetMealDetail entity was cleared.
func (m *ProductMutation) IncludedInSetMealsCleared() bool {
	return m.clearedincluded_in_set_meals
}

// RemoveIncludedInSetMealIDs removes the "included_in_set_meals" edge to the SetMealDetail entity by IDs.
func (m *ProductMutation) RemoveIncludedInSetMealIDs(ids ...int) {
	if m.removedincluded_in_set_meals == nil {
		m.removedincluded_in_set_meals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.included_in_set_meals, ids[i])
		m.removedincluded_in_set_meals[ids[i]] = struct{}{}
	}
}

// RemovedIncludedInSetMeals returns the removed IDs of the "included_in_set_meals" edge to the SetMealDetail entity.
func (m *ProductMutation) RemovedIncludedInSetMealsIDs() (ids []int) {
	for id := range m.removedincluded_in_set_meals {
		ids = append(ids, id)
	}
	return
}

// IncludedInSetMealsIDs returns the "included_in_set_meals" edge IDs in the mutation.
func (m *ProductMutation) IncludedInSetMealsIDs() (ids []int) {
	for id := range m.included_in_set_meals {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedInSetMeals resets all changes to the "included_in_set_meals" edge.
func (m *ProductMutation) ResetIncludedInSetMeals() {
	m.included_in_set_meals = nil
	m.clearedincluded_in_set_meals = false
	m.removedincluded_in_set_meals = nil
}

// AddOrderCartItemIDs adds the "order_cart_items" edge to the OrderCart entity by ids.
func (m *ProductMutation) AddOrderCartItemIDs(ids ...int) {
	if m.order_cart_items == nil {
		m.order_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_cart_items[ids[i]] = struct{}{}
	}
}

// ClearOrderCartItems clears the "order_cart_items" edge to the OrderCart entity.
func (m *ProductMutation) ClearOrderCartItems() {
	m.clearedorder_cart_items = true
}

// OrderCartItemsCleared reports if the "order_cart_items" edge to the OrderCart entity was cleared.
func (m *ProductMutation) OrderCartItemsCleared() bool {
	return m.clearedorder_cart_items
}

// RemoveOrderCartItemIDs removes the "order_cart_items" edge to the OrderCart entity by IDs.
func (m *ProductMutation) RemoveOrderCartItemIDs(ids ...int) {
	if m.removedorder_cart_items == nil {
		m.removedorder_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_cart_items, ids[i])
		m.removedorder_cart_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderCartItems returns the removed IDs of the "order_cart_items" edge to the OrderCart entity.
func (m *ProductMutation) RemovedOrderCartItemsIDs() (ids []int) {
	for id := range m.removedorder_cart_items {
		ids = append(ids, id)
	}
	return
}

// OrderCartItemsIDs returns the "order_cart_items" edge IDs in the mutation.
func (m *ProductMutation) OrderCartItemsIDs() (ids []int) {
	for id := range m.order_cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderCartItems resets all changes to the "order_cart_items" edge.
func (m *ProductMutation) ResetOrderCartItems() {
	m.order_cart_items = nil
	m.clearedorder_cart_items = false
	m.removedorder_cart_items = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, product.FieldStoreID)
	}
	if m._type != nil {
		fields = append(fields, product.FieldType)
	}
	if m.images != nil {
		fields = append(fields, product.FieldImages)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.sale_status != nil {
		fields = append(fields, product.FieldSaleStatus)
	}
	if m.allow_point_pay != nil {
		fields = append(fields, product.FieldAllowPointPay)
	}
	if m.unit != nil {
		fields = append(fields, product.FieldUnitID)
	}
	if m.category != nil {
		fields = append(fields, product.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldStoreID:
		return m.StoreID()
	case product.FieldType:
		return m.GetType()
	case product.FieldImages:
		return m.Images()
	case product.FieldPrice:
		return m.Price()
	case product.FieldStatus:
		return m.Status()
	case product.FieldSaleStatus:
		return m.SaleStatus()
	case product.FieldAllowPointPay:
		return m.AllowPointPay()
	case product.FieldUnitID:
		return m.UnitID()
	case product.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldStoreID:
		return m.OldStoreID(ctx)
	case product.FieldType:
		return m.OldType(ctx)
	case product.FieldImages:
		return m.OldImages(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldSaleStatus:
		return m.OldSaleStatus(ctx)
	case product.FieldAllowPointPay:
		return m.OldAllowPointPay(ctx)
	case product.FieldUnitID:
		return m.OldUnitID(ctx)
	case product.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case product.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case product.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldSaleStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStatus(v)
		return nil
	case product.FieldAllowPointPay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowPointPay(v)
		return nil
	case product.FieldUnitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case product.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, product.FieldStoreID)
	}
	if m.add_type != nil {
		fields = append(fields, product.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.addsale_status != nil {
		fields = append(fields, product.FieldSaleStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldDeletedAt:
		return m.AddedDeletedAt()
	case product.FieldStoreID:
		return m.AddedStoreID()
	case product.FieldType:
		return m.AddedType()
	case product.FieldStatus:
		return m.AddedStatus()
	case product.FieldSaleStatus:
		return m.AddedSaleStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case product.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case product.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case product.FieldSaleStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldImages) {
		fields = append(fields, product.FieldImages)
	}
	if m.FieldCleared(product.FieldPrice) {
		fields = append(fields, product.FieldPrice)
	}
	if m.FieldCleared(product.FieldUnitID) {
		fields = append(fields, product.FieldUnitID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldImages:
		m.ClearImages()
		return nil
	case product.FieldPrice:
		m.ClearPrice()
		return nil
	case product.FieldUnitID:
		m.ClearUnitID()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldStoreID:
		m.ResetStoreID()
		return nil
	case product.FieldType:
		m.ResetType()
		return nil
	case product.FieldImages:
		m.ResetImages()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldSaleStatus:
		m.ResetSaleStatus()
		return nil
	case product.FieldAllowPointPay:
		m.ResetAllowPointPay()
		return nil
	case product.FieldUnitID:
		m.ResetUnitID()
		return nil
	case product.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.category != nil {
		edges = append(edges, product.EdgeCategory)
	}
	if m.unit != nil {
		edges = append(edges, product.EdgeUnit)
	}
	if m.attrs != nil {
		edges = append(edges, product.EdgeAttrs)
	}
	if m.recipes != nil {
		edges = append(edges, product.EdgeRecipes)
	}
	if m.product_specs != nil {
		edges = append(edges, product.EdgeProductSpecs)
	}
	if m.set_meal_details != nil {
		edges = append(edges, product.EdgeSetMealDetails)
	}
	if m.included_in_set_meals != nil {
		edges = append(edges, product.EdgeIncludedInSetMeals)
	}
	if m.order_cart_items != nil {
		edges = append(edges, product.EdgeOrderCartItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeAttrs:
		ids := make([]ent.Value, 0, len(m.attrs))
		for id := range m.attrs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeRecipes:
		ids := make([]ent.Value, 0, len(m.recipes))
		for id := range m.recipes {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.product_specs))
		for id := range m.product_specs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.set_meal_details))
		for id := range m.set_meal_details {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeIncludedInSetMeals:
		ids := make([]ent.Value, 0, len(m.included_in_set_meals))
		for id := range m.included_in_set_meals {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.order_cart_items))
		for id := range m.order_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedattrs != nil {
		edges = append(edges, product.EdgeAttrs)
	}
	if m.removedrecipes != nil {
		edges = append(edges, product.EdgeRecipes)
	}
	if m.removedproduct_specs != nil {
		edges = append(edges, product.EdgeProductSpecs)
	}
	if m.removedset_meal_details != nil {
		edges = append(edges, product.EdgeSetMealDetails)
	}
	if m.removedincluded_in_set_meals != nil {
		edges = append(edges, product.EdgeIncludedInSetMeals)
	}
	if m.removedorder_cart_items != nil {
		edges = append(edges, product.EdgeOrderCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeAttrs:
		ids := make([]ent.Value, 0, len(m.removedattrs))
		for id := range m.removedattrs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeRecipes:
		ids := make([]ent.Value, 0, len(m.removedrecipes))
		for id := range m.removedrecipes {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.removedproduct_specs))
		for id := range m.removedproduct_specs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.removedset_meal_details))
		for id := range m.removedset_meal_details {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeIncludedInSetMeals:
		ids := make([]ent.Value, 0, len(m.removedincluded_in_set_meals))
		for id := range m.removedincluded_in_set_meals {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.removedorder_cart_items))
		for id := range m.removedorder_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcategory {
		edges = append(edges, product.EdgeCategory)
	}
	if m.clearedunit {
		edges = append(edges, product.EdgeUnit)
	}
	if m.clearedattrs {
		edges = append(edges, product.EdgeAttrs)
	}
	if m.clearedrecipes {
		edges = append(edges, product.EdgeRecipes)
	}
	if m.clearedproduct_specs {
		edges = append(edges, product.EdgeProductSpecs)
	}
	if m.clearedset_meal_details {
		edges = append(edges, product.EdgeSetMealDetails)
	}
	if m.clearedincluded_in_set_meals {
		edges = append(edges, product.EdgeIncludedInSetMeals)
	}
	if m.clearedorder_cart_items {
		edges = append(edges, product.EdgeOrderCartItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCategory:
		return m.clearedcategory
	case product.EdgeUnit:
		return m.clearedunit
	case product.EdgeAttrs:
		return m.clearedattrs
	case product.EdgeRecipes:
		return m.clearedrecipes
	case product.EdgeProductSpecs:
		return m.clearedproduct_specs
	case product.EdgeSetMealDetails:
		return m.clearedset_meal_details
	case product.EdgeIncludedInSetMeals:
		return m.clearedincluded_in_set_meals
	case product.EdgeOrderCartItems:
		return m.clearedorder_cart_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCategory:
		m.ClearCategory()
		return nil
	case product.EdgeUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCategory:
		m.ResetCategory()
		return nil
	case product.EdgeUnit:
		m.ResetUnit()
		return nil
	case product.EdgeAttrs:
		m.ResetAttrs()
		return nil
	case product.EdgeRecipes:
		m.ResetRecipes()
		return nil
	case product.EdgeProductSpecs:
		m.ResetProductSpecs()
		return nil
	case product.EdgeSetMealDetails:
		m.ResetSetMealDetails()
		return nil
	case product.EdgeIncludedInSetMeals:
		m.ResetIncludedInSetMeals()
		return nil
	case product.EdgeOrderCartItems:
		m.ResetOrderCartItems()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductSpecMutation represents an operation that mutates the ProductSpec nodes in the graph.
type ProductSpecMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	price                   *decimal.Decimal
	sale_status             *int
	addsale_status          *int
	clearedFields           map[string]struct{}
	product                 *int
	clearedproduct          bool
	spec                    *int
	clearedspec             bool
	set_meal_details        map[int]struct{}
	removedset_meal_details map[int]struct{}
	clearedset_meal_details bool
	order_cart_items        map[int]struct{}
	removedorder_cart_items map[int]struct{}
	clearedorder_cart_items bool
	done                    bool
	oldValue                func(context.Context) (*ProductSpec, error)
	predicates              []predicate.ProductSpec
}

var _ ent.Mutation = (*ProductSpecMutation)(nil)

// productspecOption allows management of the mutation configuration using functional options.
type productspecOption func(*ProductSpecMutation)

// newProductSpecMutation creates new mutation for the ProductSpec entity.
func newProductSpecMutation(c config, op Op, opts ...productspecOption) *ProductSpecMutation {
	m := &ProductSpecMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpecID sets the ID field of the mutation.
func withProductSpecID(id int) productspecOption {
	return func(m *ProductSpecMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpec
		)
		m.oldValue = func(ctx context.Context) (*ProductSpec, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpec sets the old ProductSpec of the mutation.
func withProductSpec(node *ProductSpec) productspecOption {
	return func(m *ProductSpecMutation) {
		m.oldValue = func(context.Context) (*ProductSpec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductSpecMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductSpecMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductSpec.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrice sets the "price" field.
func (m *ProductSpecMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductSpecMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductSpecMutation) ResetPrice() {
	m.price = nil
}

// SetSaleStatus sets the "sale_status" field.
func (m *ProductSpecMutation) SetSaleStatus(i int) {
	m.sale_status = &i
	m.addsale_status = nil
}

// SaleStatus returns the value of the "sale_status" field in the mutation.
func (m *ProductSpecMutation) SaleStatus() (r int, exists bool) {
	v := m.sale_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStatus returns the old "sale_status" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldSaleStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStatus: %w", err)
	}
	return oldValue.SaleStatus, nil
}

// AddSaleStatus adds i to the "sale_status" field.
func (m *ProductSpecMutation) AddSaleStatus(i int) {
	if m.addsale_status != nil {
		*m.addsale_status += i
	} else {
		m.addsale_status = &i
	}
}

// AddedSaleStatus returns the value that was added to the "sale_status" field in this mutation.
func (m *ProductSpecMutation) AddedSaleStatus() (r int, exists bool) {
	v := m.addsale_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetSaleStatus resets all changes to the "sale_status" field.
func (m *ProductSpecMutation) ResetSaleStatus() {
	m.sale_status = nil
	m.addsale_status = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductSpecMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductSpecMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductSpecMutation) ResetProductID() {
	m.product = nil
}

// SetSpecID sets the "spec_id" field.
func (m *ProductSpecMutation) SetSpecID(i int) {
	m.spec = &i
}

// SpecID returns the value of the "spec_id" field in the mutation.
func (m *ProductSpecMutation) SpecID() (r int, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecID returns the old "spec_id" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldSpecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecID: %w", err)
	}
	return oldValue.SpecID, nil
}

// ResetSpecID resets all changes to the "spec_id" field.
func (m *ProductSpecMutation) ResetSpecID() {
	m.spec = nil
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductSpecMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productspec.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductSpecMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductSpecMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductSpecMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearSpec clears the "spec" edge to the Spec entity.
func (m *ProductSpecMutation) ClearSpec() {
	m.clearedspec = true
	m.clearedFields[productspec.FieldSpecID] = struct{}{}
}

// SpecCleared reports if the "spec" edge to the Spec entity was cleared.
func (m *ProductSpecMutation) SpecCleared() bool {
	return m.clearedspec
}

// SpecIDs returns the "spec" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpecID instead. It exists only for internal usage by the builders.
func (m *ProductSpecMutation) SpecIDs() (ids []int) {
	if id := m.spec; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpec resets all changes to the "spec" edge.
func (m *ProductSpecMutation) ResetSpec() {
	m.spec = nil
	m.clearedspec = false
}

// AddSetMealDetailIDs adds the "set_meal_details" edge to the SetMealDetail entity by ids.
func (m *ProductSpecMutation) AddSetMealDetailIDs(ids ...int) {
	if m.set_meal_details == nil {
		m.set_meal_details = make(map[int]struct{})
	}
	for i := range ids {
		m.set_meal_details[ids[i]] = struct{}{}
	}
}

// ClearSetMealDetails clears the "set_meal_details" edge to the SetMealDetail entity.
func (m *ProductSpecMutation) ClearSetMealDetails() {
	m.clearedset_meal_details = true
}

// SetMealDetailsCleared reports if the "set_meal_details" edge to the SetMealDetail entity was cleared.
func (m *ProductSpecMutation) SetMealDetailsCleared() bool {
	return m.clearedset_meal_details
}

// RemoveSetMealDetailIDs removes the "set_meal_details" edge to the SetMealDetail entity by IDs.
func (m *ProductSpecMutation) RemoveSetMealDetailIDs(ids ...int) {
	if m.removedset_meal_details == nil {
		m.removedset_meal_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.set_meal_details, ids[i])
		m.removedset_meal_details[ids[i]] = struct{}{}
	}
}

// RemovedSetMealDetails returns the removed IDs of the "set_meal_details" edge to the SetMealDetail entity.
func (m *ProductSpecMutation) RemovedSetMealDetailsIDs() (ids []int) {
	for id := range m.removedset_meal_details {
		ids = append(ids, id)
	}
	return
}

// SetMealDetailsIDs returns the "set_meal_details" edge IDs in the mutation.
func (m *ProductSpecMutation) SetMealDetailsIDs() (ids []int) {
	for id := range m.set_meal_details {
		ids = append(ids, id)
	}
	return
}

// ResetSetMealDetails resets all changes to the "set_meal_details" edge.
func (m *ProductSpecMutation) ResetSetMealDetails() {
	m.set_meal_details = nil
	m.clearedset_meal_details = false
	m.removedset_meal_details = nil
}

// AddOrderCartItemIDs adds the "order_cart_items" edge to the OrderCart entity by ids.
func (m *ProductSpecMutation) AddOrderCartItemIDs(ids ...int) {
	if m.order_cart_items == nil {
		m.order_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_cart_items[ids[i]] = struct{}{}
	}
}

// ClearOrderCartItems clears the "order_cart_items" edge to the OrderCart entity.
func (m *ProductSpecMutation) ClearOrderCartItems() {
	m.clearedorder_cart_items = true
}

// OrderCartItemsCleared reports if the "order_cart_items" edge to the OrderCart entity was cleared.
func (m *ProductSpecMutation) OrderCartItemsCleared() bool {
	return m.clearedorder_cart_items
}

// RemoveOrderCartItemIDs removes the "order_cart_items" edge to the OrderCart entity by IDs.
func (m *ProductSpecMutation) RemoveOrderCartItemIDs(ids ...int) {
	if m.removedorder_cart_items == nil {
		m.removedorder_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_cart_items, ids[i])
		m.removedorder_cart_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderCartItems returns the removed IDs of the "order_cart_items" edge to the OrderCart entity.
func (m *ProductSpecMutation) RemovedOrderCartItemsIDs() (ids []int) {
	for id := range m.removedorder_cart_items {
		ids = append(ids, id)
	}
	return
}

// OrderCartItemsIDs returns the "order_cart_items" edge IDs in the mutation.
func (m *ProductSpecMutation) OrderCartItemsIDs() (ids []int) {
	for id := range m.order_cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderCartItems resets all changes to the "order_cart_items" edge.
func (m *ProductSpecMutation) ResetOrderCartItems() {
	m.order_cart_items = nil
	m.clearedorder_cart_items = false
	m.removedorder_cart_items = nil
}

// Where appends a list predicates to the ProductSpecMutation builder.
func (m *ProductSpecMutation) Where(ps ...predicate.ProductSpec) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductSpecMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductSpecMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductSpec, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductSpecMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductSpecMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductSpec).
func (m *ProductSpecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpecMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.price != nil {
		fields = append(fields, productspec.FieldPrice)
	}
	if m.sale_status != nil {
		fields = append(fields, productspec.FieldSaleStatus)
	}
	if m.product != nil {
		fields = append(fields, productspec.FieldProductID)
	}
	if m.spec != nil {
		fields = append(fields, productspec.FieldSpecID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspec.FieldPrice:
		return m.Price()
	case productspec.FieldSaleStatus:
		return m.SaleStatus()
	case productspec.FieldProductID:
		return m.ProductID()
	case productspec.FieldSpecID:
		return m.SpecID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspec.FieldPrice:
		return m.OldPrice(ctx)
	case productspec.FieldSaleStatus:
		return m.OldSaleStatus(ctx)
	case productspec.FieldProductID:
		return m.OldProductID(ctx)
	case productspec.FieldSpecID:
		return m.OldSpecID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspec.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productspec.FieldSaleStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStatus(v)
		return nil
	case productspec.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productspec.FieldSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpecMutation) AddedFields() []string {
	var fields []string
	if m.addsale_status != nil {
		fields = append(fields, productspec.FieldSaleStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspec.FieldSaleStatus:
		return m.AddedSaleStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspec.FieldSaleStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpecMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpecMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductSpec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpecMutation) ResetField(name string) error {
	switch name {
	case productspec.FieldPrice:
		m.ResetPrice()
		return nil
	case productspec.FieldSaleStatus:
		m.ResetSaleStatus()
		return nil
	case productspec.FieldProductID:
		m.ResetProductID()
		return nil
	case productspec.FieldSpecID:
		m.ResetSpecID()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpecMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.product != nil {
		edges = append(edges, productspec.EdgeProduct)
	}
	if m.spec != nil {
		edges = append(edges, productspec.EdgeSpec)
	}
	if m.set_meal_details != nil {
		edges = append(edges, productspec.EdgeSetMealDetails)
	}
	if m.order_cart_items != nil {
		edges = append(edges, productspec.EdgeOrderCartItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpecMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productspec.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productspec.EdgeSpec:
		if id := m.spec; id != nil {
			return []ent.Value{*id}
		}
	case productspec.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.set_meal_details))
		for id := range m.set_meal_details {
			ids = append(ids, id)
		}
		return ids
	case productspec.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.order_cart_items))
		for id := range m.order_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedset_meal_details != nil {
		edges = append(edges, productspec.EdgeSetMealDetails)
	}
	if m.removedorder_cart_items != nil {
		edges = append(edges, productspec.EdgeOrderCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpecMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productspec.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.removedset_meal_details))
		for id := range m.removedset_meal_details {
			ids = append(ids, id)
		}
		return ids
	case productspec.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.removedorder_cart_items))
		for id := range m.removedorder_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproduct {
		edges = append(edges, productspec.EdgeProduct)
	}
	if m.clearedspec {
		edges = append(edges, productspec.EdgeSpec)
	}
	if m.clearedset_meal_details {
		edges = append(edges, productspec.EdgeSetMealDetails)
	}
	if m.clearedorder_cart_items {
		edges = append(edges, productspec.EdgeOrderCartItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpecMutation) EdgeCleared(name string) bool {
	switch name {
	case productspec.EdgeProduct:
		return m.clearedproduct
	case productspec.EdgeSpec:
		return m.clearedspec
	case productspec.EdgeSetMealDetails:
		return m.clearedset_meal_details
	case productspec.EdgeOrderCartItems:
		return m.clearedorder_cart_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpecMutation) ClearEdge(name string) error {
	switch name {
	case productspec.EdgeProduct:
		m.ClearProduct()
		return nil
	case productspec.EdgeSpec:
		m.ClearSpec()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpecMutation) ResetEdge(name string) error {
	switch name {
	case productspec.EdgeProduct:
		m.ResetProduct()
		return nil
	case productspec.EdgeSpec:
		m.ResetSpec()
		return nil
	case productspec.EdgeSetMealDetails:
		m.ResetSetMealDetails()
		return nil
	case productspec.EdgeOrderCartItems:
		m.ResetOrderCartItems()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec edge %s", name)
}

// RecipeMutation represents an operation that mutates the Recipe nodes in the graph.
type RecipeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *int64
	adddeleted_at           *int64
	name                    *string
	store_id                *int
	addstore_id             *int
	clearedFields           map[string]struct{}
	products                map[int]struct{}
	removedproducts         map[int]struct{}
	clearedproducts         bool
	order_cart_items        map[int]struct{}
	removedorder_cart_items map[int]struct{}
	clearedorder_cart_items bool
	done                    bool
	oldValue                func(context.Context) (*Recipe, error)
	predicates              []predicate.Recipe
}

var _ ent.Mutation = (*RecipeMutation)(nil)

// recipeOption allows management of the mutation configuration using functional options.
type recipeOption func(*RecipeMutation)

// newRecipeMutation creates new mutation for the Recipe entity.
func newRecipeMutation(c config, op Op, opts ...recipeOption) *RecipeMutation {
	m := &RecipeMutation{
		config:        c,
		op:            op,
		typ:           TypeRecipe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecipeID sets the ID field of the mutation.
func withRecipeID(id int) recipeOption {
	return func(m *RecipeMutation) {
		var (
			err   error
			once  sync.Once
			value *Recipe
		)
		m.oldValue = func(ctx context.Context) (*Recipe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recipe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecipe sets the old Recipe of the mutation.
func withRecipe(node *Recipe) recipeOption {
	return func(m *RecipeMutation) {
		m.oldValue = func(context.Context) (*Recipe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecipeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecipeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecipeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecipeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recipe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RecipeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecipeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecipeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecipeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecipeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecipeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RecipeMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RecipeMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RecipeMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RecipeMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RecipeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RecipeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RecipeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RecipeMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *RecipeMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *RecipeMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Recipe entity.
// If the Recipe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecipeMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *RecipeMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *RecipeMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *RecipeMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *RecipeMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *RecipeMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *RecipeMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *RecipeMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *RecipeMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *RecipeMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *RecipeMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddOrderCartItemIDs adds the "order_cart_items" edge to the OrderCart entity by ids.
func (m *RecipeMutation) AddOrderCartItemIDs(ids ...int) {
	if m.order_cart_items == nil {
		m.order_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_cart_items[ids[i]] = struct{}{}
	}
}

// ClearOrderCartItems clears the "order_cart_items" edge to the OrderCart entity.
func (m *RecipeMutation) ClearOrderCartItems() {
	m.clearedorder_cart_items = true
}

// OrderCartItemsCleared reports if the "order_cart_items" edge to the OrderCart entity was cleared.
func (m *RecipeMutation) OrderCartItemsCleared() bool {
	return m.clearedorder_cart_items
}

// RemoveOrderCartItemIDs removes the "order_cart_items" edge to the OrderCart entity by IDs.
func (m *RecipeMutation) RemoveOrderCartItemIDs(ids ...int) {
	if m.removedorder_cart_items == nil {
		m.removedorder_cart_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_cart_items, ids[i])
		m.removedorder_cart_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderCartItems returns the removed IDs of the "order_cart_items" edge to the OrderCart entity.
func (m *RecipeMutation) RemovedOrderCartItemsIDs() (ids []int) {
	for id := range m.removedorder_cart_items {
		ids = append(ids, id)
	}
	return
}

// OrderCartItemsIDs returns the "order_cart_items" edge IDs in the mutation.
func (m *RecipeMutation) OrderCartItemsIDs() (ids []int) {
	for id := range m.order_cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderCartItems resets all changes to the "order_cart_items" edge.
func (m *RecipeMutation) ResetOrderCartItems() {
	m.order_cart_items = nil
	m.clearedorder_cart_items = false
	m.removedorder_cart_items = nil
}

// Where appends a list predicates to the RecipeMutation builder.
func (m *RecipeMutation) Where(ps ...predicate.Recipe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecipeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecipeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Recipe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecipeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecipeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Recipe).
func (m *RecipeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecipeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, recipe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recipe.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, recipe.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, recipe.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, recipe.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecipeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recipe.FieldCreatedAt:
		return m.CreatedAt()
	case recipe.FieldUpdatedAt:
		return m.UpdatedAt()
	case recipe.FieldDeletedAt:
		return m.DeletedAt()
	case recipe.FieldName:
		return m.Name()
	case recipe.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecipeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recipe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recipe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recipe.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case recipe.FieldName:
		return m.OldName(ctx)
	case recipe.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Recipe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecipeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recipe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recipe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recipe.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case recipe.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case recipe.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Recipe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecipeMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, recipe.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, recipe.FieldStoreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecipeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recipe.FieldDeletedAt:
		return m.AddedDeletedAt()
	case recipe.FieldStoreID:
		return m.AddedStoreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecipeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recipe.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case recipe.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Recipe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecipeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecipeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecipeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Recipe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecipeMutation) ResetField(name string) error {
	switch name {
	case recipe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recipe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recipe.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case recipe.FieldName:
		m.ResetName()
		return nil
	case recipe.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Recipe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecipeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, recipe.EdgeProducts)
	}
	if m.order_cart_items != nil {
		edges = append(edges, recipe.EdgeOrderCartItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecipeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recipe.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.order_cart_items))
		for id := range m.order_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecipeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, recipe.EdgeProducts)
	}
	if m.removedorder_cart_items != nil {
		edges = append(edges, recipe.EdgeOrderCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecipeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recipe.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case recipe.EdgeOrderCartItems:
		ids := make([]ent.Value, 0, len(m.removedorder_cart_items))
		for id := range m.removedorder_cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecipeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, recipe.EdgeProducts)
	}
	if m.clearedorder_cart_items {
		edges = append(edges, recipe.EdgeOrderCartItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecipeMutation) EdgeCleared(name string) bool {
	switch name {
	case recipe.EdgeProducts:
		return m.clearedproducts
	case recipe.EdgeOrderCartItems:
		return m.clearedorder_cart_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecipeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Recipe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecipeMutation) ResetEdge(name string) error {
	switch name {
	case recipe.EdgeProducts:
		m.ResetProducts()
		return nil
	case recipe.EdgeOrderCartItems:
		m.ResetOrderCartItems()
		return nil
	}
	return fmt.Errorf("unknown Recipe edge %s", name)
}

// ReconciliationRecordMutation represents an operation that mutates the ReconciliationRecord nodes in the graph.
type ReconciliationRecordMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	no             *string
	store_id       *int
	addstore_id    *int
	store_name     *string
	order_count    *int
	addorder_count *int
	amount         *decimal.Decimal
	channel        *domain.OrderPaidChannel
	date           *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ReconciliationRecord, error)
	predicates     []predicate.ReconciliationRecord
}

var _ ent.Mutation = (*ReconciliationRecordMutation)(nil)

// reconciliationrecordOption allows management of the mutation configuration using functional options.
type reconciliationrecordOption func(*ReconciliationRecordMutation)

// newReconciliationRecordMutation creates new mutation for the ReconciliationRecord entity.
func newReconciliationRecordMutation(c config, op Op, opts ...reconciliationrecordOption) *ReconciliationRecordMutation {
	m := &ReconciliationRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeReconciliationRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReconciliationRecordID sets the ID field of the mutation.
func withReconciliationRecordID(id int) reconciliationrecordOption {
	return func(m *ReconciliationRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ReconciliationRecord
		)
		m.oldValue = func(ctx context.Context) (*ReconciliationRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReconciliationRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReconciliationRecord sets the old ReconciliationRecord of the mutation.
func withReconciliationRecord(node *ReconciliationRecord) reconciliationrecordOption {
	return func(m *ReconciliationRecordMutation) {
		m.oldValue = func(context.Context) (*ReconciliationRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReconciliationRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReconciliationRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReconciliationRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReconciliationRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReconciliationRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReconciliationRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReconciliationRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReconciliationRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReconciliationRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReconciliationRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReconciliationRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNo sets the "no" field.
func (m *ReconciliationRecordMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *ReconciliationRecordMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *ReconciliationRecordMutation) ResetNo() {
	m.no = nil
}

// SetStoreID sets the "store_id" field.
func (m *ReconciliationRecordMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ReconciliationRecordMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *ReconciliationRecordMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *ReconciliationRecordMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ReconciliationRecordMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetStoreName sets the "store_name" field.
func (m *ReconciliationRecordMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *ReconciliationRecordMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *ReconciliationRecordMutation) ResetStoreName() {
	m.store_name = nil
}

// SetOrderCount sets the "order_count" field.
func (m *ReconciliationRecordMutation) SetOrderCount(i int) {
	m.order_count = &i
	m.addorder_count = nil
}

// OrderCount returns the value of the "order_count" field in the mutation.
func (m *ReconciliationRecordMutation) OrderCount() (r int, exists bool) {
	v := m.order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCount returns the old "order_count" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCount: %w", err)
	}
	return oldValue.OrderCount, nil
}

// AddOrderCount adds i to the "order_count" field.
func (m *ReconciliationRecordMutation) AddOrderCount(i int) {
	if m.addorder_count != nil {
		*m.addorder_count += i
	} else {
		m.addorder_count = &i
	}
}

// AddedOrderCount returns the value that was added to the "order_count" field in this mutation.
func (m *ReconciliationRecordMutation) AddedOrderCount() (r int, exists bool) {
	v := m.addorder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCount resets all changes to the "order_count" field.
func (m *ReconciliationRecordMutation) ResetOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
}

// SetAmount sets the "amount" field.
func (m *ReconciliationRecordMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ReconciliationRecordMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *ReconciliationRecordMutation) ResetAmount() {
	m.amount = nil
}

// SetChannel sets the "channel" field.
func (m *ReconciliationRecordMutation) SetChannel(dpc domain.OrderPaidChannel) {
	m.channel = &dpc
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ReconciliationRecordMutation) Channel() (r domain.OrderPaidChannel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldChannel(ctx context.Context) (v domain.OrderPaidChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *ReconciliationRecordMutation) ResetChannel() {
	m.channel = nil
}

// SetDate sets the "date" field.
func (m *ReconciliationRecordMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ReconciliationRecordMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the ReconciliationRecord entity.
// If the ReconciliationRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationRecordMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *ReconciliationRecordMutation) ResetDate() {
	m.date = nil
}

// Where appends a list predicates to the ReconciliationRecordMutation builder.
func (m *ReconciliationRecordMutation) Where(ps ...predicate.ReconciliationRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReconciliationRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReconciliationRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReconciliationRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReconciliationRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReconciliationRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReconciliationRecord).
func (m *ReconciliationRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReconciliationRecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, reconciliationrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reconciliationrecord.FieldUpdatedAt)
	}
	if m.no != nil {
		fields = append(fields, reconciliationrecord.FieldNo)
	}
	if m.store_id != nil {
		fields = append(fields, reconciliationrecord.FieldStoreID)
	}
	if m.store_name != nil {
		fields = append(fields, reconciliationrecord.FieldStoreName)
	}
	if m.order_count != nil {
		fields = append(fields, reconciliationrecord.FieldOrderCount)
	}
	if m.amount != nil {
		fields = append(fields, reconciliationrecord.FieldAmount)
	}
	if m.channel != nil {
		fields = append(fields, reconciliationrecord.FieldChannel)
	}
	if m.date != nil {
		fields = append(fields, reconciliationrecord.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReconciliationRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reconciliationrecord.FieldCreatedAt:
		return m.CreatedAt()
	case reconciliationrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case reconciliationrecord.FieldNo:
		return m.No()
	case reconciliationrecord.FieldStoreID:
		return m.StoreID()
	case reconciliationrecord.FieldStoreName:
		return m.StoreName()
	case reconciliationrecord.FieldOrderCount:
		return m.OrderCount()
	case reconciliationrecord.FieldAmount:
		return m.Amount()
	case reconciliationrecord.FieldChannel:
		return m.Channel()
	case reconciliationrecord.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReconciliationRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reconciliationrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reconciliationrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reconciliationrecord.FieldNo:
		return m.OldNo(ctx)
	case reconciliationrecord.FieldStoreID:
		return m.OldStoreID(ctx)
	case reconciliationrecord.FieldStoreName:
		return m.OldStoreName(ctx)
	case reconciliationrecord.FieldOrderCount:
		return m.OldOrderCount(ctx)
	case reconciliationrecord.FieldAmount:
		return m.OldAmount(ctx)
	case reconciliationrecord.FieldChannel:
		return m.OldChannel(ctx)
	case reconciliationrecord.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown ReconciliationRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReconciliationRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reconciliationrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reconciliationrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reconciliationrecord.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case reconciliationrecord.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case reconciliationrecord.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case reconciliationrecord.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCount(v)
		return nil
	case reconciliationrecord.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case reconciliationrecord.FieldChannel:
		v, ok := value.(domain.OrderPaidChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case reconciliationrecord.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown ReconciliationRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReconciliationRecordMutation) AddedFields() []string {
	var fields []string
	if m.addstore_id != nil {
		fields = append(fields, reconciliationrecord.FieldStoreID)
	}
	if m.addorder_count != nil {
		fields = append(fields, reconciliationrecord.FieldOrderCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReconciliationRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reconciliationrecord.FieldStoreID:
		return m.AddedStoreID()
	case reconciliationrecord.FieldOrderCount:
		return m.AddedOrderCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReconciliationRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reconciliationrecord.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case reconciliationrecord.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCount(v)
		return nil
	}
	return fmt.Errorf("unknown ReconciliationRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReconciliationRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReconciliationRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReconciliationRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReconciliationRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReconciliationRecordMutation) ResetField(name string) error {
	switch name {
	case reconciliationrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reconciliationrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reconciliationrecord.FieldNo:
		m.ResetNo()
		return nil
	case reconciliationrecord.FieldStoreID:
		m.ResetStoreID()
		return nil
	case reconciliationrecord.FieldStoreName:
		m.ResetStoreName()
		return nil
	case reconciliationrecord.FieldOrderCount:
		m.ResetOrderCount()
		return nil
	case reconciliationrecord.FieldAmount:
		m.ResetAmount()
		return nil
	case reconciliationrecord.FieldChannel:
		m.ResetChannel()
		return nil
	case reconciliationrecord.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown ReconciliationRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReconciliationRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReconciliationRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReconciliationRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReconciliationRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReconciliationRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReconciliationRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReconciliationRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReconciliationRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReconciliationRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReconciliationRecord edge %s", name)
}

// SetMealDetailMutation represents an operation that mutates the SetMealDetail nodes in the graph.
type SetMealDetailMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *int64
	adddeleted_at       *int64
	price               *decimal.Decimal
	quantity            *decimal.Decimal
	clearedFields       map[string]struct{}
	set_meal            *int
	clearedset_meal     bool
	product             *int
	clearedproduct      bool
	product_spec        *int
	clearedproduct_spec bool
	done                bool
	oldValue            func(context.Context) (*SetMealDetail, error)
	predicates          []predicate.SetMealDetail
}

var _ ent.Mutation = (*SetMealDetailMutation)(nil)

// setmealdetailOption allows management of the mutation configuration using functional options.
type setmealdetailOption func(*SetMealDetailMutation)

// newSetMealDetailMutation creates new mutation for the SetMealDetail entity.
func newSetMealDetailMutation(c config, op Op, opts ...setmealdetailOption) *SetMealDetailMutation {
	m := &SetMealDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeSetMealDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetMealDetailID sets the ID field of the mutation.
func withSetMealDetailID(id int) setmealdetailOption {
	return func(m *SetMealDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *SetMealDetail
		)
		m.oldValue = func(ctx context.Context) (*SetMealDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SetMealDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetMealDetail sets the old SetMealDetail of the mutation.
func withSetMealDetail(node *SetMealDetail) setmealdetailOption {
	return func(m *SetMealDetailMutation) {
		m.oldValue = func(context.Context) (*SetMealDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMealDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMealDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMealDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMealDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SetMealDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SetMealDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SetMealDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SetMealDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SetMealDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SetMealDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SetMealDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SetMealDetailMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SetMealDetailMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SetMealDetailMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SetMealDetailMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SetMealDetailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetPrice sets the "price" field.
func (m *SetMealDetailMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *SetMealDetailMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *SetMealDetailMutation) ResetPrice() {
	m.price = nil
}

// SetQuantity sets the "quantity" field.
func (m *SetMealDetailMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *SetMealDetailMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *SetMealDetailMutation) ResetQuantity() {
	m.quantity = nil
}

// SetSetMealID sets the "set_meal_id" field.
func (m *SetMealDetailMutation) SetSetMealID(i int) {
	m.set_meal = &i
}

// SetMealID returns the value of the "set_meal_id" field in the mutation.
func (m *SetMealDetailMutation) SetMealID() (r int, exists bool) {
	v := m.set_meal
	if v == nil {
		return
	}
	return *v, true
}

// OldSetMealID returns the old "set_meal_id" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldSetMealID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetMealID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetMealID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetMealID: %w", err)
	}
	return oldValue.SetMealID, nil
}

// ResetSetMealID resets all changes to the "set_meal_id" field.
func (m *SetMealDetailMutation) ResetSetMealID() {
	m.set_meal = nil
}

// SetProductID sets the "product_id" field.
func (m *SetMealDetailMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *SetMealDetailMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *SetMealDetailMutation) ResetProductID() {
	m.product = nil
}

// SetProductSpecID sets the "product_spec_id" field.
func (m *SetMealDetailMutation) SetProductSpecID(i int) {
	m.product_spec = &i
}

// ProductSpecID returns the value of the "product_spec_id" field in the mutation.
func (m *SetMealDetailMutation) ProductSpecID() (r int, exists bool) {
	v := m.product_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldProductSpecID returns the old "product_spec_id" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldProductSpecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductSpecID: %w", err)
	}
	return oldValue.ProductSpecID, nil
}

// ClearProductSpecID clears the value of the "product_spec_id" field.
func (m *SetMealDetailMutation) ClearProductSpecID() {
	m.product_spec = nil
	m.clearedFields[setmealdetail.FieldProductSpecID] = struct{}{}
}

// ProductSpecIDCleared returns if the "product_spec_id" field was cleared in this mutation.
func (m *SetMealDetailMutation) ProductSpecIDCleared() bool {
	_, ok := m.clearedFields[setmealdetail.FieldProductSpecID]
	return ok
}

// ResetProductSpecID resets all changes to the "product_spec_id" field.
func (m *SetMealDetailMutation) ResetProductSpecID() {
	m.product_spec = nil
	delete(m.clearedFields, setmealdetail.FieldProductSpecID)
}

// ClearSetMeal clears the "set_meal" edge to the Product entity.
func (m *SetMealDetailMutation) ClearSetMeal() {
	m.clearedset_meal = true
	m.clearedFields[setmealdetail.FieldSetMealID] = struct{}{}
}

// SetMealCleared reports if the "set_meal" edge to the Product entity was cleared.
func (m *SetMealDetailMutation) SetMealCleared() bool {
	return m.clearedset_meal
}

// SetMealIDs returns the "set_meal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SetMealID instead. It exists only for internal usage by the builders.
func (m *SetMealDetailMutation) SetMealIDs() (ids []int) {
	if id := m.set_meal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSetMeal resets all changes to the "set_meal" edge.
func (m *SetMealDetailMutation) ResetSetMeal() {
	m.set_meal = nil
	m.clearedset_meal = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *SetMealDetailMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[setmealdetail.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *SetMealDetailMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *SetMealDetailMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *SetMealDetailMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearProductSpec clears the "product_spec" edge to the ProductSpec entity.
func (m *SetMealDetailMutation) ClearProductSpec() {
	m.clearedproduct_spec = true
	m.clearedFields[setmealdetail.FieldProductSpecID] = struct{}{}
}

// ProductSpecCleared reports if the "product_spec" edge to the ProductSpec entity was cleared.
func (m *SetMealDetailMutation) ProductSpecCleared() bool {
	return m.ProductSpecIDCleared() || m.clearedproduct_spec
}

// ProductSpecIDs returns the "product_spec" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductSpecID instead. It exists only for internal usage by the builders.
func (m *SetMealDetailMutation) ProductSpecIDs() (ids []int) {
	if id := m.product_spec; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductSpec resets all changes to the "product_spec" edge.
func (m *SetMealDetailMutation) ResetProductSpec() {
	m.product_spec = nil
	m.clearedproduct_spec = false
}

// Where appends a list predicates to the SetMealDetailMutation builder.
func (m *SetMealDetailMutation) Where(ps ...predicate.SetMealDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMealDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMealDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SetMealDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMealDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMealDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SetMealDetail).
func (m *SetMealDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMealDetailMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, setmealdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setmealdetail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, setmealdetail.FieldDeletedAt)
	}
	if m.price != nil {
		fields = append(fields, setmealdetail.FieldPrice)
	}
	if m.quantity != nil {
		fields = append(fields, setmealdetail.FieldQuantity)
	}
	if m.set_meal != nil {
		fields = append(fields, setmealdetail.FieldSetMealID)
	}
	if m.product != nil {
		fields = append(fields, setmealdetail.FieldProductID)
	}
	if m.product_spec != nil {
		fields = append(fields, setmealdetail.FieldProductSpecID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMealDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setmealdetail.FieldCreatedAt:
		return m.CreatedAt()
	case setmealdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case setmealdetail.FieldDeletedAt:
		return m.DeletedAt()
	case setmealdetail.FieldPrice:
		return m.Price()
	case setmealdetail.FieldQuantity:
		return m.Quantity()
	case setmealdetail.FieldSetMealID:
		return m.SetMealID()
	case setmealdetail.FieldProductID:
		return m.ProductID()
	case setmealdetail.FieldProductSpecID:
		return m.ProductSpecID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMealDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setmealdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setmealdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setmealdetail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setmealdetail.FieldPrice:
		return m.OldPrice(ctx)
	case setmealdetail.FieldQuantity:
		return m.OldQuantity(ctx)
	case setmealdetail.FieldSetMealID:
		return m.OldSetMealID(ctx)
	case setmealdetail.FieldProductID:
		return m.OldProductID(ctx)
	case setmealdetail.FieldProductSpecID:
		return m.OldProductSpecID(ctx)
	}
	return nil, fmt.Errorf("unknown SetMealDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMealDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setmealdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setmealdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setmealdetail.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setmealdetail.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case setmealdetail.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case setmealdetail.FieldSetMealID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetMealID(v)
		return nil
	case setmealdetail.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case setmealdetail.FieldProductSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductSpecID(v)
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMealDetailMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, setmealdetail.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMealDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case setmealdetail.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMealDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case setmealdetail.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMealDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setmealdetail.FieldProductSpecID) {
		fields = append(fields, setmealdetail.FieldProductSpecID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMealDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMealDetailMutation) ClearField(name string) error {
	switch name {
	case setmealdetail.FieldProductSpecID:
		m.ClearProductSpecID()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMealDetailMutation) ResetField(name string) error {
	switch name {
	case setmealdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setmealdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setmealdetail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setmealdetail.FieldPrice:
		m.ResetPrice()
		return nil
	case setmealdetail.FieldQuantity:
		m.ResetQuantity()
		return nil
	case setmealdetail.FieldSetMealID:
		m.ResetSetMealID()
		return nil
	case setmealdetail.FieldProductID:
		m.ResetProductID()
		return nil
	case setmealdetail.FieldProductSpecID:
		m.ResetProductSpecID()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMealDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.set_meal != nil {
		edges = append(edges, setmealdetail.EdgeSetMeal)
	}
	if m.product != nil {
		edges = append(edges, setmealdetail.EdgeProduct)
	}
	if m.product_spec != nil {
		edges = append(edges, setmealdetail.EdgeProductSpec)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMealDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case setmealdetail.EdgeSetMeal:
		if id := m.set_meal; id != nil {
			return []ent.Value{*id}
		}
	case setmealdetail.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case setmealdetail.EdgeProductSpec:
		if id := m.product_spec; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMealDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMealDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMealDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedset_meal {
		edges = append(edges, setmealdetail.EdgeSetMeal)
	}
	if m.clearedproduct {
		edges = append(edges, setmealdetail.EdgeProduct)
	}
	if m.clearedproduct_spec {
		edges = append(edges, setmealdetail.EdgeProductSpec)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMealDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case setmealdetail.EdgeSetMeal:
		return m.clearedset_meal
	case setmealdetail.EdgeProduct:
		return m.clearedproduct
	case setmealdetail.EdgeProductSpec:
		return m.clearedproduct_spec
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMealDetailMutation) ClearEdge(name string) error {
	switch name {
	case setmealdetail.EdgeSetMeal:
		m.ClearSetMeal()
		return nil
	case setmealdetail.EdgeProduct:
		m.ClearProduct()
		return nil
	case setmealdetail.EdgeProductSpec:
		m.ClearProductSpec()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMealDetailMutation) ResetEdge(name string) error {
	switch name {
	case setmealdetail.EdgeSetMeal:
		m.ResetSetMeal()
		return nil
	case setmealdetail.EdgeProduct:
		m.ResetProduct()
		return nil
	case setmealdetail.EdgeProductSpec:
		m.ResetProductSpec()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail edge %s", name)
}

// SpecMutation represents an operation that mutates the Spec nodes in the graph.
type SpecMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int64
	adddeleted_at        *int64
	name                 *string
	store_id             *int
	addstore_id          *int
	clearedFields        map[string]struct{}
	product_specs        map[int]struct{}
	removedproduct_specs map[int]struct{}
	clearedproduct_specs bool
	done                 bool
	oldValue             func(context.Context) (*Spec, error)
	predicates           []predicate.Spec
}

var _ ent.Mutation = (*SpecMutation)(nil)

// specOption allows management of the mutation configuration using functional options.
type specOption func(*SpecMutation)

// newSpecMutation creates new mutation for the Spec entity.
func newSpecMutation(c config, op Op, opts ...specOption) *SpecMutation {
	m := &SpecMutation{
		config:        c,
		op:            op,
		typ:           TypeSpec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecID sets the ID field of the mutation.
func withSpecID(id int) specOption {
	return func(m *SpecMutation) {
		var (
			err   error
			once  sync.Once
			value *Spec
		)
		m.oldValue = func(ctx context.Context) (*Spec, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpec sets the old Spec of the mutation.
func withSpec(node *Spec) specOption {
	return func(m *SpecMutation) {
		m.oldValue = func(context.Context) (*Spec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpecMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpecMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Spec.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SpecMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SpecMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Spec entity.
// If the Spec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SpecMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SpecMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SpecMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Spec entity.
// If the Spec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SpecMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SpecMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SpecMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Spec entity.
// If the Spec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SpecMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SpecMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SpecMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *SpecMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpecMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Spec entity.
// If the Spec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpecMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *SpecMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *SpecMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Spec entity.
// If the Spec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *SpecMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *SpecMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *SpecMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// AddProductSpecIDs adds the "product_specs" edge to the ProductSpec entity by ids.
func (m *SpecMutation) AddProductSpecIDs(ids ...int) {
	if m.product_specs == nil {
		m.product_specs = make(map[int]struct{})
	}
	for i := range ids {
		m.product_specs[ids[i]] = struct{}{}
	}
}

// ClearProductSpecs clears the "product_specs" edge to the ProductSpec entity.
func (m *SpecMutation) ClearProductSpecs() {
	m.clearedproduct_specs = true
}

// ProductSpecsCleared reports if the "product_specs" edge to the ProductSpec entity was cleared.
func (m *SpecMutation) ProductSpecsCleared() bool {
	return m.clearedproduct_specs
}

// RemoveProductSpecIDs removes the "product_specs" edge to the ProductSpec entity by IDs.
func (m *SpecMutation) RemoveProductSpecIDs(ids ...int) {
	if m.removedproduct_specs == nil {
		m.removedproduct_specs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_specs, ids[i])
		m.removedproduct_specs[ids[i]] = struct{}{}
	}
}

// RemovedProductSpecs returns the removed IDs of the "product_specs" edge to the ProductSpec entity.
func (m *SpecMutation) RemovedProductSpecsIDs() (ids []int) {
	for id := range m.removedproduct_specs {
		ids = append(ids, id)
	}
	return
}

// ProductSpecsIDs returns the "product_specs" edge IDs in the mutation.
func (m *SpecMutation) ProductSpecsIDs() (ids []int) {
	for id := range m.product_specs {
		ids = append(ids, id)
	}
	return
}

// ResetProductSpecs resets all changes to the "product_specs" edge.
func (m *SpecMutation) ResetProductSpecs() {
	m.product_specs = nil
	m.clearedproduct_specs = false
	m.removedproduct_specs = nil
}

// Where appends a list predicates to the SpecMutation builder.
func (m *SpecMutation) Where(ps ...predicate.Spec) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpecMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpecMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Spec, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpecMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpecMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Spec).
func (m *SpecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpecMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, spec.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, spec.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, spec.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, spec.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, spec.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spec.FieldCreatedAt:
		return m.CreatedAt()
	case spec.FieldUpdatedAt:
		return m.UpdatedAt()
	case spec.FieldDeletedAt:
		return m.DeletedAt()
	case spec.FieldName:
		return m.Name()
	case spec.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spec.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case spec.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case spec.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case spec.FieldName:
		return m.OldName(ctx)
	case spec.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Spec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spec.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case spec.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case spec.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case spec.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case spec.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Spec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpecMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, spec.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, spec.FieldStoreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spec.FieldDeletedAt:
		return m.AddedDeletedAt()
	case spec.FieldStoreID:
		return m.AddedStoreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spec.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case spec.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Spec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpecMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Spec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpecMutation) ResetField(name string) error {
	switch name {
	case spec.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case spec.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case spec.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case spec.FieldName:
		m.ResetName()
		return nil
	case spec.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Spec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpecMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_specs != nil {
		edges = append(edges, spec.EdgeProductSpecs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpecMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spec.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.product_specs))
		for id := range m.product_specs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct_specs != nil {
		edges = append(edges, spec.EdgeProductSpecs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpecMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spec.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.removedproduct_specs))
		for id := range m.removedproduct_specs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_specs {
		edges = append(edges, spec.EdgeProductSpecs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpecMutation) EdgeCleared(name string) bool {
	switch name {
	case spec.EdgeProductSpecs:
		return m.clearedproduct_specs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpecMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Spec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpecMutation) ResetEdge(name string) error {
	switch name {
	case spec.EdgeProductSpecs:
		m.ResetProductSpecs()
		return nil
	}
	return fmt.Errorf("unknown Spec edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *int64
	adddeleted_at                     *int64
	name                              *string
	_type                             *domain.StoreType
	cooperation_type                  *domain.StoreCooperationType
	need_audit                        *bool
	enabled                           *bool
	point_settlement_rate             *decimal.Decimal
	point_withdrawal_rate             *decimal.Decimal
	huifu_id                          *string
	zxh_id                            *string
	zxh_secret                        *string
	clearedFields                     map[string]struct{}
	backend_user                      *int
	clearedbackend_user               bool
	frontend_users                    map[int]struct{}
	removedfrontend_users             map[int]struct{}
	clearedfrontend_users             bool
	store_info                        *int
	clearedstore_info                 bool
	store_finance                     *int
	clearedstore_finance              bool
	store_account                     *int
	clearedstore_account              bool
	store_withdraws                   map[int]struct{}
	removedstore_withdraws            map[int]struct{}
	clearedstore_withdraws            bool
	store_account_transactions        map[int]struct{}
	removedstore_account_transactions map[int]struct{}
	clearedstore_account_transactions bool
	done                              bool
	oldValue                          func(context.Context) (*Store, error)
	predicates                        []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id int) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StoreMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StoreMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *StoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoreMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *StoreMutation) SetType(dt domain.StoreType) {
	m._type = &dt
}

// GetType returns the value of the "type" field in the mutation.
func (m *StoreMutation) GetType() (r domain.StoreType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldType(ctx context.Context) (v domain.StoreType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StoreMutation) ResetType() {
	m._type = nil
}

// SetCooperationType sets the "cooperation_type" field.
func (m *StoreMutation) SetCooperationType(dct domain.StoreCooperationType) {
	m.cooperation_type = &dct
}

// CooperationType returns the value of the "cooperation_type" field in the mutation.
func (m *StoreMutation) CooperationType() (r domain.StoreCooperationType, exists bool) {
	v := m.cooperation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCooperationType returns the old "cooperation_type" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCooperationType(ctx context.Context) (v domain.StoreCooperationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooperationType: %w", err)
	}
	return oldValue.CooperationType, nil
}

// ResetCooperationType resets all changes to the "cooperation_type" field.
func (m *StoreMutation) ResetCooperationType() {
	m.cooperation_type = nil
}

// SetNeedAudit sets the "need_audit" field.
func (m *StoreMutation) SetNeedAudit(b bool) {
	m.need_audit = &b
}

// NeedAudit returns the value of the "need_audit" field in the mutation.
func (m *StoreMutation) NeedAudit() (r bool, exists bool) {
	v := m.need_audit
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedAudit returns the old "need_audit" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldNeedAudit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedAudit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedAudit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedAudit: %w", err)
	}
	return oldValue.NeedAudit, nil
}

// ResetNeedAudit resets all changes to the "need_audit" field.
func (m *StoreMutation) ResetNeedAudit() {
	m.need_audit = nil
}

// SetEnabled sets the "enabled" field.
func (m *StoreMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *StoreMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *StoreMutation) ResetEnabled() {
	m.enabled = nil
}

// SetPointSettlementRate sets the "point_settlement_rate" field.
func (m *StoreMutation) SetPointSettlementRate(d decimal.Decimal) {
	m.point_settlement_rate = &d
}

// PointSettlementRate returns the value of the "point_settlement_rate" field in the mutation.
func (m *StoreMutation) PointSettlementRate() (r decimal.Decimal, exists bool) {
	v := m.point_settlement_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldPointSettlementRate returns the old "point_settlement_rate" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldPointSettlementRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointSettlementRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointSettlementRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointSettlementRate: %w", err)
	}
	return oldValue.PointSettlementRate, nil
}

// ResetPointSettlementRate resets all changes to the "point_settlement_rate" field.
func (m *StoreMutation) ResetPointSettlementRate() {
	m.point_settlement_rate = nil
}

// SetPointWithdrawalRate sets the "point_withdrawal_rate" field.
func (m *StoreMutation) SetPointWithdrawalRate(d decimal.Decimal) {
	m.point_withdrawal_rate = &d
}

// PointWithdrawalRate returns the value of the "point_withdrawal_rate" field in the mutation.
func (m *StoreMutation) PointWithdrawalRate() (r decimal.Decimal, exists bool) {
	v := m.point_withdrawal_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldPointWithdrawalRate returns the old "point_withdrawal_rate" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldPointWithdrawalRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointWithdrawalRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointWithdrawalRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointWithdrawalRate: %w", err)
	}
	return oldValue.PointWithdrawalRate, nil
}

// ResetPointWithdrawalRate resets all changes to the "point_withdrawal_rate" field.
func (m *StoreMutation) ResetPointWithdrawalRate() {
	m.point_withdrawal_rate = nil
}

// SetHuifuID sets the "huifu_id" field.
func (m *StoreMutation) SetHuifuID(s string) {
	m.huifu_id = &s
}

// HuifuID returns the value of the "huifu_id" field in the mutation.
func (m *StoreMutation) HuifuID() (r string, exists bool) {
	v := m.huifu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHuifuID returns the old "huifu_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldHuifuID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHuifuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHuifuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHuifuID: %w", err)
	}
	return oldValue.HuifuID, nil
}

// ResetHuifuID resets all changes to the "huifu_id" field.
func (m *StoreMutation) ResetHuifuID() {
	m.huifu_id = nil
}

// SetZxhID sets the "zxh_id" field.
func (m *StoreMutation) SetZxhID(s string) {
	m.zxh_id = &s
}

// ZxhID returns the value of the "zxh_id" field in the mutation.
func (m *StoreMutation) ZxhID() (r string, exists bool) {
	v := m.zxh_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZxhID returns the old "zxh_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldZxhID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZxhID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZxhID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZxhID: %w", err)
	}
	return oldValue.ZxhID, nil
}

// ResetZxhID resets all changes to the "zxh_id" field.
func (m *StoreMutation) ResetZxhID() {
	m.zxh_id = nil
}

// SetZxhSecret sets the "zxh_secret" field.
func (m *StoreMutation) SetZxhSecret(s string) {
	m.zxh_secret = &s
}

// ZxhSecret returns the value of the "zxh_secret" field in the mutation.
func (m *StoreMutation) ZxhSecret() (r string, exists bool) {
	v := m.zxh_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldZxhSecret returns the old "zxh_secret" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldZxhSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZxhSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZxhSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZxhSecret: %w", err)
	}
	return oldValue.ZxhSecret, nil
}

// ResetZxhSecret resets all changes to the "zxh_secret" field.
func (m *StoreMutation) ResetZxhSecret() {
	m.zxh_secret = nil
}

// SetBackendUserID sets the "backend_user" edge to the BackendUser entity by id.
func (m *StoreMutation) SetBackendUserID(id int) {
	m.backend_user = &id
}

// ClearBackendUser clears the "backend_user" edge to the BackendUser entity.
func (m *StoreMutation) ClearBackendUser() {
	m.clearedbackend_user = true
}

// BackendUserCleared reports if the "backend_user" edge to the BackendUser entity was cleared.
func (m *StoreMutation) BackendUserCleared() bool {
	return m.clearedbackend_user
}

// BackendUserID returns the "backend_user" edge ID in the mutation.
func (m *StoreMutation) BackendUserID() (id int, exists bool) {
	if m.backend_user != nil {
		return *m.backend_user, true
	}
	return
}

// BackendUserIDs returns the "backend_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackendUserID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) BackendUserIDs() (ids []int) {
	if id := m.backend_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackendUser resets all changes to the "backend_user" edge.
func (m *StoreMutation) ResetBackendUser() {
	m.backend_user = nil
	m.clearedbackend_user = false
}

// AddFrontendUserIDs adds the "frontend_users" edge to the FrontendUser entity by ids.
func (m *StoreMutation) AddFrontendUserIDs(ids ...int) {
	if m.frontend_users == nil {
		m.frontend_users = make(map[int]struct{})
	}
	for i := range ids {
		m.frontend_users[ids[i]] = struct{}{}
	}
}

// ClearFrontendUsers clears the "frontend_users" edge to the FrontendUser entity.
func (m *StoreMutation) ClearFrontendUsers() {
	m.clearedfrontend_users = true
}

// FrontendUsersCleared reports if the "frontend_users" edge to the FrontendUser entity was cleared.
func (m *StoreMutation) FrontendUsersCleared() bool {
	return m.clearedfrontend_users
}

// RemoveFrontendUserIDs removes the "frontend_users" edge to the FrontendUser entity by IDs.
func (m *StoreMutation) RemoveFrontendUserIDs(ids ...int) {
	if m.removedfrontend_users == nil {
		m.removedfrontend_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.frontend_users, ids[i])
		m.removedfrontend_users[ids[i]] = struct{}{}
	}
}

// RemovedFrontendUsers returns the removed IDs of the "frontend_users" edge to the FrontendUser entity.
func (m *StoreMutation) RemovedFrontendUsersIDs() (ids []int) {
	for id := range m.removedfrontend_users {
		ids = append(ids, id)
	}
	return
}

// FrontendUsersIDs returns the "frontend_users" edge IDs in the mutation.
func (m *StoreMutation) FrontendUsersIDs() (ids []int) {
	for id := range m.frontend_users {
		ids = append(ids, id)
	}
	return
}

// ResetFrontendUsers resets all changes to the "frontend_users" edge.
func (m *StoreMutation) ResetFrontendUsers() {
	m.frontend_users = nil
	m.clearedfrontend_users = false
	m.removedfrontend_users = nil
}

// SetStoreInfoID sets the "store_info" edge to the StoreInfo entity by id.
func (m *StoreMutation) SetStoreInfoID(id int) {
	m.store_info = &id
}

// ClearStoreInfo clears the "store_info" edge to the StoreInfo entity.
func (m *StoreMutation) ClearStoreInfo() {
	m.clearedstore_info = true
}

// StoreInfoCleared reports if the "store_info" edge to the StoreInfo entity was cleared.
func (m *StoreMutation) StoreInfoCleared() bool {
	return m.clearedstore_info
}

// StoreInfoID returns the "store_info" edge ID in the mutation.
func (m *StoreMutation) StoreInfoID() (id int, exists bool) {
	if m.store_info != nil {
		return *m.store_info, true
	}
	return
}

// StoreInfoIDs returns the "store_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreInfoID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) StoreInfoIDs() (ids []int) {
	if id := m.store_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoreInfo resets all changes to the "store_info" edge.
func (m *StoreMutation) ResetStoreInfo() {
	m.store_info = nil
	m.clearedstore_info = false
}

// SetStoreFinanceID sets the "store_finance" edge to the StoreFinance entity by id.
func (m *StoreMutation) SetStoreFinanceID(id int) {
	m.store_finance = &id
}

// ClearStoreFinance clears the "store_finance" edge to the StoreFinance entity.
func (m *StoreMutation) ClearStoreFinance() {
	m.clearedstore_finance = true
}

// StoreFinanceCleared reports if the "store_finance" edge to the StoreFinance entity was cleared.
func (m *StoreMutation) StoreFinanceCleared() bool {
	return m.clearedstore_finance
}

// StoreFinanceID returns the "store_finance" edge ID in the mutation.
func (m *StoreMutation) StoreFinanceID() (id int, exists bool) {
	if m.store_finance != nil {
		return *m.store_finance, true
	}
	return
}

// StoreFinanceIDs returns the "store_finance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreFinanceID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) StoreFinanceIDs() (ids []int) {
	if id := m.store_finance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoreFinance resets all changes to the "store_finance" edge.
func (m *StoreMutation) ResetStoreFinance() {
	m.store_finance = nil
	m.clearedstore_finance = false
}

// SetStoreAccountID sets the "store_account" edge to the StoreAccount entity by id.
func (m *StoreMutation) SetStoreAccountID(id int) {
	m.store_account = &id
}

// ClearStoreAccount clears the "store_account" edge to the StoreAccount entity.
func (m *StoreMutation) ClearStoreAccount() {
	m.clearedstore_account = true
}

// StoreAccountCleared reports if the "store_account" edge to the StoreAccount entity was cleared.
func (m *StoreMutation) StoreAccountCleared() bool {
	return m.clearedstore_account
}

// StoreAccountID returns the "store_account" edge ID in the mutation.
func (m *StoreMutation) StoreAccountID() (id int, exists bool) {
	if m.store_account != nil {
		return *m.store_account, true
	}
	return
}

// StoreAccountIDs returns the "store_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreAccountID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) StoreAccountIDs() (ids []int) {
	if id := m.store_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoreAccount resets all changes to the "store_account" edge.
func (m *StoreMutation) ResetStoreAccount() {
	m.store_account = nil
	m.clearedstore_account = false
}

// AddStoreWithdrawIDs adds the "store_withdraws" edge to the StoreWithdraw entity by ids.
func (m *StoreMutation) AddStoreWithdrawIDs(ids ...int) {
	if m.store_withdraws == nil {
		m.store_withdraws = make(map[int]struct{})
	}
	for i := range ids {
		m.store_withdraws[ids[i]] = struct{}{}
	}
}

// ClearStoreWithdraws clears the "store_withdraws" edge to the StoreWithdraw entity.
func (m *StoreMutation) ClearStoreWithdraws() {
	m.clearedstore_withdraws = true
}

// StoreWithdrawsCleared reports if the "store_withdraws" edge to the StoreWithdraw entity was cleared.
func (m *StoreMutation) StoreWithdrawsCleared() bool {
	return m.clearedstore_withdraws
}

// RemoveStoreWithdrawIDs removes the "store_withdraws" edge to the StoreWithdraw entity by IDs.
func (m *StoreMutation) RemoveStoreWithdrawIDs(ids ...int) {
	if m.removedstore_withdraws == nil {
		m.removedstore_withdraws = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.store_withdraws, ids[i])
		m.removedstore_withdraws[ids[i]] = struct{}{}
	}
}

// RemovedStoreWithdraws returns the removed IDs of the "store_withdraws" edge to the StoreWithdraw entity.
func (m *StoreMutation) RemovedStoreWithdrawsIDs() (ids []int) {
	for id := range m.removedstore_withdraws {
		ids = append(ids, id)
	}
	return
}

// StoreWithdrawsIDs returns the "store_withdraws" edge IDs in the mutation.
func (m *StoreMutation) StoreWithdrawsIDs() (ids []int) {
	for id := range m.store_withdraws {
		ids = append(ids, id)
	}
	return
}

// ResetStoreWithdraws resets all changes to the "store_withdraws" edge.
func (m *StoreMutation) ResetStoreWithdraws() {
	m.store_withdraws = nil
	m.clearedstore_withdraws = false
	m.removedstore_withdraws = nil
}

// AddStoreAccountTransactionIDs adds the "store_account_transactions" edge to the StoreAccountTransaction entity by ids.
func (m *StoreMutation) AddStoreAccountTransactionIDs(ids ...int) {
	if m.store_account_transactions == nil {
		m.store_account_transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.store_account_transactions[ids[i]] = struct{}{}
	}
}

// ClearStoreAccountTransactions clears the "store_account_transactions" edge to the StoreAccountTransaction entity.
func (m *StoreMutation) ClearStoreAccountTransactions() {
	m.clearedstore_account_transactions = true
}

// StoreAccountTransactionsCleared reports if the "store_account_transactions" edge to the StoreAccountTransaction entity was cleared.
func (m *StoreMutation) StoreAccountTransactionsCleared() bool {
	return m.clearedstore_account_transactions
}

// RemoveStoreAccountTransactionIDs removes the "store_account_transactions" edge to the StoreAccountTransaction entity by IDs.
func (m *StoreMutation) RemoveStoreAccountTransactionIDs(ids ...int) {
	if m.removedstore_account_transactions == nil {
		m.removedstore_account_transactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.store_account_transactions, ids[i])
		m.removedstore_account_transactions[ids[i]] = struct{}{}
	}
}

// RemovedStoreAccountTransactions returns the removed IDs of the "store_account_transactions" edge to the StoreAccountTransaction entity.
func (m *StoreMutation) RemovedStoreAccountTransactionsIDs() (ids []int) {
	for id := range m.removedstore_account_transactions {
		ids = append(ids, id)
	}
	return
}

// StoreAccountTransactionsIDs returns the "store_account_transactions" edge IDs in the mutation.
func (m *StoreMutation) StoreAccountTransactionsIDs() (ids []int) {
	for id := range m.store_account_transactions {
		ids = append(ids, id)
	}
	return
}

// ResetStoreAccountTransactions resets all changes to the "store_account_transactions" edge.
func (m *StoreMutation) ResetStoreAccountTransactions() {
	m.store_account_transactions = nil
	m.clearedstore_account_transactions = false
	m.removedstore_account_transactions = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Store, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, store.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, store.FieldName)
	}
	if m._type != nil {
		fields = append(fields, store.FieldType)
	}
	if m.cooperation_type != nil {
		fields = append(fields, store.FieldCooperationType)
	}
	if m.need_audit != nil {
		fields = append(fields, store.FieldNeedAudit)
	}
	if m.enabled != nil {
		fields = append(fields, store.FieldEnabled)
	}
	if m.point_settlement_rate != nil {
		fields = append(fields, store.FieldPointSettlementRate)
	}
	if m.point_withdrawal_rate != nil {
		fields = append(fields, store.FieldPointWithdrawalRate)
	}
	if m.huifu_id != nil {
		fields = append(fields, store.FieldHuifuID)
	}
	if m.zxh_id != nil {
		fields = append(fields, store.FieldZxhID)
	}
	if m.zxh_secret != nil {
		fields = append(fields, store.FieldZxhSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldCreatedAt:
		return m.CreatedAt()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	case store.FieldDeletedAt:
		return m.DeletedAt()
	case store.FieldName:
		return m.Name()
	case store.FieldType:
		return m.GetType()
	case store.FieldCooperationType:
		return m.CooperationType()
	case store.FieldNeedAudit:
		return m.NeedAudit()
	case store.FieldEnabled:
		return m.Enabled()
	case store.FieldPointSettlementRate:
		return m.PointSettlementRate()
	case store.FieldPointWithdrawalRate:
		return m.PointWithdrawalRate()
	case store.FieldHuifuID:
		return m.HuifuID()
	case store.FieldZxhID:
		return m.ZxhID()
	case store.FieldZxhSecret:
		return m.ZxhSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case store.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case store.FieldName:
		return m.OldName(ctx)
	case store.FieldType:
		return m.OldType(ctx)
	case store.FieldCooperationType:
		return m.OldCooperationType(ctx)
	case store.FieldNeedAudit:
		return m.OldNeedAudit(ctx)
	case store.FieldEnabled:
		return m.OldEnabled(ctx)
	case store.FieldPointSettlementRate:
		return m.OldPointSettlementRate(ctx)
	case store.FieldPointWithdrawalRate:
		return m.OldPointWithdrawalRate(ctx)
	case store.FieldHuifuID:
		return m.OldHuifuID(ctx)
	case store.FieldZxhID:
		return m.OldZxhID(ctx)
	case store.FieldZxhSecret:
		return m.OldZxhSecret(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case store.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case store.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case store.FieldType:
		v, ok := value.(domain.StoreType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case store.FieldCooperationType:
		v, ok := value.(domain.StoreCooperationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooperationType(v)
		return nil
	case store.FieldNeedAudit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedAudit(v)
		return nil
	case store.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case store.FieldPointSettlementRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointSettlementRate(v)
		return nil
	case store.FieldPointWithdrawalRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointWithdrawalRate(v)
		return nil
	case store.FieldHuifuID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHuifuID(v)
		return nil
	case store.FieldZxhID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZxhID(v)
		return nil
	case store.FieldZxhSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZxhSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case store.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case store.FieldName:
		m.ResetName()
		return nil
	case store.FieldType:
		m.ResetType()
		return nil
	case store.FieldCooperationType:
		m.ResetCooperationType()
		return nil
	case store.FieldNeedAudit:
		m.ResetNeedAudit()
		return nil
	case store.FieldEnabled:
		m.ResetEnabled()
		return nil
	case store.FieldPointSettlementRate:
		m.ResetPointSettlementRate()
		return nil
	case store.FieldPointWithdrawalRate:
		m.ResetPointWithdrawalRate()
		return nil
	case store.FieldHuifuID:
		m.ResetHuifuID()
		return nil
	case store.FieldZxhID:
		m.ResetZxhID()
		return nil
	case store.FieldZxhSecret:
		m.ResetZxhSecret()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.backend_user != nil {
		edges = append(edges, store.EdgeBackendUser)
	}
	if m.frontend_users != nil {
		edges = append(edges, store.EdgeFrontendUsers)
	}
	if m.store_info != nil {
		edges = append(edges, store.EdgeStoreInfo)
	}
	if m.store_finance != nil {
		edges = append(edges, store.EdgeStoreFinance)
	}
	if m.store_account != nil {
		edges = append(edges, store.EdgeStoreAccount)
	}
	if m.store_withdraws != nil {
		edges = append(edges, store.EdgeStoreWithdraws)
	}
	if m.store_account_transactions != nil {
		edges = append(edges, store.EdgeStoreAccountTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeBackendUser:
		if id := m.backend_user; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeFrontendUsers:
		ids := make([]ent.Value, 0, len(m.frontend_users))
		for id := range m.frontend_users {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeStoreInfo:
		if id := m.store_info; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeStoreFinance:
		if id := m.store_finance; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeStoreAccount:
		if id := m.store_account; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeStoreWithdraws:
		ids := make([]ent.Value, 0, len(m.store_withdraws))
		for id := range m.store_withdraws {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeStoreAccountTransactions:
		ids := make([]ent.Value, 0, len(m.store_account_transactions))
		for id := range m.store_account_transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedfrontend_users != nil {
		edges = append(edges, store.EdgeFrontendUsers)
	}
	if m.removedstore_withdraws != nil {
		edges = append(edges, store.EdgeStoreWithdraws)
	}
	if m.removedstore_account_transactions != nil {
		edges = append(edges, store.EdgeStoreAccountTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeFrontendUsers:
		ids := make([]ent.Value, 0, len(m.removedfrontend_users))
		for id := range m.removedfrontend_users {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeStoreWithdraws:
		ids := make([]ent.Value, 0, len(m.removedstore_withdraws))
		for id := range m.removedstore_withdraws {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeStoreAccountTransactions:
		ids := make([]ent.Value, 0, len(m.removedstore_account_transactions))
		for id := range m.removedstore_account_transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedbackend_user {
		edges = append(edges, store.EdgeBackendUser)
	}
	if m.clearedfrontend_users {
		edges = append(edges, store.EdgeFrontendUsers)
	}
	if m.clearedstore_info {
		edges = append(edges, store.EdgeStoreInfo)
	}
	if m.clearedstore_finance {
		edges = append(edges, store.EdgeStoreFinance)
	}
	if m.clearedstore_account {
		edges = append(edges, store.EdgeStoreAccount)
	}
	if m.clearedstore_withdraws {
		edges = append(edges, store.EdgeStoreWithdraws)
	}
	if m.clearedstore_account_transactions {
		edges = append(edges, store.EdgeStoreAccountTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeBackendUser:
		return m.clearedbackend_user
	case store.EdgeFrontendUsers:
		return m.clearedfrontend_users
	case store.EdgeStoreInfo:
		return m.clearedstore_info
	case store.EdgeStoreFinance:
		return m.clearedstore_finance
	case store.EdgeStoreAccount:
		return m.clearedstore_account
	case store.EdgeStoreWithdraws:
		return m.clearedstore_withdraws
	case store.EdgeStoreAccountTransactions:
		return m.clearedstore_account_transactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	case store.EdgeBackendUser:
		m.ClearBackendUser()
		return nil
	case store.EdgeStoreInfo:
		m.ClearStoreInfo()
		return nil
	case store.EdgeStoreFinance:
		m.ClearStoreFinance()
		return nil
	case store.EdgeStoreAccount:
		m.ClearStoreAccount()
		return nil
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeBackendUser:
		m.ResetBackendUser()
		return nil
	case store.EdgeFrontendUsers:
		m.ResetFrontendUsers()
		return nil
	case store.EdgeStoreInfo:
		m.ResetStoreInfo()
		return nil
	case store.EdgeStoreFinance:
		m.ResetStoreFinance()
		return nil
	case store.EdgeStoreAccount:
		m.ResetStoreAccount()
		return nil
	case store.EdgeStoreWithdraws:
		m.ResetStoreWithdraws()
		return nil
	case store.EdgeStoreAccountTransactions:
		m.ResetStoreAccountTransactions()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}

// StoreAccountMutation represents an operation that mutates the StoreAccount nodes in the graph.
type StoreAccountMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	balance          *decimal.Decimal
	pending_withdraw *decimal.Decimal
	withdrawn        *decimal.Decimal
	total_amount     *decimal.Decimal
	clearedFields    map[string]struct{}
	store            *int
	clearedstore     bool
	done             bool
	oldValue         func(context.Context) (*StoreAccount, error)
	predicates       []predicate.StoreAccount
}

var _ ent.Mutation = (*StoreAccountMutation)(nil)

// storeaccountOption allows management of the mutation configuration using functional options.
type storeaccountOption func(*StoreAccountMutation)

// newStoreAccountMutation creates new mutation for the StoreAccount entity.
func newStoreAccountMutation(c config, op Op, opts ...storeaccountOption) *StoreAccountMutation {
	m := &StoreAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreAccountID sets the ID field of the mutation.
func withStoreAccountID(id int) storeaccountOption {
	return func(m *StoreAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreAccount
		)
		m.oldValue = func(ctx context.Context) (*StoreAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreAccount sets the old StoreAccount of the mutation.
func withStoreAccount(node *StoreAccount) storeaccountOption {
	return func(m *StoreAccountMutation) {
		m.oldValue = func(context.Context) (*StoreAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreAccountMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreAccountMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StoreAccountMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StoreAccountMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetStoreID sets the "store_id" field.
func (m *StoreAccountMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StoreAccountMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StoreAccountMutation) ResetStoreID() {
	m.store = nil
}

// SetBalance sets the "balance" field.
func (m *StoreAccountMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
}

// Balance returns the value of the "balance" field in the mutation.
func (m *StoreAccountMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// ResetBalance resets all changes to the "balance" field.
func (m *StoreAccountMutation) ResetBalance() {
	m.balance = nil
}

// SetPendingWithdraw sets the "pending_withdraw" field.
func (m *StoreAccountMutation) SetPendingWithdraw(d decimal.Decimal) {
	m.pending_withdraw = &d
}

// PendingWithdraw returns the value of the "pending_withdraw" field in the mutation.
func (m *StoreAccountMutation) PendingWithdraw() (r decimal.Decimal, exists bool) {
	v := m.pending_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingWithdraw returns the old "pending_withdraw" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldPendingWithdraw(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingWithdraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingWithdraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingWithdraw: %w", err)
	}
	return oldValue.PendingWithdraw, nil
}

// ResetPendingWithdraw resets all changes to the "pending_withdraw" field.
func (m *StoreAccountMutation) ResetPendingWithdraw() {
	m.pending_withdraw = nil
}

// SetWithdrawn sets the "withdrawn" field.
func (m *StoreAccountMutation) SetWithdrawn(d decimal.Decimal) {
	m.withdrawn = &d
}

// Withdrawn returns the value of the "withdrawn" field in the mutation.
func (m *StoreAccountMutation) Withdrawn() (r decimal.Decimal, exists bool) {
	v := m.withdrawn
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawn returns the old "withdrawn" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldWithdrawn(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawn: %w", err)
	}
	return oldValue.Withdrawn, nil
}

// ResetWithdrawn resets all changes to the "withdrawn" field.
func (m *StoreAccountMutation) ResetWithdrawn() {
	m.withdrawn = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *StoreAccountMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *StoreAccountMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the StoreAccount entity.
// If the StoreAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *StoreAccountMutation) ResetTotalAmount() {
	m.total_amount = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StoreAccountMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[storeaccount.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StoreAccountMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StoreAccountMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StoreAccountMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the StoreAccountMutation builder.
func (m *StoreAccountMutation) Where(ps ...predicate.StoreAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreAccount).
func (m *StoreAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, storeaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storeaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storeaccount.FieldDeletedAt)
	}
	if m.store != nil {
		fields = append(fields, storeaccount.FieldStoreID)
	}
	if m.balance != nil {
		fields = append(fields, storeaccount.FieldBalance)
	}
	if m.pending_withdraw != nil {
		fields = append(fields, storeaccount.FieldPendingWithdraw)
	}
	if m.withdrawn != nil {
		fields = append(fields, storeaccount.FieldWithdrawn)
	}
	if m.total_amount != nil {
		fields = append(fields, storeaccount.FieldTotalAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storeaccount.FieldCreatedAt:
		return m.CreatedAt()
	case storeaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case storeaccount.FieldDeletedAt:
		return m.DeletedAt()
	case storeaccount.FieldStoreID:
		return m.StoreID()
	case storeaccount.FieldBalance:
		return m.Balance()
	case storeaccount.FieldPendingWithdraw:
		return m.PendingWithdraw()
	case storeaccount.FieldWithdrawn:
		return m.Withdrawn()
	case storeaccount.FieldTotalAmount:
		return m.TotalAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storeaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storeaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storeaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storeaccount.FieldStoreID:
		return m.OldStoreID(ctx)
	case storeaccount.FieldBalance:
		return m.OldBalance(ctx)
	case storeaccount.FieldPendingWithdraw:
		return m.OldPendingWithdraw(ctx)
	case storeaccount.FieldWithdrawn:
		return m.OldWithdrawn(ctx)
	case storeaccount.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	}
	return nil, fmt.Errorf("unknown StoreAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storeaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storeaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storeaccount.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storeaccount.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case storeaccount.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case storeaccount.FieldPendingWithdraw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingWithdraw(v)
		return nil
	case storeaccount.FieldWithdrawn:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawn(v)
		return nil
	case storeaccount.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown StoreAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreAccountMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, storeaccount.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storeaccount.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storeaccount.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StoreAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StoreAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreAccountMutation) ResetField(name string) error {
	switch name {
	case storeaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storeaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storeaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storeaccount.FieldStoreID:
		m.ResetStoreID()
		return nil
	case storeaccount.FieldBalance:
		m.ResetBalance()
		return nil
	case storeaccount.FieldPendingWithdraw:
		m.ResetPendingWithdraw()
		return nil
	case storeaccount.FieldWithdrawn:
		m.ResetWithdrawn()
		return nil
	case storeaccount.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	}
	return fmt.Errorf("unknown StoreAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, storeaccount.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storeaccount.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, storeaccount.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case storeaccount.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreAccountMutation) ClearEdge(name string) error {
	switch name {
	case storeaccount.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown StoreAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreAccountMutation) ResetEdge(name string) error {
	switch name {
	case storeaccount.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown StoreAccount edge %s", name)
}

// StoreAccountTransactionMutation represents an operation that mutates the StoreAccountTransaction nodes in the graph.
type StoreAccountTransactionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int64
	adddeleted_at *int64
	no            *string
	amount        *decimal.Decimal
	after         *decimal.Decimal
	_type         *domain.TransactionType
	add_type      *domain.TransactionType
	clearedFields map[string]struct{}
	store         *int
	clearedstore  bool
	done          bool
	oldValue      func(context.Context) (*StoreAccountTransaction, error)
	predicates    []predicate.StoreAccountTransaction
}

var _ ent.Mutation = (*StoreAccountTransactionMutation)(nil)

// storeaccounttransactionOption allows management of the mutation configuration using functional options.
type storeaccounttransactionOption func(*StoreAccountTransactionMutation)

// newStoreAccountTransactionMutation creates new mutation for the StoreAccountTransaction entity.
func newStoreAccountTransactionMutation(c config, op Op, opts ...storeaccounttransactionOption) *StoreAccountTransactionMutation {
	m := &StoreAccountTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreAccountTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreAccountTransactionID sets the ID field of the mutation.
func withStoreAccountTransactionID(id int) storeaccounttransactionOption {
	return func(m *StoreAccountTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreAccountTransaction
		)
		m.oldValue = func(ctx context.Context) (*StoreAccountTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreAccountTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreAccountTransaction sets the old StoreAccountTransaction of the mutation.
func withStoreAccountTransaction(node *StoreAccountTransaction) storeaccounttransactionOption {
	return func(m *StoreAccountTransactionMutation) {
		m.oldValue = func(context.Context) (*StoreAccountTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreAccountTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreAccountTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreAccountTransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreAccountTransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreAccountTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreAccountTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreAccountTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreAccountTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreAccountTransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreAccountTransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreAccountTransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreAccountTransactionMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreAccountTransactionMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StoreAccountTransactionMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StoreAccountTransactionMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreAccountTransactionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetStoreID sets the "store_id" field.
func (m *StoreAccountTransactionMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StoreAccountTransactionMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StoreAccountTransactionMutation) ResetStoreID() {
	m.store = nil
}

// SetNo sets the "no" field.
func (m *StoreAccountTransactionMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *StoreAccountTransactionMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *StoreAccountTransactionMutation) ResetNo() {
	m.no = nil
}

// SetAmount sets the "amount" field.
func (m *StoreAccountTransactionMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *StoreAccountTransactionMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *StoreAccountTransactionMutation) ResetAmount() {
	m.amount = nil
}

// SetAfter sets the "after" field.
func (m *StoreAccountTransactionMutation) SetAfter(d decimal.Decimal) {
	m.after = &d
}

// After returns the value of the "after" field in the mutation.
func (m *StoreAccountTransactionMutation) After() (r decimal.Decimal, exists bool) {
	v := m.after
	if v == nil {
		return
	}
	return *v, true
}

// OldAfter returns the old "after" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldAfter(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfter: %w", err)
	}
	return oldValue.After, nil
}

// ResetAfter resets all changes to the "after" field.
func (m *StoreAccountTransactionMutation) ResetAfter() {
	m.after = nil
}

// SetType sets the "type" field.
func (m *StoreAccountTransactionMutation) SetType(dt domain.TransactionType) {
	m._type = &dt
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *StoreAccountTransactionMutation) GetType() (r domain.TransactionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the StoreAccountTransaction entity.
// If the StoreAccountTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAccountTransactionMutation) OldType(ctx context.Context) (v domain.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds dt to the "type" field.
func (m *StoreAccountTransactionMutation) AddType(dt domain.TransactionType) {
	if m.add_type != nil {
		*m.add_type += dt
	} else {
		m.add_type = &dt
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *StoreAccountTransactionMutation) AddedType() (r domain.TransactionType, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *StoreAccountTransactionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StoreAccountTransactionMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[storeaccounttransaction.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StoreAccountTransactionMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StoreAccountTransactionMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StoreAccountTransactionMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the StoreAccountTransactionMutation builder.
func (m *StoreAccountTransactionMutation) Where(ps ...predicate.StoreAccountTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreAccountTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreAccountTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreAccountTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreAccountTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreAccountTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreAccountTransaction).
func (m *StoreAccountTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreAccountTransactionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, storeaccounttransaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storeaccounttransaction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storeaccounttransaction.FieldDeletedAt)
	}
	if m.store != nil {
		fields = append(fields, storeaccounttransaction.FieldStoreID)
	}
	if m.no != nil {
		fields = append(fields, storeaccounttransaction.FieldNo)
	}
	if m.amount != nil {
		fields = append(fields, storeaccounttransaction.FieldAmount)
	}
	if m.after != nil {
		fields = append(fields, storeaccounttransaction.FieldAfter)
	}
	if m._type != nil {
		fields = append(fields, storeaccounttransaction.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreAccountTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storeaccounttransaction.FieldCreatedAt:
		return m.CreatedAt()
	case storeaccounttransaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case storeaccounttransaction.FieldDeletedAt:
		return m.DeletedAt()
	case storeaccounttransaction.FieldStoreID:
		return m.StoreID()
	case storeaccounttransaction.FieldNo:
		return m.No()
	case storeaccounttransaction.FieldAmount:
		return m.Amount()
	case storeaccounttransaction.FieldAfter:
		return m.After()
	case storeaccounttransaction.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreAccountTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storeaccounttransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storeaccounttransaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storeaccounttransaction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storeaccounttransaction.FieldStoreID:
		return m.OldStoreID(ctx)
	case storeaccounttransaction.FieldNo:
		return m.OldNo(ctx)
	case storeaccounttransaction.FieldAmount:
		return m.OldAmount(ctx)
	case storeaccounttransaction.FieldAfter:
		return m.OldAfter(ctx)
	case storeaccounttransaction.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown StoreAccountTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAccountTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storeaccounttransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storeaccounttransaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storeaccounttransaction.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storeaccounttransaction.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case storeaccounttransaction.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case storeaccounttransaction.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case storeaccounttransaction.FieldAfter:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfter(v)
		return nil
	case storeaccounttransaction.FieldType:
		v, ok := value.(domain.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown StoreAccountTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreAccountTransactionMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, storeaccounttransaction.FieldDeletedAt)
	}
	if m.add_type != nil {
		fields = append(fields, storeaccounttransaction.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreAccountTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storeaccounttransaction.FieldDeletedAt:
		return m.AddedDeletedAt()
	case storeaccounttransaction.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAccountTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storeaccounttransaction.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case storeaccounttransaction.FieldType:
		v, ok := value.(domain.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown StoreAccountTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreAccountTransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreAccountTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreAccountTransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StoreAccountTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreAccountTransactionMutation) ResetField(name string) error {
	switch name {
	case storeaccounttransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storeaccounttransaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storeaccounttransaction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storeaccounttransaction.FieldStoreID:
		m.ResetStoreID()
		return nil
	case storeaccounttransaction.FieldNo:
		m.ResetNo()
		return nil
	case storeaccounttransaction.FieldAmount:
		m.ResetAmount()
		return nil
	case storeaccounttransaction.FieldAfter:
		m.ResetAfter()
		return nil
	case storeaccounttransaction.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown StoreAccountTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreAccountTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, storeaccounttransaction.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreAccountTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storeaccounttransaction.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreAccountTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreAccountTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreAccountTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, storeaccounttransaction.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreAccountTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case storeaccounttransaction.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreAccountTransactionMutation) ClearEdge(name string) error {
	switch name {
	case storeaccounttransaction.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown StoreAccountTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreAccountTransactionMutation) ResetEdge(name string) error {
	switch name {
	case storeaccounttransaction.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown StoreAccountTransaction edge %s", name)
}

// StoreFinanceMutation represents an operation that mutates the StoreFinance nodes in the graph.
type StoreFinanceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	bank_account       *string
	bank_card_name     *string
	bank_name          *string
	branch_name        *string
	public_account     *string
	company_name       *string
	public_bank_name   *string
	public_branch_name *string
	credit_code        *string
	clearedFields      map[string]struct{}
	store              *int
	clearedstore       bool
	done               bool
	oldValue           func(context.Context) (*StoreFinance, error)
	predicates         []predicate.StoreFinance
}

var _ ent.Mutation = (*StoreFinanceMutation)(nil)

// storefinanceOption allows management of the mutation configuration using functional options.
type storefinanceOption func(*StoreFinanceMutation)

// newStoreFinanceMutation creates new mutation for the StoreFinance entity.
func newStoreFinanceMutation(c config, op Op, opts ...storefinanceOption) *StoreFinanceMutation {
	m := &StoreFinanceMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreFinance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreFinanceID sets the ID field of the mutation.
func withStoreFinanceID(id int) storefinanceOption {
	return func(m *StoreFinanceMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreFinance
		)
		m.oldValue = func(ctx context.Context) (*StoreFinance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreFinance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreFinance sets the old StoreFinance of the mutation.
func withStoreFinance(node *StoreFinance) storefinanceOption {
	return func(m *StoreFinanceMutation) {
		m.oldValue = func(context.Context) (*StoreFinance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreFinanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreFinanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreFinanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreFinanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreFinance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBankAccount sets the "bank_account" field.
func (m *StoreFinanceMutation) SetBankAccount(s string) {
	m.bank_account = &s
}

// BankAccount returns the value of the "bank_account" field in the mutation.
func (m *StoreFinanceMutation) BankAccount() (r string, exists bool) {
	v := m.bank_account
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccount returns the old "bank_account" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldBankAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccount: %w", err)
	}
	return oldValue.BankAccount, nil
}

// ClearBankAccount clears the value of the "bank_account" field.
func (m *StoreFinanceMutation) ClearBankAccount() {
	m.bank_account = nil
	m.clearedFields[storefinance.FieldBankAccount] = struct{}{}
}

// BankAccountCleared returns if the "bank_account" field was cleared in this mutation.
func (m *StoreFinanceMutation) BankAccountCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldBankAccount]
	return ok
}

// ResetBankAccount resets all changes to the "bank_account" field.
func (m *StoreFinanceMutation) ResetBankAccount() {
	m.bank_account = nil
	delete(m.clearedFields, storefinance.FieldBankAccount)
}

// SetBankCardName sets the "bank_card_name" field.
func (m *StoreFinanceMutation) SetBankCardName(s string) {
	m.bank_card_name = &s
}

// BankCardName returns the value of the "bank_card_name" field in the mutation.
func (m *StoreFinanceMutation) BankCardName() (r string, exists bool) {
	v := m.bank_card_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCardName returns the old "bank_card_name" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldBankCardName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankCardName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankCardName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCardName: %w", err)
	}
	return oldValue.BankCardName, nil
}

// ClearBankCardName clears the value of the "bank_card_name" field.
func (m *StoreFinanceMutation) ClearBankCardName() {
	m.bank_card_name = nil
	m.clearedFields[storefinance.FieldBankCardName] = struct{}{}
}

// BankCardNameCleared returns if the "bank_card_name" field was cleared in this mutation.
func (m *StoreFinanceMutation) BankCardNameCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldBankCardName]
	return ok
}

// ResetBankCardName resets all changes to the "bank_card_name" field.
func (m *StoreFinanceMutation) ResetBankCardName() {
	m.bank_card_name = nil
	delete(m.clearedFields, storefinance.FieldBankCardName)
}

// SetBankName sets the "bank_name" field.
func (m *StoreFinanceMutation) SetBankName(s string) {
	m.bank_name = &s
}

// BankName returns the value of the "bank_name" field in the mutation.
func (m *StoreFinanceMutation) BankName() (r string, exists bool) {
	v := m.bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bank_name" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldBankName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// ClearBankName clears the value of the "bank_name" field.
func (m *StoreFinanceMutation) ClearBankName() {
	m.bank_name = nil
	m.clearedFields[storefinance.FieldBankName] = struct{}{}
}

// BankNameCleared returns if the "bank_name" field was cleared in this mutation.
func (m *StoreFinanceMutation) BankNameCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldBankName]
	return ok
}

// ResetBankName resets all changes to the "bank_name" field.
func (m *StoreFinanceMutation) ResetBankName() {
	m.bank_name = nil
	delete(m.clearedFields, storefinance.FieldBankName)
}

// SetBranchName sets the "branch_name" field.
func (m *StoreFinanceMutation) SetBranchName(s string) {
	m.branch_name = &s
}

// BranchName returns the value of the "branch_name" field in the mutation.
func (m *StoreFinanceMutation) BranchName() (r string, exists bool) {
	v := m.branch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchName returns the old "branch_name" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldBranchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchName: %w", err)
	}
	return oldValue.BranchName, nil
}

// ClearBranchName clears the value of the "branch_name" field.
func (m *StoreFinanceMutation) ClearBranchName() {
	m.branch_name = nil
	m.clearedFields[storefinance.FieldBranchName] = struct{}{}
}

// BranchNameCleared returns if the "branch_name" field was cleared in this mutation.
func (m *StoreFinanceMutation) BranchNameCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldBranchName]
	return ok
}

// ResetBranchName resets all changes to the "branch_name" field.
func (m *StoreFinanceMutation) ResetBranchName() {
	m.branch_name = nil
	delete(m.clearedFields, storefinance.FieldBranchName)
}

// SetPublicAccount sets the "public_account" field.
func (m *StoreFinanceMutation) SetPublicAccount(s string) {
	m.public_account = &s
}

// PublicAccount returns the value of the "public_account" field in the mutation.
func (m *StoreFinanceMutation) PublicAccount() (r string, exists bool) {
	v := m.public_account
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicAccount returns the old "public_account" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldPublicAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicAccount: %w", err)
	}
	return oldValue.PublicAccount, nil
}

// ClearPublicAccount clears the value of the "public_account" field.
func (m *StoreFinanceMutation) ClearPublicAccount() {
	m.public_account = nil
	m.clearedFields[storefinance.FieldPublicAccount] = struct{}{}
}

// PublicAccountCleared returns if the "public_account" field was cleared in this mutation.
func (m *StoreFinanceMutation) PublicAccountCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldPublicAccount]
	return ok
}

// ResetPublicAccount resets all changes to the "public_account" field.
func (m *StoreFinanceMutation) ResetPublicAccount() {
	m.public_account = nil
	delete(m.clearedFields, storefinance.FieldPublicAccount)
}

// SetCompanyName sets the "company_name" field.
func (m *StoreFinanceMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *StoreFinanceMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *StoreFinanceMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[storefinance.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *StoreFinanceMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *StoreFinanceMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, storefinance.FieldCompanyName)
}

// SetPublicBankName sets the "public_bank_name" field.
func (m *StoreFinanceMutation) SetPublicBankName(s string) {
	m.public_bank_name = &s
}

// PublicBankName returns the value of the "public_bank_name" field in the mutation.
func (m *StoreFinanceMutation) PublicBankName() (r string, exists bool) {
	v := m.public_bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicBankName returns the old "public_bank_name" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldPublicBankName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicBankName: %w", err)
	}
	return oldValue.PublicBankName, nil
}

// ClearPublicBankName clears the value of the "public_bank_name" field.
func (m *StoreFinanceMutation) ClearPublicBankName() {
	m.public_bank_name = nil
	m.clearedFields[storefinance.FieldPublicBankName] = struct{}{}
}

// PublicBankNameCleared returns if the "public_bank_name" field was cleared in this mutation.
func (m *StoreFinanceMutation) PublicBankNameCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldPublicBankName]
	return ok
}

// ResetPublicBankName resets all changes to the "public_bank_name" field.
func (m *StoreFinanceMutation) ResetPublicBankName() {
	m.public_bank_name = nil
	delete(m.clearedFields, storefinance.FieldPublicBankName)
}

// SetPublicBranchName sets the "public_branch_name" field.
func (m *StoreFinanceMutation) SetPublicBranchName(s string) {
	m.public_branch_name = &s
}

// PublicBranchName returns the value of the "public_branch_name" field in the mutation.
func (m *StoreFinanceMutation) PublicBranchName() (r string, exists bool) {
	v := m.public_branch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicBranchName returns the old "public_branch_name" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldPublicBranchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicBranchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicBranchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicBranchName: %w", err)
	}
	return oldValue.PublicBranchName, nil
}

// ClearPublicBranchName clears the value of the "public_branch_name" field.
func (m *StoreFinanceMutation) ClearPublicBranchName() {
	m.public_branch_name = nil
	m.clearedFields[storefinance.FieldPublicBranchName] = struct{}{}
}

// PublicBranchNameCleared returns if the "public_branch_name" field was cleared in this mutation.
func (m *StoreFinanceMutation) PublicBranchNameCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldPublicBranchName]
	return ok
}

// ResetPublicBranchName resets all changes to the "public_branch_name" field.
func (m *StoreFinanceMutation) ResetPublicBranchName() {
	m.public_branch_name = nil
	delete(m.clearedFields, storefinance.FieldPublicBranchName)
}

// SetCreditCode sets the "credit_code" field.
func (m *StoreFinanceMutation) SetCreditCode(s string) {
	m.credit_code = &s
}

// CreditCode returns the value of the "credit_code" field in the mutation.
func (m *StoreFinanceMutation) CreditCode() (r string, exists bool) {
	v := m.credit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditCode returns the old "credit_code" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldCreditCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditCode: %w", err)
	}
	return oldValue.CreditCode, nil
}

// ClearCreditCode clears the value of the "credit_code" field.
func (m *StoreFinanceMutation) ClearCreditCode() {
	m.credit_code = nil
	m.clearedFields[storefinance.FieldCreditCode] = struct{}{}
}

// CreditCodeCleared returns if the "credit_code" field was cleared in this mutation.
func (m *StoreFinanceMutation) CreditCodeCleared() bool {
	_, ok := m.clearedFields[storefinance.FieldCreditCode]
	return ok
}

// ResetCreditCode resets all changes to the "credit_code" field.
func (m *StoreFinanceMutation) ResetCreditCode() {
	m.credit_code = nil
	delete(m.clearedFields, storefinance.FieldCreditCode)
}

// SetStoreID sets the "store_id" field.
func (m *StoreFinanceMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StoreFinanceMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StoreFinance entity.
// If the StoreFinance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreFinanceMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StoreFinanceMutation) ResetStoreID() {
	m.store = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StoreFinanceMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[storefinance.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StoreFinanceMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StoreFinanceMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StoreFinanceMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the StoreFinanceMutation builder.
func (m *StoreFinanceMutation) Where(ps ...predicate.StoreFinance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreFinanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreFinanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreFinance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreFinanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreFinanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreFinance).
func (m *StoreFinanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreFinanceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.bank_account != nil {
		fields = append(fields, storefinance.FieldBankAccount)
	}
	if m.bank_card_name != nil {
		fields = append(fields, storefinance.FieldBankCardName)
	}
	if m.bank_name != nil {
		fields = append(fields, storefinance.FieldBankName)
	}
	if m.branch_name != nil {
		fields = append(fields, storefinance.FieldBranchName)
	}
	if m.public_account != nil {
		fields = append(fields, storefinance.FieldPublicAccount)
	}
	if m.company_name != nil {
		fields = append(fields, storefinance.FieldCompanyName)
	}
	if m.public_bank_name != nil {
		fields = append(fields, storefinance.FieldPublicBankName)
	}
	if m.public_branch_name != nil {
		fields = append(fields, storefinance.FieldPublicBranchName)
	}
	if m.credit_code != nil {
		fields = append(fields, storefinance.FieldCreditCode)
	}
	if m.store != nil {
		fields = append(fields, storefinance.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreFinanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storefinance.FieldBankAccount:
		return m.BankAccount()
	case storefinance.FieldBankCardName:
		return m.BankCardName()
	case storefinance.FieldBankName:
		return m.BankName()
	case storefinance.FieldBranchName:
		return m.BranchName()
	case storefinance.FieldPublicAccount:
		return m.PublicAccount()
	case storefinance.FieldCompanyName:
		return m.CompanyName()
	case storefinance.FieldPublicBankName:
		return m.PublicBankName()
	case storefinance.FieldPublicBranchName:
		return m.PublicBranchName()
	case storefinance.FieldCreditCode:
		return m.CreditCode()
	case storefinance.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreFinanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storefinance.FieldBankAccount:
		return m.OldBankAccount(ctx)
	case storefinance.FieldBankCardName:
		return m.OldBankCardName(ctx)
	case storefinance.FieldBankName:
		return m.OldBankName(ctx)
	case storefinance.FieldBranchName:
		return m.OldBranchName(ctx)
	case storefinance.FieldPublicAccount:
		return m.OldPublicAccount(ctx)
	case storefinance.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case storefinance.FieldPublicBankName:
		return m.OldPublicBankName(ctx)
	case storefinance.FieldPublicBranchName:
		return m.OldPublicBranchName(ctx)
	case storefinance.FieldCreditCode:
		return m.OldCreditCode(ctx)
	case storefinance.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown StoreFinance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreFinanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storefinance.FieldBankAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccount(v)
		return nil
	case storefinance.FieldBankCardName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCardName(v)
		return nil
	case storefinance.FieldBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case storefinance.FieldBranchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchName(v)
		return nil
	case storefinance.FieldPublicAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicAccount(v)
		return nil
	case storefinance.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case storefinance.FieldPublicBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicBankName(v)
		return nil
	case storefinance.FieldPublicBranchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicBranchName(v)
		return nil
	case storefinance.FieldCreditCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditCode(v)
		return nil
	case storefinance.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown StoreFinance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreFinanceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreFinanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreFinanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StoreFinance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreFinanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storefinance.FieldBankAccount) {
		fields = append(fields, storefinance.FieldBankAccount)
	}
	if m.FieldCleared(storefinance.FieldBankCardName) {
		fields = append(fields, storefinance.FieldBankCardName)
	}
	if m.FieldCleared(storefinance.FieldBankName) {
		fields = append(fields, storefinance.FieldBankName)
	}
	if m.FieldCleared(storefinance.FieldBranchName) {
		fields = append(fields, storefinance.FieldBranchName)
	}
	if m.FieldCleared(storefinance.FieldPublicAccount) {
		fields = append(fields, storefinance.FieldPublicAccount)
	}
	if m.FieldCleared(storefinance.FieldCompanyName) {
		fields = append(fields, storefinance.FieldCompanyName)
	}
	if m.FieldCleared(storefinance.FieldPublicBankName) {
		fields = append(fields, storefinance.FieldPublicBankName)
	}
	if m.FieldCleared(storefinance.FieldPublicBranchName) {
		fields = append(fields, storefinance.FieldPublicBranchName)
	}
	if m.FieldCleared(storefinance.FieldCreditCode) {
		fields = append(fields, storefinance.FieldCreditCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreFinanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreFinanceMutation) ClearField(name string) error {
	switch name {
	case storefinance.FieldBankAccount:
		m.ClearBankAccount()
		return nil
	case storefinance.FieldBankCardName:
		m.ClearBankCardName()
		return nil
	case storefinance.FieldBankName:
		m.ClearBankName()
		return nil
	case storefinance.FieldBranchName:
		m.ClearBranchName()
		return nil
	case storefinance.FieldPublicAccount:
		m.ClearPublicAccount()
		return nil
	case storefinance.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	case storefinance.FieldPublicBankName:
		m.ClearPublicBankName()
		return nil
	case storefinance.FieldPublicBranchName:
		m.ClearPublicBranchName()
		return nil
	case storefinance.FieldCreditCode:
		m.ClearCreditCode()
		return nil
	}
	return fmt.Errorf("unknown StoreFinance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreFinanceMutation) ResetField(name string) error {
	switch name {
	case storefinance.FieldBankAccount:
		m.ResetBankAccount()
		return nil
	case storefinance.FieldBankCardName:
		m.ResetBankCardName()
		return nil
	case storefinance.FieldBankName:
		m.ResetBankName()
		return nil
	case storefinance.FieldBranchName:
		m.ResetBranchName()
		return nil
	case storefinance.FieldPublicAccount:
		m.ResetPublicAccount()
		return nil
	case storefinance.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case storefinance.FieldPublicBankName:
		m.ResetPublicBankName()
		return nil
	case storefinance.FieldPublicBranchName:
		m.ResetPublicBranchName()
		return nil
	case storefinance.FieldCreditCode:
		m.ResetCreditCode()
		return nil
	case storefinance.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown StoreFinance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreFinanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, storefinance.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreFinanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storefinance.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreFinanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreFinanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreFinanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, storefinance.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreFinanceMutation) EdgeCleared(name string) bool {
	switch name {
	case storefinance.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreFinanceMutation) ClearEdge(name string) error {
	switch name {
	case storefinance.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown StoreFinance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreFinanceMutation) ResetEdge(name string) error {
	switch name {
	case storefinance.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown StoreFinance edge %s", name)
}

// StoreInfoMutation represents an operation that mutates the StoreInfo nodes in the graph.
type StoreInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	city          *string
	address       *string
	contact_name  *string
	contact_phone *string
	images        *domain.StoreInfoImages
	clearedFields map[string]struct{}
	store         *int
	clearedstore  bool
	done          bool
	oldValue      func(context.Context) (*StoreInfo, error)
	predicates    []predicate.StoreInfo
}

var _ ent.Mutation = (*StoreInfoMutation)(nil)

// storeinfoOption allows management of the mutation configuration using functional options.
type storeinfoOption func(*StoreInfoMutation)

// newStoreInfoMutation creates new mutation for the StoreInfo entity.
func newStoreInfoMutation(c config, op Op, opts ...storeinfoOption) *StoreInfoMutation {
	m := &StoreInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreInfoID sets the ID field of the mutation.
func withStoreInfoID(id int) storeinfoOption {
	return func(m *StoreInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreInfo
		)
		m.oldValue = func(ctx context.Context) (*StoreInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreInfo sets the old StoreInfo of the mutation.
func withStoreInfo(node *StoreInfo) storeinfoOption {
	return func(m *StoreInfoMutation) {
		m.oldValue = func(context.Context) (*StoreInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *StoreInfoMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *StoreInfoMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the StoreInfo entity.
// If the StoreInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreInfoMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *StoreInfoMutation) ClearCity() {
	m.city = nil
	m.clearedFields[storeinfo.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *StoreInfoMutation) CityCleared() bool {
	_, ok := m.clearedFields[storeinfo.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *StoreInfoMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, storeinfo.FieldCity)
}

// SetAddress sets the "address" field.
func (m *StoreInfoMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *StoreInfoMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the StoreInfo entity.
// If the StoreInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreInfoMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *StoreInfoMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[storeinfo.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *StoreInfoMutation) AddressCleared() bool {
	_, ok := m.clearedFields[storeinfo.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *StoreInfoMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, storeinfo.FieldAddress)
}

// SetContactName sets the "contact_name" field.
func (m *StoreInfoMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *StoreInfoMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the StoreInfo entity.
// If the StoreInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreInfoMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ClearContactName clears the value of the "contact_name" field.
func (m *StoreInfoMutation) ClearContactName() {
	m.contact_name = nil
	m.clearedFields[storeinfo.FieldContactName] = struct{}{}
}

// ContactNameCleared returns if the "contact_name" field was cleared in this mutation.
func (m *StoreInfoMutation) ContactNameCleared() bool {
	_, ok := m.clearedFields[storeinfo.FieldContactName]
	return ok
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *StoreInfoMutation) ResetContactName() {
	m.contact_name = nil
	delete(m.clearedFields, storeinfo.FieldContactName)
}

// SetContactPhone sets the "contact_phone" field.
func (m *StoreInfoMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *StoreInfoMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the StoreInfo entity.
// If the StoreInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreInfoMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ClearContactPhone clears the value of the "contact_phone" field.
func (m *StoreInfoMutation) ClearContactPhone() {
	m.contact_phone = nil
	m.clearedFields[storeinfo.FieldContactPhone] = struct{}{}
}

// ContactPhoneCleared returns if the "contact_phone" field was cleared in this mutation.
func (m *StoreInfoMutation) ContactPhoneCleared() bool {
	_, ok := m.clearedFields[storeinfo.FieldContactPhone]
	return ok
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *StoreInfoMutation) ResetContactPhone() {
	m.contact_phone = nil
	delete(m.clearedFields, storeinfo.FieldContactPhone)
}

// SetImages sets the "images" field.
func (m *StoreInfoMutation) SetImages(dii domain.StoreInfoImages) {
	m.images = &dii
}

// Images returns the value of the "images" field in the mutation.
func (m *StoreInfoMutation) Images() (r domain.StoreInfoImages, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the StoreInfo entity.
// If the StoreInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreInfoMutation) OldImages(ctx context.Context) (v domain.StoreInfoImages, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *StoreInfoMutation) ClearImages() {
	m.images = nil
	m.clearedFields[storeinfo.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *StoreInfoMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[storeinfo.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *StoreInfoMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, storeinfo.FieldImages)
}

// SetStoreID sets the "store_id" field.
func (m *StoreInfoMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StoreInfoMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StoreInfo entity.
// If the StoreInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreInfoMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StoreInfoMutation) ResetStoreID() {
	m.store = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StoreInfoMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[storeinfo.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StoreInfoMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StoreInfoMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StoreInfoMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the StoreInfoMutation builder.
func (m *StoreInfoMutation) Where(ps ...predicate.StoreInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreInfo).
func (m *StoreInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreInfoMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.city != nil {
		fields = append(fields, storeinfo.FieldCity)
	}
	if m.address != nil {
		fields = append(fields, storeinfo.FieldAddress)
	}
	if m.contact_name != nil {
		fields = append(fields, storeinfo.FieldContactName)
	}
	if m.contact_phone != nil {
		fields = append(fields, storeinfo.FieldContactPhone)
	}
	if m.images != nil {
		fields = append(fields, storeinfo.FieldImages)
	}
	if m.store != nil {
		fields = append(fields, storeinfo.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storeinfo.FieldCity:
		return m.City()
	case storeinfo.FieldAddress:
		return m.Address()
	case storeinfo.FieldContactName:
		return m.ContactName()
	case storeinfo.FieldContactPhone:
		return m.ContactPhone()
	case storeinfo.FieldImages:
		return m.Images()
	case storeinfo.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storeinfo.FieldCity:
		return m.OldCity(ctx)
	case storeinfo.FieldAddress:
		return m.OldAddress(ctx)
	case storeinfo.FieldContactName:
		return m.OldContactName(ctx)
	case storeinfo.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case storeinfo.FieldImages:
		return m.OldImages(ctx)
	case storeinfo.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown StoreInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storeinfo.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case storeinfo.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case storeinfo.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case storeinfo.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case storeinfo.FieldImages:
		v, ok := value.(domain.StoreInfoImages)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case storeinfo.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown StoreInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreInfoMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StoreInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storeinfo.FieldCity) {
		fields = append(fields, storeinfo.FieldCity)
	}
	if m.FieldCleared(storeinfo.FieldAddress) {
		fields = append(fields, storeinfo.FieldAddress)
	}
	if m.FieldCleared(storeinfo.FieldContactName) {
		fields = append(fields, storeinfo.FieldContactName)
	}
	if m.FieldCleared(storeinfo.FieldContactPhone) {
		fields = append(fields, storeinfo.FieldContactPhone)
	}
	if m.FieldCleared(storeinfo.FieldImages) {
		fields = append(fields, storeinfo.FieldImages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreInfoMutation) ClearField(name string) error {
	switch name {
	case storeinfo.FieldCity:
		m.ClearCity()
		return nil
	case storeinfo.FieldAddress:
		m.ClearAddress()
		return nil
	case storeinfo.FieldContactName:
		m.ClearContactName()
		return nil
	case storeinfo.FieldContactPhone:
		m.ClearContactPhone()
		return nil
	case storeinfo.FieldImages:
		m.ClearImages()
		return nil
	}
	return fmt.Errorf("unknown StoreInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreInfoMutation) ResetField(name string) error {
	switch name {
	case storeinfo.FieldCity:
		m.ResetCity()
		return nil
	case storeinfo.FieldAddress:
		m.ResetAddress()
		return nil
	case storeinfo.FieldContactName:
		m.ResetContactName()
		return nil
	case storeinfo.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case storeinfo.FieldImages:
		m.ResetImages()
		return nil
	case storeinfo.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown StoreInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, storeinfo.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storeinfo.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, storeinfo.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case storeinfo.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreInfoMutation) ClearEdge(name string) error {
	switch name {
	case storeinfo.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown StoreInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreInfoMutation) ResetEdge(name string) error {
	switch name {
	case storeinfo.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown StoreInfo edge %s", name)
}

// StoreWithdrawMutation represents an operation that mutates the StoreWithdraw nodes in the graph.
type StoreWithdrawMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *int64
	adddeleted_at         *int64
	store_name            *string
	no                    *string
	amount                *decimal.Decimal
	point_withdrawal_rate *decimal.Decimal
	actual_amount         *decimal.Decimal
	account_type          *domain.AccountType
	bank_account          *string
	bank_card_name        *string
	bank_name             *string
	bank_branch           *string
	invoice_amount        *decimal.Decimal
	status                *domain.StoreWithdrawStatus
	addstatus             *domain.StoreWithdrawStatus
	clearedFields         map[string]struct{}
	store                 *int
	clearedstore          bool
	done                  bool
	oldValue              func(context.Context) (*StoreWithdraw, error)
	predicates            []predicate.StoreWithdraw
}

var _ ent.Mutation = (*StoreWithdrawMutation)(nil)

// storewithdrawOption allows management of the mutation configuration using functional options.
type storewithdrawOption func(*StoreWithdrawMutation)

// newStoreWithdrawMutation creates new mutation for the StoreWithdraw entity.
func newStoreWithdrawMutation(c config, op Op, opts ...storewithdrawOption) *StoreWithdrawMutation {
	m := &StoreWithdrawMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreWithdraw,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreWithdrawID sets the ID field of the mutation.
func withStoreWithdrawID(id int) storewithdrawOption {
	return func(m *StoreWithdrawMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreWithdraw
		)
		m.oldValue = func(ctx context.Context) (*StoreWithdraw, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreWithdraw.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreWithdraw sets the old StoreWithdraw of the mutation.
func withStoreWithdraw(node *StoreWithdraw) storewithdrawOption {
	return func(m *StoreWithdrawMutation) {
		m.oldValue = func(context.Context) (*StoreWithdraw, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreWithdrawMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreWithdrawMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreWithdrawMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreWithdrawMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreWithdraw.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreWithdrawMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreWithdrawMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreWithdrawMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreWithdrawMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreWithdrawMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreWithdrawMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreWithdrawMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreWithdrawMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StoreWithdrawMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StoreWithdrawMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreWithdrawMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetStoreID sets the "store_id" field.
func (m *StoreWithdrawMutation) SetStoreID(i int) {
	m.store = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StoreWithdrawMutation) StoreID() (r int, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StoreWithdrawMutation) ResetStoreID() {
	m.store = nil
}

// SetStoreName sets the "store_name" field.
func (m *StoreWithdrawMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *StoreWithdrawMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *StoreWithdrawMutation) ResetStoreName() {
	m.store_name = nil
}

// SetNo sets the "no" field.
func (m *StoreWithdrawMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *StoreWithdrawMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *StoreWithdrawMutation) ResetNo() {
	m.no = nil
}

// SetAmount sets the "amount" field.
func (m *StoreWithdrawMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *StoreWithdrawMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *StoreWithdrawMutation) ResetAmount() {
	m.amount = nil
}

// SetPointWithdrawalRate sets the "point_withdrawal_rate" field.
func (m *StoreWithdrawMutation) SetPointWithdrawalRate(d decimal.Decimal) {
	m.point_withdrawal_rate = &d
}

// PointWithdrawalRate returns the value of the "point_withdrawal_rate" field in the mutation.
func (m *StoreWithdrawMutation) PointWithdrawalRate() (r decimal.Decimal, exists bool) {
	v := m.point_withdrawal_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldPointWithdrawalRate returns the old "point_withdrawal_rate" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldPointWithdrawalRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointWithdrawalRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointWithdrawalRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointWithdrawalRate: %w", err)
	}
	return oldValue.PointWithdrawalRate, nil
}

// ResetPointWithdrawalRate resets all changes to the "point_withdrawal_rate" field.
func (m *StoreWithdrawMutation) ResetPointWithdrawalRate() {
	m.point_withdrawal_rate = nil
}

// SetActualAmount sets the "actual_amount" field.
func (m *StoreWithdrawMutation) SetActualAmount(d decimal.Decimal) {
	m.actual_amount = &d
}

// ActualAmount returns the value of the "actual_amount" field in the mutation.
func (m *StoreWithdrawMutation) ActualAmount() (r decimal.Decimal, exists bool) {
	v := m.actual_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldActualAmount returns the old "actual_amount" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldActualAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualAmount: %w", err)
	}
	return oldValue.ActualAmount, nil
}

// ResetActualAmount resets all changes to the "actual_amount" field.
func (m *StoreWithdrawMutation) ResetActualAmount() {
	m.actual_amount = nil
}

// SetAccountType sets the "account_type" field.
func (m *StoreWithdrawMutation) SetAccountType(dt domain.AccountType) {
	m.account_type = &dt
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *StoreWithdrawMutation) AccountType() (r domain.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldAccountType(ctx context.Context) (v domain.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *StoreWithdrawMutation) ResetAccountType() {
	m.account_type = nil
}

// SetBankAccount sets the "bank_account" field.
func (m *StoreWithdrawMutation) SetBankAccount(s string) {
	m.bank_account = &s
}

// BankAccount returns the value of the "bank_account" field in the mutation.
func (m *StoreWithdrawMutation) BankAccount() (r string, exists bool) {
	v := m.bank_account
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccount returns the old "bank_account" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldBankAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccount: %w", err)
	}
	return oldValue.BankAccount, nil
}

// ResetBankAccount resets all changes to the "bank_account" field.
func (m *StoreWithdrawMutation) ResetBankAccount() {
	m.bank_account = nil
}

// SetBankCardName sets the "bank_card_name" field.
func (m *StoreWithdrawMutation) SetBankCardName(s string) {
	m.bank_card_name = &s
}

// BankCardName returns the value of the "bank_card_name" field in the mutation.
func (m *StoreWithdrawMutation) BankCardName() (r string, exists bool) {
	v := m.bank_card_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCardName returns the old "bank_card_name" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldBankCardName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankCardName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankCardName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCardName: %w", err)
	}
	return oldValue.BankCardName, nil
}

// ResetBankCardName resets all changes to the "bank_card_name" field.
func (m *StoreWithdrawMutation) ResetBankCardName() {
	m.bank_card_name = nil
}

// SetBankName sets the "bank_name" field.
func (m *StoreWithdrawMutation) SetBankName(s string) {
	m.bank_name = &s
}

// BankName returns the value of the "bank_name" field in the mutation.
func (m *StoreWithdrawMutation) BankName() (r string, exists bool) {
	v := m.bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bank_name" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldBankName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// ResetBankName resets all changes to the "bank_name" field.
func (m *StoreWithdrawMutation) ResetBankName() {
	m.bank_name = nil
}

// SetBankBranch sets the "bank_branch" field.
func (m *StoreWithdrawMutation) SetBankBranch(s string) {
	m.bank_branch = &s
}

// BankBranch returns the value of the "bank_branch" field in the mutation.
func (m *StoreWithdrawMutation) BankBranch() (r string, exists bool) {
	v := m.bank_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBankBranch returns the old "bank_branch" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldBankBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankBranch: %w", err)
	}
	return oldValue.BankBranch, nil
}

// ResetBankBranch resets all changes to the "bank_branch" field.
func (m *StoreWithdrawMutation) ResetBankBranch() {
	m.bank_branch = nil
}

// SetInvoiceAmount sets the "invoice_amount" field.
func (m *StoreWithdrawMutation) SetInvoiceAmount(d decimal.Decimal) {
	m.invoice_amount = &d
}

// InvoiceAmount returns the value of the "invoice_amount" field in the mutation.
func (m *StoreWithdrawMutation) InvoiceAmount() (r decimal.Decimal, exists bool) {
	v := m.invoice_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAmount returns the old "invoice_amount" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldInvoiceAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAmount: %w", err)
	}
	return oldValue.InvoiceAmount, nil
}

// ResetInvoiceAmount resets all changes to the "invoice_amount" field.
func (m *StoreWithdrawMutation) ResetInvoiceAmount() {
	m.invoice_amount = nil
}

// SetStatus sets the "status" field.
func (m *StoreWithdrawMutation) SetStatus(dws domain.StoreWithdrawStatus) {
	m.status = &dws
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *StoreWithdrawMutation) Status() (r domain.StoreWithdrawStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StoreWithdraw entity.
// If the StoreWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreWithdrawMutation) OldStatus(ctx context.Context) (v domain.StoreWithdrawStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds dws to the "status" field.
func (m *StoreWithdrawMutation) AddStatus(dws domain.StoreWithdrawStatus) {
	if m.addstatus != nil {
		*m.addstatus += dws
	} else {
		m.addstatus = &dws
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *StoreWithdrawMutation) AddedStatus() (r domain.StoreWithdrawStatus, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *StoreWithdrawMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StoreWithdrawMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[storewithdraw.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StoreWithdrawMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StoreWithdrawMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StoreWithdrawMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the StoreWithdrawMutation builder.
func (m *StoreWithdrawMutation) Where(ps ...predicate.StoreWithdraw) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreWithdrawMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreWithdrawMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreWithdraw, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreWithdrawMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreWithdrawMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreWithdraw).
func (m *StoreWithdrawMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreWithdrawMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, storewithdraw.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storewithdraw.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storewithdraw.FieldDeletedAt)
	}
	if m.store != nil {
		fields = append(fields, storewithdraw.FieldStoreID)
	}
	if m.store_name != nil {
		fields = append(fields, storewithdraw.FieldStoreName)
	}
	if m.no != nil {
		fields = append(fields, storewithdraw.FieldNo)
	}
	if m.amount != nil {
		fields = append(fields, storewithdraw.FieldAmount)
	}
	if m.point_withdrawal_rate != nil {
		fields = append(fields, storewithdraw.FieldPointWithdrawalRate)
	}
	if m.actual_amount != nil {
		fields = append(fields, storewithdraw.FieldActualAmount)
	}
	if m.account_type != nil {
		fields = append(fields, storewithdraw.FieldAccountType)
	}
	if m.bank_account != nil {
		fields = append(fields, storewithdraw.FieldBankAccount)
	}
	if m.bank_card_name != nil {
		fields = append(fields, storewithdraw.FieldBankCardName)
	}
	if m.bank_name != nil {
		fields = append(fields, storewithdraw.FieldBankName)
	}
	if m.bank_branch != nil {
		fields = append(fields, storewithdraw.FieldBankBranch)
	}
	if m.invoice_amount != nil {
		fields = append(fields, storewithdraw.FieldInvoiceAmount)
	}
	if m.status != nil {
		fields = append(fields, storewithdraw.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreWithdrawMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storewithdraw.FieldCreatedAt:
		return m.CreatedAt()
	case storewithdraw.FieldUpdatedAt:
		return m.UpdatedAt()
	case storewithdraw.FieldDeletedAt:
		return m.DeletedAt()
	case storewithdraw.FieldStoreID:
		return m.StoreID()
	case storewithdraw.FieldStoreName:
		return m.StoreName()
	case storewithdraw.FieldNo:
		return m.No()
	case storewithdraw.FieldAmount:
		return m.Amount()
	case storewithdraw.FieldPointWithdrawalRate:
		return m.PointWithdrawalRate()
	case storewithdraw.FieldActualAmount:
		return m.ActualAmount()
	case storewithdraw.FieldAccountType:
		return m.AccountType()
	case storewithdraw.FieldBankAccount:
		return m.BankAccount()
	case storewithdraw.FieldBankCardName:
		return m.BankCardName()
	case storewithdraw.FieldBankName:
		return m.BankName()
	case storewithdraw.FieldBankBranch:
		return m.BankBranch()
	case storewithdraw.FieldInvoiceAmount:
		return m.InvoiceAmount()
	case storewithdraw.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreWithdrawMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storewithdraw.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storewithdraw.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storewithdraw.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storewithdraw.FieldStoreID:
		return m.OldStoreID(ctx)
	case storewithdraw.FieldStoreName:
		return m.OldStoreName(ctx)
	case storewithdraw.FieldNo:
		return m.OldNo(ctx)
	case storewithdraw.FieldAmount:
		return m.OldAmount(ctx)
	case storewithdraw.FieldPointWithdrawalRate:
		return m.OldPointWithdrawalRate(ctx)
	case storewithdraw.FieldActualAmount:
		return m.OldActualAmount(ctx)
	case storewithdraw.FieldAccountType:
		return m.OldAccountType(ctx)
	case storewithdraw.FieldBankAccount:
		return m.OldBankAccount(ctx)
	case storewithdraw.FieldBankCardName:
		return m.OldBankCardName(ctx)
	case storewithdraw.FieldBankName:
		return m.OldBankName(ctx)
	case storewithdraw.FieldBankBranch:
		return m.OldBankBranch(ctx)
	case storewithdraw.FieldInvoiceAmount:
		return m.OldInvoiceAmount(ctx)
	case storewithdraw.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown StoreWithdraw field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreWithdrawMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storewithdraw.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storewithdraw.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storewithdraw.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storewithdraw.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case storewithdraw.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case storewithdraw.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case storewithdraw.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case storewithdraw.FieldPointWithdrawalRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointWithdrawalRate(v)
		return nil
	case storewithdraw.FieldActualAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualAmount(v)
		return nil
	case storewithdraw.FieldAccountType:
		v, ok := value.(domain.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case storewithdraw.FieldBankAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccount(v)
		return nil
	case storewithdraw.FieldBankCardName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCardName(v)
		return nil
	case storewithdraw.FieldBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case storewithdraw.FieldBankBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankBranch(v)
		return nil
	case storewithdraw.FieldInvoiceAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAmount(v)
		return nil
	case storewithdraw.FieldStatus:
		v, ok := value.(domain.StoreWithdrawStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown StoreWithdraw field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreWithdrawMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, storewithdraw.FieldDeletedAt)
	}
	if m.addstatus != nil {
		fields = append(fields, storewithdraw.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreWithdrawMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storewithdraw.FieldDeletedAt:
		return m.AddedDeletedAt()
	case storewithdraw.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreWithdrawMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storewithdraw.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case storewithdraw.FieldStatus:
		v, ok := value.(domain.StoreWithdrawStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown StoreWithdraw numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreWithdrawMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreWithdrawMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreWithdrawMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StoreWithdraw nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreWithdrawMutation) ResetField(name string) error {
	switch name {
	case storewithdraw.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storewithdraw.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storewithdraw.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storewithdraw.FieldStoreID:
		m.ResetStoreID()
		return nil
	case storewithdraw.FieldStoreName:
		m.ResetStoreName()
		return nil
	case storewithdraw.FieldNo:
		m.ResetNo()
		return nil
	case storewithdraw.FieldAmount:
		m.ResetAmount()
		return nil
	case storewithdraw.FieldPointWithdrawalRate:
		m.ResetPointWithdrawalRate()
		return nil
	case storewithdraw.FieldActualAmount:
		m.ResetActualAmount()
		return nil
	case storewithdraw.FieldAccountType:
		m.ResetAccountType()
		return nil
	case storewithdraw.FieldBankAccount:
		m.ResetBankAccount()
		return nil
	case storewithdraw.FieldBankCardName:
		m.ResetBankCardName()
		return nil
	case storewithdraw.FieldBankName:
		m.ResetBankName()
		return nil
	case storewithdraw.FieldBankBranch:
		m.ResetBankBranch()
		return nil
	case storewithdraw.FieldInvoiceAmount:
		m.ResetInvoiceAmount()
		return nil
	case storewithdraw.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown StoreWithdraw field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreWithdrawMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, storewithdraw.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreWithdrawMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storewithdraw.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreWithdrawMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreWithdrawMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreWithdrawMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, storewithdraw.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreWithdrawMutation) EdgeCleared(name string) bool {
	switch name {
	case storewithdraw.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreWithdrawMutation) ClearEdge(name string) error {
	switch name {
	case storewithdraw.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown StoreWithdraw unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreWithdrawMutation) ResetEdge(name string) error {
	switch name {
	case storewithdraw.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown StoreWithdraw edge %s", name)
}

// TableAreaMutation represents an operation that mutates the TableArea nodes in the graph.
type TableAreaMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int64
	adddeleted_at     *int64
	name              *string
	store_id          *int
	addstore_id       *int
	table_count       *int
	addtable_count    *int
	clearedFields     map[string]struct{}
	dinetables        map[int]struct{}
	removeddinetables map[int]struct{}
	cleareddinetables bool
	done              bool
	oldValue          func(context.Context) (*TableArea, error)
	predicates        []predicate.TableArea
}

var _ ent.Mutation = (*TableAreaMutation)(nil)

// tableareaOption allows management of the mutation configuration using functional options.
type tableareaOption func(*TableAreaMutation)

// newTableAreaMutation creates new mutation for the TableArea entity.
func newTableAreaMutation(c config, op Op, opts ...tableareaOption) *TableAreaMutation {
	m := &TableAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeTableArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTableAreaID sets the ID field of the mutation.
func withTableAreaID(id int) tableareaOption {
	return func(m *TableAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *TableArea
		)
		m.oldValue = func(ctx context.Context) (*TableArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TableArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTableArea sets the old TableArea of the mutation.
func withTableArea(node *TableArea) tableareaOption {
	return func(m *TableAreaMutation) {
		m.oldValue = func(context.Context) (*TableArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TableAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TableAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TableAreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TableAreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TableArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TableAreaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TableAreaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TableArea entity.
// If the TableArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableAreaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TableAreaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TableAreaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TableAreaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TableArea entity.
// If the TableArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableAreaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TableAreaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TableAreaMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TableAreaMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TableArea entity.
// If the TableArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableAreaMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TableAreaMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TableAreaMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TableAreaMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *TableAreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TableAreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TableArea entity.
// If the TableArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableAreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TableAreaMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *TableAreaMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *TableAreaMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the TableArea entity.
// If the TableArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableAreaMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *TableAreaMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *TableAreaMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *TableAreaMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetTableCount sets the "table_count" field.
func (m *TableAreaMutation) SetTableCount(i int) {
	m.table_count = &i
	m.addtable_count = nil
}

// TableCount returns the value of the "table_count" field in the mutation.
func (m *TableAreaMutation) TableCount() (r int, exists bool) {
	v := m.table_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTableCount returns the old "table_count" field's value of the TableArea entity.
// If the TableArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableAreaMutation) OldTableCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableCount: %w", err)
	}
	return oldValue.TableCount, nil
}

// AddTableCount adds i to the "table_count" field.
func (m *TableAreaMutation) AddTableCount(i int) {
	if m.addtable_count != nil {
		*m.addtable_count += i
	} else {
		m.addtable_count = &i
	}
}

// AddedTableCount returns the value that was added to the "table_count" field in this mutation.
func (m *TableAreaMutation) AddedTableCount() (r int, exists bool) {
	v := m.addtable_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTableCount clears the value of the "table_count" field.
func (m *TableAreaMutation) ClearTableCount() {
	m.table_count = nil
	m.addtable_count = nil
	m.clearedFields[tablearea.FieldTableCount] = struct{}{}
}

// TableCountCleared returns if the "table_count" field was cleared in this mutation.
func (m *TableAreaMutation) TableCountCleared() bool {
	_, ok := m.clearedFields[tablearea.FieldTableCount]
	return ok
}

// ResetTableCount resets all changes to the "table_count" field.
func (m *TableAreaMutation) ResetTableCount() {
	m.table_count = nil
	m.addtable_count = nil
	delete(m.clearedFields, tablearea.FieldTableCount)
}

// AddDinetableIDs adds the "dinetables" edge to the DineTable entity by ids.
func (m *TableAreaMutation) AddDinetableIDs(ids ...int) {
	if m.dinetables == nil {
		m.dinetables = make(map[int]struct{})
	}
	for i := range ids {
		m.dinetables[ids[i]] = struct{}{}
	}
}

// ClearDinetables clears the "dinetables" edge to the DineTable entity.
func (m *TableAreaMutation) ClearDinetables() {
	m.cleareddinetables = true
}

// DinetablesCleared reports if the "dinetables" edge to the DineTable entity was cleared.
func (m *TableAreaMutation) DinetablesCleared() bool {
	return m.cleareddinetables
}

// RemoveDinetableIDs removes the "dinetables" edge to the DineTable entity by IDs.
func (m *TableAreaMutation) RemoveDinetableIDs(ids ...int) {
	if m.removeddinetables == nil {
		m.removeddinetables = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dinetables, ids[i])
		m.removeddinetables[ids[i]] = struct{}{}
	}
}

// RemovedDinetables returns the removed IDs of the "dinetables" edge to the DineTable entity.
func (m *TableAreaMutation) RemovedDinetablesIDs() (ids []int) {
	for id := range m.removeddinetables {
		ids = append(ids, id)
	}
	return
}

// DinetablesIDs returns the "dinetables" edge IDs in the mutation.
func (m *TableAreaMutation) DinetablesIDs() (ids []int) {
	for id := range m.dinetables {
		ids = append(ids, id)
	}
	return
}

// ResetDinetables resets all changes to the "dinetables" edge.
func (m *TableAreaMutation) ResetDinetables() {
	m.dinetables = nil
	m.cleareddinetables = false
	m.removeddinetables = nil
}

// Where appends a list predicates to the TableAreaMutation builder.
func (m *TableAreaMutation) Where(ps ...predicate.TableArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TableAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TableAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TableArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TableAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TableAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TableArea).
func (m *TableAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TableAreaMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, tablearea.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tablearea.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tablearea.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tablearea.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, tablearea.FieldStoreID)
	}
	if m.table_count != nil {
		fields = append(fields, tablearea.FieldTableCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TableAreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tablearea.FieldCreatedAt:
		return m.CreatedAt()
	case tablearea.FieldUpdatedAt:
		return m.UpdatedAt()
	case tablearea.FieldDeletedAt:
		return m.DeletedAt()
	case tablearea.FieldName:
		return m.Name()
	case tablearea.FieldStoreID:
		return m.StoreID()
	case tablearea.FieldTableCount:
		return m.TableCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TableAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tablearea.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tablearea.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tablearea.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tablearea.FieldName:
		return m.OldName(ctx)
	case tablearea.FieldStoreID:
		return m.OldStoreID(ctx)
	case tablearea.FieldTableCount:
		return m.OldTableCount(ctx)
	}
	return nil, fmt.Errorf("unknown TableArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tablearea.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tablearea.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tablearea.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tablearea.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tablearea.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case tablearea.FieldTableCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableCount(v)
		return nil
	}
	return fmt.Errorf("unknown TableArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TableAreaMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, tablearea.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, tablearea.FieldStoreID)
	}
	if m.addtable_count != nil {
		fields = append(fields, tablearea.FieldTableCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TableAreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tablearea.FieldDeletedAt:
		return m.AddedDeletedAt()
	case tablearea.FieldStoreID:
		return m.AddedStoreID()
	case tablearea.FieldTableCount:
		return m.AddedTableCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableAreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tablearea.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case tablearea.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case tablearea.FieldTableCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTableCount(v)
		return nil
	}
	return fmt.Errorf("unknown TableArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TableAreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tablearea.FieldTableCount) {
		fields = append(fields, tablearea.FieldTableCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TableAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TableAreaMutation) ClearField(name string) error {
	switch name {
	case tablearea.FieldTableCount:
		m.ClearTableCount()
		return nil
	}
	return fmt.Errorf("unknown TableArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TableAreaMutation) ResetField(name string) error {
	switch name {
	case tablearea.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tablearea.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tablearea.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tablearea.FieldName:
		m.ResetName()
		return nil
	case tablearea.FieldStoreID:
		m.ResetStoreID()
		return nil
	case tablearea.FieldTableCount:
		m.ResetTableCount()
		return nil
	}
	return fmt.Errorf("unknown TableArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TableAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dinetables != nil {
		edges = append(edges, tablearea.EdgeDinetables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TableAreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tablearea.EdgeDinetables:
		ids := make([]ent.Value, 0, len(m.dinetables))
		for id := range m.dinetables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TableAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddinetables != nil {
		edges = append(edges, tablearea.EdgeDinetables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TableAreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tablearea.EdgeDinetables:
		ids := make([]ent.Value, 0, len(m.removeddinetables))
		for id := range m.removeddinetables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TableAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddinetables {
		edges = append(edges, tablearea.EdgeDinetables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TableAreaMutation) EdgeCleared(name string) bool {
	switch name {
	case tablearea.EdgeDinetables:
		return m.cleareddinetables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TableAreaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TableArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TableAreaMutation) ResetEdge(name string) error {
	switch name {
	case tablearea.EdgeDinetables:
		m.ResetDinetables()
		return nil
	}
	return fmt.Errorf("unknown TableArea edge %s", name)
}

// UnitMutation represents an operation that mutates the Unit nodes in the graph.
type UnitMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	store_id        *int
	addstore_id     *int
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Unit, error)
	predicates      []predicate.Unit
}

var _ ent.Mutation = (*UnitMutation)(nil)

// unitOption allows management of the mutation configuration using functional options.
type unitOption func(*UnitMutation)

// newUnitMutation creates new mutation for the Unit entity.
func newUnitMutation(c config, op Op, opts ...unitOption) *UnitMutation {
	m := &UnitMutation{
		config:        c,
		op:            op,
		typ:           TypeUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnitID sets the ID field of the mutation.
func withUnitID(id int) unitOption {
	return func(m *UnitMutation) {
		var (
			err   error
			once  sync.Once
			value *Unit
		)
		m.oldValue = func(ctx context.Context) (*Unit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Unit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnit sets the old Unit of the mutation.
func withUnit(node *Unit) unitOption {
	return func(m *UnitMutation) {
		m.oldValue = func(context.Context) (*Unit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UnitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UnitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Unit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UnitMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UnitMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UnitMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UnitMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UnitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *UnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UnitMutation) ResetName() {
	m.name = nil
}

// SetStoreID sets the "store_id" field.
func (m *UnitMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *UnitMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *UnitMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *UnitMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *UnitMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *UnitMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *UnitMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *UnitMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *UnitMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *UnitMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *UnitMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *UnitMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the UnitMutation builder.
func (m *UnitMutation) Where(ps ...predicate.Unit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Unit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Unit).
func (m *UnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnitMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, unit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, unit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, unit.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, unit.FieldName)
	}
	if m.store_id != nil {
		fields = append(fields, unit.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unit.FieldCreatedAt:
		return m.CreatedAt()
	case unit.FieldUpdatedAt:
		return m.UpdatedAt()
	case unit.FieldDeletedAt:
		return m.DeletedAt()
	case unit.FieldName:
		return m.Name()
	case unit.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case unit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case unit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case unit.FieldName:
		return m.OldName(ctx)
	case unit.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Unit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case unit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case unit.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case unit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case unit.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Unit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnitMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, unit.FieldDeletedAt)
	}
	if m.addstore_id != nil {
		fields = append(fields, unit.FieldStoreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case unit.FieldDeletedAt:
		return m.AddedDeletedAt()
	case unit.FieldStoreID:
		return m.AddedStoreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case unit.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case unit.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Unit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Unit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnitMutation) ResetField(name string) error {
	switch name {
	case unit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case unit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case unit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case unit.FieldName:
		m.ResetName()
		return nil
	case unit.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Unit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, unit.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unit.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, unit.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case unit.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, unit.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnitMutation) EdgeCleared(name string) bool {
	switch name {
	case unit.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnitMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Unit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnitMutation) ResetEdge(name string) error {
	switch name {
	case unit.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Unit edge %s", name)
}
