// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"gitlab.jiguang.dev/pos-dine/dine/domain"
	"gitlab.jiguang.dev/pos-dine/dine/ent/adminuser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/backenduser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/category"
	"gitlab.jiguang.dev/pos-dine/dine/ent/predicate"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productspec"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productunit"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminUser   = "AdminUser"
	TypeBackendUser = "BackendUser"
	TypeCategory    = "Category"
	TypeProductSpec = "ProductSpec"
	TypeProductUnit = "ProductUnit"
)

// AdminUserMutation represents an operation that mutates the AdminUser nodes in the graph.
type AdminUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AdminUser, error)
	predicates      []predicate.AdminUser
}

var _ ent.Mutation = (*AdminUserMutation)(nil)

// adminuserOption allows management of the mutation configuration using functional options.
type adminuserOption func(*AdminUserMutation)

// newAdminUserMutation creates new mutation for the AdminUser entity.
func newAdminUserMutation(c config, op Op, opts ...adminuserOption) *AdminUserMutation {
	m := &AdminUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminUserID sets the ID field of the mutation.
func withAdminUserID(id uuid.UUID) adminuserOption {
	return func(m *AdminUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminUser
		)
		m.oldValue = func(ctx context.Context) (*AdminUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminUser sets the old AdminUser of the mutation.
func withAdminUser(node *AdminUser) adminuserOption {
	return func(m *AdminUserMutation) {
		m.oldValue = func(context.Context) (*AdminUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminUser entities.
func (m *AdminUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AdminUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AdminUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *AdminUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *AdminUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *AdminUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *AdminUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AdminUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AdminUserMutation) ResetNickname() {
	m.nickname = nil
}

// Where appends a list predicates to the AdminUserMutation builder.
func (m *AdminUserMutation) Where(ps ...predicate.AdminUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminUser).
func (m *AdminUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminuser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, adminuser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, adminuser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, adminuser.FieldNickname)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.CreatedAt()
	case adminuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case adminuser.FieldDeletedAt:
		return m.DeletedAt()
	case adminuser.FieldUsername:
		return m.Username()
	case adminuser.FieldHashedPassword:
		return m.HashedPassword()
	case adminuser.FieldNickname:
		return m.Nickname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adminuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminuser.FieldUsername:
		return m.OldUsername(ctx)
	case adminuser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case adminuser.FieldNickname:
		return m.OldNickname(ctx)
	}
	return nil, fmt.Errorf("unknown AdminUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adminuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case adminuser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case adminuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, adminuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminUserMutation) ResetField(name string) error {
	switch name {
	case adminuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adminuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminuser.FieldUsername:
		m.ResetUsername()
		return nil
	case adminuser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case adminuser.FieldNickname:
		m.ResetNickname()
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdminUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdminUser edge %s", name)
}

// BackendUserMutation represents an operation that mutates the BackendUser nodes in the graph.
type BackendUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	merchant_id     *uuid.UUID
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*BackendUser, error)
	predicates      []predicate.BackendUser
}

var _ ent.Mutation = (*BackendUserMutation)(nil)

// backenduserOption allows management of the mutation configuration using functional options.
type backenduserOption func(*BackendUserMutation)

// newBackendUserMutation creates new mutation for the BackendUser entity.
func newBackendUserMutation(c config, op Op, opts ...backenduserOption) *BackendUserMutation {
	m := &BackendUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBackendUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackendUserID sets the ID field of the mutation.
func withBackendUserID(id uuid.UUID) backenduserOption {
	return func(m *BackendUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BackendUser
		)
		m.oldValue = func(ctx context.Context) (*BackendUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackendUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackendUser sets the old BackendUser of the mutation.
func withBackendUser(node *BackendUser) backenduserOption {
	return func(m *BackendUserMutation) {
		m.oldValue = func(context.Context) (*BackendUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackendUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackendUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BackendUser entities.
func (m *BackendUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackendUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackendUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackendUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BackendUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackendUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackendUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackendUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackendUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackendUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BackendUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BackendUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BackendUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BackendUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BackendUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *BackendUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *BackendUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *BackendUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *BackendUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *BackendUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *BackendUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *BackendUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *BackendUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *BackendUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *BackendUserMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *BackendUserMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *BackendUserMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// Where appends a list predicates to the BackendUserMutation builder.
func (m *BackendUserMutation) Where(ps ...predicate.BackendUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackendUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackendUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackendUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackendUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackendUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackendUser).
func (m *BackendUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackendUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, backenduser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backenduser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, backenduser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, backenduser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, backenduser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, backenduser.FieldNickname)
	}
	if m.merchant_id != nil {
		fields = append(fields, backenduser.FieldMerchantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackendUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backenduser.FieldCreatedAt:
		return m.CreatedAt()
	case backenduser.FieldUpdatedAt:
		return m.UpdatedAt()
	case backenduser.FieldDeletedAt:
		return m.DeletedAt()
	case backenduser.FieldUsername:
		return m.Username()
	case backenduser.FieldHashedPassword:
		return m.HashedPassword()
	case backenduser.FieldNickname:
		return m.Nickname()
	case backenduser.FieldMerchantID:
		return m.MerchantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackendUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backenduser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backenduser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backenduser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case backenduser.FieldUsername:
		return m.OldUsername(ctx)
	case backenduser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case backenduser.FieldNickname:
		return m.OldNickname(ctx)
	case backenduser.FieldMerchantID:
		return m.OldMerchantID(ctx)
	}
	return nil, fmt.Errorf("unknown BackendUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackendUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backenduser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backenduser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case backenduser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case backenduser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case backenduser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case backenduser.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	}
	return fmt.Errorf("unknown BackendUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackendUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, backenduser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackendUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backenduser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackendUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackendUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackendUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackendUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackendUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BackendUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackendUserMutation) ResetField(name string) error {
	switch name {
	case backenduser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backenduser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backenduser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case backenduser.FieldUsername:
		m.ResetUsername()
		return nil
	case backenduser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case backenduser.FieldNickname:
		m.ResetNickname()
		return nil
	case backenduser.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	}
	return fmt.Errorf("unknown BackendUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackendUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackendUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackendUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackendUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackendUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackendUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackendUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BackendUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackendUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BackendUser edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	merchant_id      *uuid.UUID
	store_id         *uuid.UUID
	inherit_tax_rate *bool
	tax_rate_id      *uuid.UUID
	inherit_stall    *bool
	stall_id         *uuid.UUID
	product_count    *int
	addproduct_count *int
	sort_order       *int
	addsort_order    *int
	clearedFields    map[string]struct{}
	children         map[uuid.UUID]struct{}
	removedchildren  map[uuid.UUID]struct{}
	clearedchildren  bool
	parent           *uuid.UUID
	clearedparent    bool
	done             bool
	oldValue         func(context.Context) (*Category, error)
	predicates       []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uuid.UUID) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *CategoryMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CategoryMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *CategoryMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *CategoryMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *CategoryMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *CategoryMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *CategoryMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *CategoryMutation) ClearStoreID() {
	m.store_id = nil
	m.clearedFields[category.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *CategoryMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[category.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *CategoryMutation) ResetStoreID() {
	m.store_id = nil
	delete(m.clearedFields, category.FieldStoreID)
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetInheritTaxRate sets the "inherit_tax_rate" field.
func (m *CategoryMutation) SetInheritTaxRate(b bool) {
	m.inherit_tax_rate = &b
}

// InheritTaxRate returns the value of the "inherit_tax_rate" field in the mutation.
func (m *CategoryMutation) InheritTaxRate() (r bool, exists bool) {
	v := m.inherit_tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritTaxRate returns the old "inherit_tax_rate" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldInheritTaxRate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritTaxRate: %w", err)
	}
	return oldValue.InheritTaxRate, nil
}

// ResetInheritTaxRate resets all changes to the "inherit_tax_rate" field.
func (m *CategoryMutation) ResetInheritTaxRate() {
	m.inherit_tax_rate = nil
}

// SetTaxRateID sets the "tax_rate_id" field.
func (m *CategoryMutation) SetTaxRateID(u uuid.UUID) {
	m.tax_rate_id = &u
}

// TaxRateID returns the value of the "tax_rate_id" field in the mutation.
func (m *CategoryMutation) TaxRateID() (r uuid.UUID, exists bool) {
	v := m.tax_rate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRateID returns the old "tax_rate_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldTaxRateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRateID: %w", err)
	}
	return oldValue.TaxRateID, nil
}

// ClearTaxRateID clears the value of the "tax_rate_id" field.
func (m *CategoryMutation) ClearTaxRateID() {
	m.tax_rate_id = nil
	m.clearedFields[category.FieldTaxRateID] = struct{}{}
}

// TaxRateIDCleared returns if the "tax_rate_id" field was cleared in this mutation.
func (m *CategoryMutation) TaxRateIDCleared() bool {
	_, ok := m.clearedFields[category.FieldTaxRateID]
	return ok
}

// ResetTaxRateID resets all changes to the "tax_rate_id" field.
func (m *CategoryMutation) ResetTaxRateID() {
	m.tax_rate_id = nil
	delete(m.clearedFields, category.FieldTaxRateID)
}

// SetInheritStall sets the "inherit_stall" field.
func (m *CategoryMutation) SetInheritStall(b bool) {
	m.inherit_stall = &b
}

// InheritStall returns the value of the "inherit_stall" field in the mutation.
func (m *CategoryMutation) InheritStall() (r bool, exists bool) {
	v := m.inherit_stall
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritStall returns the old "inherit_stall" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldInheritStall(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritStall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritStall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritStall: %w", err)
	}
	return oldValue.InheritStall, nil
}

// ResetInheritStall resets all changes to the "inherit_stall" field.
func (m *CategoryMutation) ResetInheritStall() {
	m.inherit_stall = nil
}

// SetStallID sets the "stall_id" field.
func (m *CategoryMutation) SetStallID(u uuid.UUID) {
	m.stall_id = &u
}

// StallID returns the value of the "stall_id" field in the mutation.
func (m *CategoryMutation) StallID() (r uuid.UUID, exists bool) {
	v := m.stall_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStallID returns the old "stall_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStallID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStallID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStallID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStallID: %w", err)
	}
	return oldValue.StallID, nil
}

// ClearStallID clears the value of the "stall_id" field.
func (m *CategoryMutation) ClearStallID() {
	m.stall_id = nil
	m.clearedFields[category.FieldStallID] = struct{}{}
}

// StallIDCleared returns if the "stall_id" field was cleared in this mutation.
func (m *CategoryMutation) StallIDCleared() bool {
	_, ok := m.clearedFields[category.FieldStallID]
	return ok
}

// ResetStallID resets all changes to the "stall_id" field.
func (m *CategoryMutation) ResetStallID() {
	m.stall_id = nil
	delete(m.clearedFields, category.FieldStallID)
}

// SetProductCount sets the "product_count" field.
func (m *CategoryMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *CategoryMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *CategoryMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *CategoryMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *CategoryMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *CategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *CategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *CategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *CategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *CategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.merchant_id != nil {
		fields = append(fields, category.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, category.FieldStoreID)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.inherit_tax_rate != nil {
		fields = append(fields, category.FieldInheritTaxRate)
	}
	if m.tax_rate_id != nil {
		fields = append(fields, category.FieldTaxRateID)
	}
	if m.inherit_stall != nil {
		fields = append(fields, category.FieldInheritStall)
	}
	if m.stall_id != nil {
		fields = append(fields, category.FieldStallID)
	}
	if m.product_count != nil {
		fields = append(fields, category.FieldProductCount)
	}
	if m.sort_order != nil {
		fields = append(fields, category.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldMerchantID:
		return m.MerchantID()
	case category.FieldStoreID:
		return m.StoreID()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldInheritTaxRate:
		return m.InheritTaxRate()
	case category.FieldTaxRateID:
		return m.TaxRateID()
	case category.FieldInheritStall:
		return m.InheritStall()
	case category.FieldStallID:
		return m.StallID()
	case category.FieldProductCount:
		return m.ProductCount()
	case category.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case category.FieldStoreID:
		return m.OldStoreID(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldInheritTaxRate:
		return m.OldInheritTaxRate(ctx)
	case category.FieldTaxRateID:
		return m.OldTaxRateID(ctx)
	case category.FieldInheritStall:
		return m.OldInheritStall(ctx)
	case category.FieldStallID:
		return m.OldStallID(ctx)
	case category.FieldProductCount:
		return m.OldProductCount(ctx)
	case category.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case category.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldInheritTaxRate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritTaxRate(v)
		return nil
	case category.FieldTaxRateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRateID(v)
		return nil
	case category.FieldInheritStall:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritStall(v)
		return nil
	case category.FieldStallID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStallID(v)
		return nil
	case category.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	case category.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, category.FieldProductCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, category.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldDeletedAt:
		return m.AddedDeletedAt()
	case category.FieldProductCount:
		return m.AddedProductCount()
	case category.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case category.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	case category.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldStoreID) {
		fields = append(fields, category.FieldStoreID)
	}
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	if m.FieldCleared(category.FieldTaxRateID) {
		fields = append(fields, category.FieldTaxRateID)
	}
	if m.FieldCleared(category.FieldStallID) {
		fields = append(fields, category.FieldStallID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldStoreID:
		m.ClearStoreID()
		return nil
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	case category.FieldTaxRateID:
		m.ClearTaxRateID()
		return nil
	case category.FieldStallID:
		m.ClearStallID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case category.FieldStoreID:
		m.ResetStoreID()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldInheritTaxRate:
		m.ResetInheritTaxRate()
		return nil
	case category.FieldTaxRateID:
		m.ResetTaxRateID()
		return nil
	case category.FieldInheritStall:
		m.ResetInheritStall()
		return nil
	case category.FieldStallID:
		m.ResetStallID()
		return nil
	case category.FieldProductCount:
		m.ResetProductCount()
		return nil
	case category.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeChildren:
		return m.clearedchildren
	case category.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ProductSpecMutation represents an operation that mutates the ProductSpec nodes in the graph.
type ProductSpecMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	merchant_id      *uuid.UUID
	store_id         *uuid.UUID
	product_count    *int
	addproduct_count *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ProductSpec, error)
	predicates       []predicate.ProductSpec
}

var _ ent.Mutation = (*ProductSpecMutation)(nil)

// productspecOption allows management of the mutation configuration using functional options.
type productspecOption func(*ProductSpecMutation)

// newProductSpecMutation creates new mutation for the ProductSpec entity.
func newProductSpecMutation(c config, op Op, opts ...productspecOption) *ProductSpecMutation {
	m := &ProductSpecMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpecID sets the ID field of the mutation.
func withProductSpecID(id uuid.UUID) productspecOption {
	return func(m *ProductSpecMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpec
		)
		m.oldValue = func(ctx context.Context) (*ProductSpec, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpec sets the old ProductSpec of the mutation.
func withProductSpec(node *ProductSpec) productspecOption {
	return func(m *ProductSpecMutation) {
		m.oldValue = func(context.Context) (*ProductSpec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductSpec entities.
func (m *ProductSpecMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductSpecMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductSpecMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductSpec.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductSpecMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductSpecMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductSpecMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductSpecMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductSpecMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductSpecMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductSpecMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductSpecMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductSpecMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductSpecMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductSpecMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductSpecMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductSpecMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductSpecMutation) ResetName() {
	m.name = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductSpecMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductSpecMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductSpecMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductSpecMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductSpecMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *ProductSpecMutation) ClearStoreID() {
	m.store_id = nil
	m.clearedFields[productspec.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *ProductSpecMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[productspec.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductSpecMutation) ResetStoreID() {
	m.store_id = nil
	delete(m.clearedFields, productspec.FieldStoreID)
}

// SetProductCount sets the "product_count" field.
func (m *ProductSpecMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductSpecMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductSpecMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductSpecMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductSpecMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// Where appends a list predicates to the ProductSpecMutation builder.
func (m *ProductSpecMutation) Where(ps ...predicate.ProductSpec) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductSpecMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductSpecMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductSpec, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductSpecMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductSpecMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductSpec).
func (m *ProductSpecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpecMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, productspec.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productspec.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productspec.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, productspec.FieldName)
	}
	if m.merchant_id != nil {
		fields = append(fields, productspec.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, productspec.FieldStoreID)
	}
	if m.product_count != nil {
		fields = append(fields, productspec.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspec.FieldCreatedAt:
		return m.CreatedAt()
	case productspec.FieldUpdatedAt:
		return m.UpdatedAt()
	case productspec.FieldDeletedAt:
		return m.DeletedAt()
	case productspec.FieldName:
		return m.Name()
	case productspec.FieldMerchantID:
		return m.MerchantID()
	case productspec.FieldStoreID:
		return m.StoreID()
	case productspec.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspec.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productspec.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productspec.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productspec.FieldName:
		return m.OldName(ctx)
	case productspec.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case productspec.FieldStoreID:
		return m.OldStoreID(ctx)
	case productspec.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspec.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productspec.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productspec.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productspec.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productspec.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case productspec.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case productspec.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpecMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productspec.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, productspec.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspec.FieldDeletedAt:
		return m.AddedDeletedAt()
	case productspec.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspec.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case productspec.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpecMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productspec.FieldStoreID) {
		fields = append(fields, productspec.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpecMutation) ClearField(name string) error {
	switch name {
	case productspec.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpecMutation) ResetField(name string) error {
	switch name {
	case productspec.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productspec.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productspec.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productspec.FieldName:
		m.ResetName()
		return nil
	case productspec.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case productspec.FieldStoreID:
		m.ResetStoreID()
		return nil
	case productspec.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpecMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpecMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpecMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpecMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpecMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductSpec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpecMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductSpec edge %s", name)
}

// ProductUnitMutation represents an operation that mutates the ProductUnit nodes in the graph.
type ProductUnitMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	_type            *domain.ProductUnitType
	merchant_id      *uuid.UUID
	store_id         *uuid.UUID
	product_count    *int
	addproduct_count *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ProductUnit, error)
	predicates       []predicate.ProductUnit
}

var _ ent.Mutation = (*ProductUnitMutation)(nil)

// productunitOption allows management of the mutation configuration using functional options.
type productunitOption func(*ProductUnitMutation)

// newProductUnitMutation creates new mutation for the ProductUnit entity.
func newProductUnitMutation(c config, op Op, opts ...productunitOption) *ProductUnitMutation {
	m := &ProductUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeProductUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductUnitID sets the ID field of the mutation.
func withProductUnitID(id uuid.UUID) productunitOption {
	return func(m *ProductUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductUnit
		)
		m.oldValue = func(ctx context.Context) (*ProductUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductUnit sets the old ProductUnit of the mutation.
func withProductUnit(node *ProductUnit) productunitOption {
	return func(m *ProductUnitMutation) {
		m.oldValue = func(context.Context) (*ProductUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductUnit entities.
func (m *ProductUnitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductUnitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductUnitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductUnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductUnitMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductUnitMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductUnitMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductUnitMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductUnitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductUnitMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ProductUnitMutation) SetType(dut domain.ProductUnitType) {
	m._type = &dut
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductUnitMutation) GetType() (r domain.ProductUnitType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldType(ctx context.Context) (v domain.ProductUnitType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProductUnitMutation) ResetType() {
	m._type = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductUnitMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductUnitMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductUnitMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductUnitMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductUnitMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *ProductUnitMutation) ClearStoreID() {
	m.store_id = nil
	m.clearedFields[productunit.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *ProductUnitMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[productunit.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductUnitMutation) ResetStoreID() {
	m.store_id = nil
	delete(m.clearedFields, productunit.FieldStoreID)
}

// SetProductCount sets the "product_count" field.
func (m *ProductUnitMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductUnitMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductUnitMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductUnitMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductUnitMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// Where appends a list predicates to the ProductUnitMutation builder.
func (m *ProductUnitMutation) Where(ps ...predicate.ProductUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductUnit).
func (m *ProductUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductUnitMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, productunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productunit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productunit.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, productunit.FieldName)
	}
	if m._type != nil {
		fields = append(fields, productunit.FieldType)
	}
	if m.merchant_id != nil {
		fields = append(fields, productunit.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, productunit.FieldStoreID)
	}
	if m.product_count != nil {
		fields = append(fields, productunit.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productunit.FieldCreatedAt:
		return m.CreatedAt()
	case productunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case productunit.FieldDeletedAt:
		return m.DeletedAt()
	case productunit.FieldName:
		return m.Name()
	case productunit.FieldType:
		return m.GetType()
	case productunit.FieldMerchantID:
		return m.MerchantID()
	case productunit.FieldStoreID:
		return m.StoreID()
	case productunit.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productunit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productunit.FieldName:
		return m.OldName(ctx)
	case productunit.FieldType:
		return m.OldType(ctx)
	case productunit.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case productunit.FieldStoreID:
		return m.OldStoreID(ctx)
	case productunit.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productunit.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productunit.FieldType:
		v, ok := value.(domain.ProductUnitType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case productunit.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case productunit.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case productunit.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductUnitMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productunit.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, productunit.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productunit.FieldDeletedAt:
		return m.AddedDeletedAt()
	case productunit.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productunit.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case productunit.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productunit.FieldStoreID) {
		fields = append(fields, productunit.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductUnitMutation) ClearField(name string) error {
	switch name {
	case productunit.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown ProductUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductUnitMutation) ResetField(name string) error {
	switch name {
	case productunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productunit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productunit.FieldName:
		m.ResetName()
		return nil
	case productunit.FieldType:
		m.ResetType()
		return nil
	case productunit.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case productunit.FieldStoreID:
		m.ResetStoreID()
		return nil
	case productunit.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductUnitMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductUnitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductUnitMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductUnitMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductUnitMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductUnit edge %s", name)
}
