// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"gitlab.jiguang.dev/pos-dine/dine/domain"
	"gitlab.jiguang.dev/pos-dine/dine/ent/additionalfee"
	"gitlab.jiguang.dev/pos-dine/dine/ent/adminuser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/backenduser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/category"
	"gitlab.jiguang.dev/pos-dine/dine/ent/city"
	"gitlab.jiguang.dev/pos-dine/dine/ent/country"
	"gitlab.jiguang.dev/pos-dine/dine/ent/department"
	"gitlab.jiguang.dev/pos-dine/dine/ent/device"
	"gitlab.jiguang.dev/pos-dine/dine/ent/district"
	"gitlab.jiguang.dev/pos-dine/dine/ent/menu"
	"gitlab.jiguang.dev/pos-dine/dine/ent/menuitem"
	"gitlab.jiguang.dev/pos-dine/dine/ent/merchant"
	"gitlab.jiguang.dev/pos-dine/dine/ent/merchantbusinesstype"
	"gitlab.jiguang.dev/pos-dine/dine/ent/merchantrenewal"
	"gitlab.jiguang.dev/pos-dine/dine/ent/order"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderproduct"
	"gitlab.jiguang.dev/pos-dine/dine/ent/paymentmethod"
	"gitlab.jiguang.dev/pos-dine/dine/ent/predicate"
	"gitlab.jiguang.dev/pos-dine/dine/ent/product"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productattr"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productattritem"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productattrrelation"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productspec"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productspecrelation"
	"gitlab.jiguang.dev/pos-dine/dine/ent/producttag"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productunit"
	"gitlab.jiguang.dev/pos-dine/dine/ent/province"
	"gitlab.jiguang.dev/pos-dine/dine/ent/remark"
	"gitlab.jiguang.dev/pos-dine/dine/ent/remarkcategory"
	"gitlab.jiguang.dev/pos-dine/dine/ent/role"
	"gitlab.jiguang.dev/pos-dine/dine/ent/setmealdetail"
	"gitlab.jiguang.dev/pos-dine/dine/ent/setmealgroup"
	"gitlab.jiguang.dev/pos-dine/dine/ent/stall"
	"gitlab.jiguang.dev/pos-dine/dine/ent/store"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeuser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/taxfee"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdditionalFee        = "AdditionalFee"
	TypeAdminUser            = "AdminUser"
	TypeBackendUser          = "BackendUser"
	TypeCategory             = "Category"
	TypeCity                 = "City"
	TypeCountry              = "Country"
	TypeDepartment           = "Department"
	TypeDevice               = "Device"
	TypeDistrict             = "District"
	TypeMenu                 = "Menu"
	TypeMenuItem             = "MenuItem"
	TypeMerchant             = "Merchant"
	TypeMerchantBusinessType = "MerchantBusinessType"
	TypeMerchantRenewal      = "MerchantRenewal"
	TypeOrder                = "Order"
	TypeOrderProduct         = "OrderProduct"
	TypePaymentMethod        = "PaymentMethod"
	TypeProduct              = "Product"
	TypeProductAttr          = "ProductAttr"
	TypeProductAttrItem      = "ProductAttrItem"
	TypeProductAttrRelation  = "ProductAttrRelation"
	TypeProductSpec          = "ProductSpec"
	TypeProductSpecRelation  = "ProductSpecRelation"
	TypeProductTag           = "ProductTag"
	TypeProductUnit          = "ProductUnit"
	TypeProvince             = "Province"
	TypeRemark               = "Remark"
	TypeRemarkCategory       = "RemarkCategory"
	TypeRole                 = "Role"
	TypeSetMealDetail        = "SetMealDetail"
	TypeSetMealGroup         = "SetMealGroup"
	TypeStall                = "Stall"
	TypeStore                = "Store"
	TypeStoreUser            = "StoreUser"
	TypeTaxFee               = "TaxFee"
)

// AdditionalFeeMutation represents an operation that mutates the AdditionalFee nodes in the graph.
type AdditionalFeeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *int64
	adddeleted_at         *int64
	name                  *string
	fee_type              *domain.AdditionalFeeType
	fee_category          *domain.AdditionalCategory
	charge_mode           *domain.AdditionalFeeChargeMode
	fee_value             *decimal.Decimal
	include_in_receivable *bool
	taxable               *bool
	discount_scope        *domain.AdditionalFeeDiscountScope
	order_channels        *[]domain.OrderChannel
	appendorder_channels  []domain.OrderChannel
	dining_ways           *[]domain.DiningWay
	appenddining_ways     []domain.DiningWay
	enabled               *bool
	sort_order            *int
	addsort_order         *int
	clearedFields         map[string]struct{}
	merchant              *uuid.UUID
	clearedmerchant       bool
	store                 *uuid.UUID
	clearedstore          bool
	done                  bool
	oldValue              func(context.Context) (*AdditionalFee, error)
	predicates            []predicate.AdditionalFee
}

var _ ent.Mutation = (*AdditionalFeeMutation)(nil)

// additionalfeeOption allows management of the mutation configuration using functional options.
type additionalfeeOption func(*AdditionalFeeMutation)

// newAdditionalFeeMutation creates new mutation for the AdditionalFee entity.
func newAdditionalFeeMutation(c config, op Op, opts ...additionalfeeOption) *AdditionalFeeMutation {
	m := &AdditionalFeeMutation{
		config:        c,
		op:            op,
		typ:           TypeAdditionalFee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdditionalFeeID sets the ID field of the mutation.
func withAdditionalFeeID(id uuid.UUID) additionalfeeOption {
	return func(m *AdditionalFeeMutation) {
		var (
			err   error
			once  sync.Once
			value *AdditionalFee
		)
		m.oldValue = func(ctx context.Context) (*AdditionalFee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdditionalFee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdditionalFee sets the old AdditionalFee of the mutation.
func withAdditionalFee(node *AdditionalFee) additionalfeeOption {
	return func(m *AdditionalFeeMutation) {
		m.oldValue = func(context.Context) (*AdditionalFee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdditionalFeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdditionalFeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdditionalFee entities.
func (m *AdditionalFeeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdditionalFeeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdditionalFeeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdditionalFee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdditionalFeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdditionalFeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdditionalFeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdditionalFeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdditionalFeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdditionalFeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdditionalFeeMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdditionalFeeMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AdditionalFeeMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AdditionalFeeMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdditionalFeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *AdditionalFeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdditionalFeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdditionalFeeMutation) ResetName() {
	m.name = nil
}

// SetFeeType sets the "fee_type" field.
func (m *AdditionalFeeMutation) SetFeeType(dft domain.AdditionalFeeType) {
	m.fee_type = &dft
}

// FeeType returns the value of the "fee_type" field in the mutation.
func (m *AdditionalFeeMutation) FeeType() (r domain.AdditionalFeeType, exists bool) {
	v := m.fee_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeType returns the old "fee_type" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldFeeType(ctx context.Context) (v domain.AdditionalFeeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeType: %w", err)
	}
	return oldValue.FeeType, nil
}

// ResetFeeType resets all changes to the "fee_type" field.
func (m *AdditionalFeeMutation) ResetFeeType() {
	m.fee_type = nil
}

// SetFeeCategory sets the "fee_category" field.
func (m *AdditionalFeeMutation) SetFeeCategory(dc domain.AdditionalCategory) {
	m.fee_category = &dc
}

// FeeCategory returns the value of the "fee_category" field in the mutation.
func (m *AdditionalFeeMutation) FeeCategory() (r domain.AdditionalCategory, exists bool) {
	v := m.fee_category
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeCategory returns the old "fee_category" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldFeeCategory(ctx context.Context) (v domain.AdditionalCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeCategory: %w", err)
	}
	return oldValue.FeeCategory, nil
}

// ResetFeeCategory resets all changes to the "fee_category" field.
func (m *AdditionalFeeMutation) ResetFeeCategory() {
	m.fee_category = nil
}

// SetChargeMode sets the "charge_mode" field.
func (m *AdditionalFeeMutation) SetChargeMode(dfcm domain.AdditionalFeeChargeMode) {
	m.charge_mode = &dfcm
}

// ChargeMode returns the value of the "charge_mode" field in the mutation.
func (m *AdditionalFeeMutation) ChargeMode() (r domain.AdditionalFeeChargeMode, exists bool) {
	v := m.charge_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeMode returns the old "charge_mode" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldChargeMode(ctx context.Context) (v domain.AdditionalFeeChargeMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeMode: %w", err)
	}
	return oldValue.ChargeMode, nil
}

// ResetChargeMode resets all changes to the "charge_mode" field.
func (m *AdditionalFeeMutation) ResetChargeMode() {
	m.charge_mode = nil
}

// SetFeeValue sets the "fee_value" field.
func (m *AdditionalFeeMutation) SetFeeValue(d decimal.Decimal) {
	m.fee_value = &d
}

// FeeValue returns the value of the "fee_value" field in the mutation.
func (m *AdditionalFeeMutation) FeeValue() (r decimal.Decimal, exists bool) {
	v := m.fee_value
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeValue returns the old "fee_value" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldFeeValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeValue: %w", err)
	}
	return oldValue.FeeValue, nil
}

// ResetFeeValue resets all changes to the "fee_value" field.
func (m *AdditionalFeeMutation) ResetFeeValue() {
	m.fee_value = nil
}

// SetIncludeInReceivable sets the "include_in_receivable" field.
func (m *AdditionalFeeMutation) SetIncludeInReceivable(b bool) {
	m.include_in_receivable = &b
}

// IncludeInReceivable returns the value of the "include_in_receivable" field in the mutation.
func (m *AdditionalFeeMutation) IncludeInReceivable() (r bool, exists bool) {
	v := m.include_in_receivable
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeInReceivable returns the old "include_in_receivable" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldIncludeInReceivable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludeInReceivable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludeInReceivable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeInReceivable: %w", err)
	}
	return oldValue.IncludeInReceivable, nil
}

// ResetIncludeInReceivable resets all changes to the "include_in_receivable" field.
func (m *AdditionalFeeMutation) ResetIncludeInReceivable() {
	m.include_in_receivable = nil
}

// SetTaxable sets the "taxable" field.
func (m *AdditionalFeeMutation) SetTaxable(b bool) {
	m.taxable = &b
}

// Taxable returns the value of the "taxable" field in the mutation.
func (m *AdditionalFeeMutation) Taxable() (r bool, exists bool) {
	v := m.taxable
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxable returns the old "taxable" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldTaxable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxable: %w", err)
	}
	return oldValue.Taxable, nil
}

// ResetTaxable resets all changes to the "taxable" field.
func (m *AdditionalFeeMutation) ResetTaxable() {
	m.taxable = nil
}

// SetDiscountScope sets the "discount_scope" field.
func (m *AdditionalFeeMutation) SetDiscountScope(dfds domain.AdditionalFeeDiscountScope) {
	m.discount_scope = &dfds
}

// DiscountScope returns the value of the "discount_scope" field in the mutation.
func (m *AdditionalFeeMutation) DiscountScope() (r domain.AdditionalFeeDiscountScope, exists bool) {
	v := m.discount_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountScope returns the old "discount_scope" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldDiscountScope(ctx context.Context) (v domain.AdditionalFeeDiscountScope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountScope: %w", err)
	}
	return oldValue.DiscountScope, nil
}

// ResetDiscountScope resets all changes to the "discount_scope" field.
func (m *AdditionalFeeMutation) ResetDiscountScope() {
	m.discount_scope = nil
}

// SetOrderChannels sets the "order_channels" field.
func (m *AdditionalFeeMutation) SetOrderChannels(dc []domain.OrderChannel) {
	m.order_channels = &dc
	m.appendorder_channels = nil
}

// OrderChannels returns the value of the "order_channels" field in the mutation.
func (m *AdditionalFeeMutation) OrderChannels() (r []domain.OrderChannel, exists bool) {
	v := m.order_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderChannels returns the old "order_channels" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldOrderChannels(ctx context.Context) (v []domain.OrderChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderChannels: %w", err)
	}
	return oldValue.OrderChannels, nil
}

// AppendOrderChannels adds dc to the "order_channels" field.
func (m *AdditionalFeeMutation) AppendOrderChannels(dc []domain.OrderChannel) {
	m.appendorder_channels = append(m.appendorder_channels, dc...)
}

// AppendedOrderChannels returns the list of values that were appended to the "order_channels" field in this mutation.
func (m *AdditionalFeeMutation) AppendedOrderChannels() ([]domain.OrderChannel, bool) {
	if len(m.appendorder_channels) == 0 {
		return nil, false
	}
	return m.appendorder_channels, true
}

// ResetOrderChannels resets all changes to the "order_channels" field.
func (m *AdditionalFeeMutation) ResetOrderChannels() {
	m.order_channels = nil
	m.appendorder_channels = nil
}

// SetDiningWays sets the "dining_ways" field.
func (m *AdditionalFeeMutation) SetDiningWays(dw []domain.DiningWay) {
	m.dining_ways = &dw
	m.appenddining_ways = nil
}

// DiningWays returns the value of the "dining_ways" field in the mutation.
func (m *AdditionalFeeMutation) DiningWays() (r []domain.DiningWay, exists bool) {
	v := m.dining_ways
	if v == nil {
		return
	}
	return *v, true
}

// OldDiningWays returns the old "dining_ways" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldDiningWays(ctx context.Context) (v []domain.DiningWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiningWays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiningWays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiningWays: %w", err)
	}
	return oldValue.DiningWays, nil
}

// AppendDiningWays adds dw to the "dining_ways" field.
func (m *AdditionalFeeMutation) AppendDiningWays(dw []domain.DiningWay) {
	m.appenddining_ways = append(m.appenddining_ways, dw...)
}

// AppendedDiningWays returns the list of values that were appended to the "dining_ways" field in this mutation.
func (m *AdditionalFeeMutation) AppendedDiningWays() ([]domain.DiningWay, bool) {
	if len(m.appenddining_ways) == 0 {
		return nil, false
	}
	return m.appenddining_ways, true
}

// ResetDiningWays resets all changes to the "dining_ways" field.
func (m *AdditionalFeeMutation) ResetDiningWays() {
	m.dining_ways = nil
	m.appenddining_ways = nil
}

// SetEnabled sets the "enabled" field.
func (m *AdditionalFeeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AdditionalFeeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AdditionalFeeMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *AdditionalFeeMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AdditionalFeeMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *AdditionalFeeMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AdditionalFeeMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AdditionalFeeMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *AdditionalFeeMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *AdditionalFeeMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *AdditionalFeeMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[additionalfee.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *AdditionalFeeMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[additionalfee.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *AdditionalFeeMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, additionalfee.FieldMerchantID)
}

// SetStoreID sets the "store_id" field.
func (m *AdditionalFeeMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AdditionalFeeMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the AdditionalFee entity.
// If the AdditionalFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdditionalFeeMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *AdditionalFeeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[additionalfee.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *AdditionalFeeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[additionalfee.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AdditionalFeeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, additionalfee.FieldStoreID)
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *AdditionalFeeMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[additionalfee.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *AdditionalFeeMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *AdditionalFeeMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *AdditionalFeeMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *AdditionalFeeMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[additionalfee.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *AdditionalFeeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *AdditionalFeeMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AdditionalFeeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the AdditionalFeeMutation builder.
func (m *AdditionalFeeMutation) Where(ps ...predicate.AdditionalFee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdditionalFeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdditionalFeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdditionalFee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdditionalFeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdditionalFeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdditionalFee).
func (m *AdditionalFeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdditionalFeeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, additionalfee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, additionalfee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, additionalfee.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, additionalfee.FieldName)
	}
	if m.fee_type != nil {
		fields = append(fields, additionalfee.FieldFeeType)
	}
	if m.fee_category != nil {
		fields = append(fields, additionalfee.FieldFeeCategory)
	}
	if m.charge_mode != nil {
		fields = append(fields, additionalfee.FieldChargeMode)
	}
	if m.fee_value != nil {
		fields = append(fields, additionalfee.FieldFeeValue)
	}
	if m.include_in_receivable != nil {
		fields = append(fields, additionalfee.FieldIncludeInReceivable)
	}
	if m.taxable != nil {
		fields = append(fields, additionalfee.FieldTaxable)
	}
	if m.discount_scope != nil {
		fields = append(fields, additionalfee.FieldDiscountScope)
	}
	if m.order_channels != nil {
		fields = append(fields, additionalfee.FieldOrderChannels)
	}
	if m.dining_ways != nil {
		fields = append(fields, additionalfee.FieldDiningWays)
	}
	if m.enabled != nil {
		fields = append(fields, additionalfee.FieldEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, additionalfee.FieldSortOrder)
	}
	if m.merchant != nil {
		fields = append(fields, additionalfee.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, additionalfee.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdditionalFeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case additionalfee.FieldCreatedAt:
		return m.CreatedAt()
	case additionalfee.FieldUpdatedAt:
		return m.UpdatedAt()
	case additionalfee.FieldDeletedAt:
		return m.DeletedAt()
	case additionalfee.FieldName:
		return m.Name()
	case additionalfee.FieldFeeType:
		return m.FeeType()
	case additionalfee.FieldFeeCategory:
		return m.FeeCategory()
	case additionalfee.FieldChargeMode:
		return m.ChargeMode()
	case additionalfee.FieldFeeValue:
		return m.FeeValue()
	case additionalfee.FieldIncludeInReceivable:
		return m.IncludeInReceivable()
	case additionalfee.FieldTaxable:
		return m.Taxable()
	case additionalfee.FieldDiscountScope:
		return m.DiscountScope()
	case additionalfee.FieldOrderChannels:
		return m.OrderChannels()
	case additionalfee.FieldDiningWays:
		return m.DiningWays()
	case additionalfee.FieldEnabled:
		return m.Enabled()
	case additionalfee.FieldSortOrder:
		return m.SortOrder()
	case additionalfee.FieldMerchantID:
		return m.MerchantID()
	case additionalfee.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdditionalFeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case additionalfee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case additionalfee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case additionalfee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case additionalfee.FieldName:
		return m.OldName(ctx)
	case additionalfee.FieldFeeType:
		return m.OldFeeType(ctx)
	case additionalfee.FieldFeeCategory:
		return m.OldFeeCategory(ctx)
	case additionalfee.FieldChargeMode:
		return m.OldChargeMode(ctx)
	case additionalfee.FieldFeeValue:
		return m.OldFeeValue(ctx)
	case additionalfee.FieldIncludeInReceivable:
		return m.OldIncludeInReceivable(ctx)
	case additionalfee.FieldTaxable:
		return m.OldTaxable(ctx)
	case additionalfee.FieldDiscountScope:
		return m.OldDiscountScope(ctx)
	case additionalfee.FieldOrderChannels:
		return m.OldOrderChannels(ctx)
	case additionalfee.FieldDiningWays:
		return m.OldDiningWays(ctx)
	case additionalfee.FieldEnabled:
		return m.OldEnabled(ctx)
	case additionalfee.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case additionalfee.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case additionalfee.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown AdditionalFee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdditionalFeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case additionalfee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case additionalfee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case additionalfee.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case additionalfee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case additionalfee.FieldFeeType:
		v, ok := value.(domain.AdditionalFeeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeType(v)
		return nil
	case additionalfee.FieldFeeCategory:
		v, ok := value.(domain.AdditionalCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeCategory(v)
		return nil
	case additionalfee.FieldChargeMode:
		v, ok := value.(domain.AdditionalFeeChargeMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeMode(v)
		return nil
	case additionalfee.FieldFeeValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeValue(v)
		return nil
	case additionalfee.FieldIncludeInReceivable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeInReceivable(v)
		return nil
	case additionalfee.FieldTaxable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxable(v)
		return nil
	case additionalfee.FieldDiscountScope:
		v, ok := value.(domain.AdditionalFeeDiscountScope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountScope(v)
		return nil
	case additionalfee.FieldOrderChannels:
		v, ok := value.([]domain.OrderChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderChannels(v)
		return nil
	case additionalfee.FieldDiningWays:
		v, ok := value.([]domain.DiningWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiningWays(v)
		return nil
	case additionalfee.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case additionalfee.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case additionalfee.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case additionalfee.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown AdditionalFee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdditionalFeeMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, additionalfee.FieldDeletedAt)
	}
	if m.addsort_order != nil {
		fields = append(fields, additionalfee.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdditionalFeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case additionalfee.FieldDeletedAt:
		return m.AddedDeletedAt()
	case additionalfee.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdditionalFeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case additionalfee.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case additionalfee.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AdditionalFee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdditionalFeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(additionalfee.FieldMerchantID) {
		fields = append(fields, additionalfee.FieldMerchantID)
	}
	if m.FieldCleared(additionalfee.FieldStoreID) {
		fields = append(fields, additionalfee.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdditionalFeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdditionalFeeMutation) ClearField(name string) error {
	switch name {
	case additionalfee.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case additionalfee.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown AdditionalFee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdditionalFeeMutation) ResetField(name string) error {
	switch name {
	case additionalfee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case additionalfee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case additionalfee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case additionalfee.FieldName:
		m.ResetName()
		return nil
	case additionalfee.FieldFeeType:
		m.ResetFeeType()
		return nil
	case additionalfee.FieldFeeCategory:
		m.ResetFeeCategory()
		return nil
	case additionalfee.FieldChargeMode:
		m.ResetChargeMode()
		return nil
	case additionalfee.FieldFeeValue:
		m.ResetFeeValue()
		return nil
	case additionalfee.FieldIncludeInReceivable:
		m.ResetIncludeInReceivable()
		return nil
	case additionalfee.FieldTaxable:
		m.ResetTaxable()
		return nil
	case additionalfee.FieldDiscountScope:
		m.ResetDiscountScope()
		return nil
	case additionalfee.FieldOrderChannels:
		m.ResetOrderChannels()
		return nil
	case additionalfee.FieldDiningWays:
		m.ResetDiningWays()
		return nil
	case additionalfee.FieldEnabled:
		m.ResetEnabled()
		return nil
	case additionalfee.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case additionalfee.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case additionalfee.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown AdditionalFee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdditionalFeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.merchant != nil {
		edges = append(edges, additionalfee.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, additionalfee.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdditionalFeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case additionalfee.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case additionalfee.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdditionalFeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdditionalFeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdditionalFeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmerchant {
		edges = append(edges, additionalfee.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, additionalfee.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdditionalFeeMutation) EdgeCleared(name string) bool {
	switch name {
	case additionalfee.EdgeMerchant:
		return m.clearedmerchant
	case additionalfee.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdditionalFeeMutation) ClearEdge(name string) error {
	switch name {
	case additionalfee.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case additionalfee.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown AdditionalFee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdditionalFeeMutation) ResetEdge(name string) error {
	switch name {
	case additionalfee.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case additionalfee.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown AdditionalFee edge %s", name)
}

// AdminUserMutation represents an operation that mutates the AdminUser nodes in the graph.
type AdminUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AdminUser, error)
	predicates      []predicate.AdminUser
}

var _ ent.Mutation = (*AdminUserMutation)(nil)

// adminuserOption allows management of the mutation configuration using functional options.
type adminuserOption func(*AdminUserMutation)

// newAdminUserMutation creates new mutation for the AdminUser entity.
func newAdminUserMutation(c config, op Op, opts ...adminuserOption) *AdminUserMutation {
	m := &AdminUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminUserID sets the ID field of the mutation.
func withAdminUserID(id uuid.UUID) adminuserOption {
	return func(m *AdminUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminUser
		)
		m.oldValue = func(ctx context.Context) (*AdminUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminUser sets the old AdminUser of the mutation.
func withAdminUser(node *AdminUser) adminuserOption {
	return func(m *AdminUserMutation) {
		m.oldValue = func(context.Context) (*AdminUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminUser entities.
func (m *AdminUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *AdminUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AdminUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *AdminUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *AdminUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *AdminUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *AdminUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AdminUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AdminUserMutation) ResetNickname() {
	m.nickname = nil
}

// Where appends a list predicates to the AdminUserMutation builder.
func (m *AdminUserMutation) Where(ps ...predicate.AdminUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminUser).
func (m *AdminUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminuser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, adminuser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, adminuser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, adminuser.FieldNickname)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.CreatedAt()
	case adminuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case adminuser.FieldDeletedAt:
		return m.DeletedAt()
	case adminuser.FieldUsername:
		return m.Username()
	case adminuser.FieldHashedPassword:
		return m.HashedPassword()
	case adminuser.FieldNickname:
		return m.Nickname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adminuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminuser.FieldUsername:
		return m.OldUsername(ctx)
	case adminuser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case adminuser.FieldNickname:
		return m.OldNickname(ctx)
	}
	return nil, fmt.Errorf("unknown AdminUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adminuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case adminuser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case adminuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, adminuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminUserMutation) ResetField(name string) error {
	switch name {
	case adminuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adminuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminuser.FieldUsername:
		m.ResetUsername()
		return nil
	case adminuser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case adminuser.FieldNickname:
		m.ResetNickname()
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdminUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdminUser edge %s", name)
}

// BackendUserMutation represents an operation that mutates the BackendUser nodes in the graph.
type BackendUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	merchant_id     *uuid.UUID
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*BackendUser, error)
	predicates      []predicate.BackendUser
}

var _ ent.Mutation = (*BackendUserMutation)(nil)

// backenduserOption allows management of the mutation configuration using functional options.
type backenduserOption func(*BackendUserMutation)

// newBackendUserMutation creates new mutation for the BackendUser entity.
func newBackendUserMutation(c config, op Op, opts ...backenduserOption) *BackendUserMutation {
	m := &BackendUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBackendUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackendUserID sets the ID field of the mutation.
func withBackendUserID(id uuid.UUID) backenduserOption {
	return func(m *BackendUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BackendUser
		)
		m.oldValue = func(ctx context.Context) (*BackendUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackendUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackendUser sets the old BackendUser of the mutation.
func withBackendUser(node *BackendUser) backenduserOption {
	return func(m *BackendUserMutation) {
		m.oldValue = func(context.Context) (*BackendUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackendUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackendUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BackendUser entities.
func (m *BackendUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackendUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackendUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackendUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BackendUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackendUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackendUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackendUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackendUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackendUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BackendUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BackendUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *BackendUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BackendUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BackendUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *BackendUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *BackendUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *BackendUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *BackendUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *BackendUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *BackendUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *BackendUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *BackendUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *BackendUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *BackendUserMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *BackendUserMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the BackendUser entity.
// If the BackendUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackendUserMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *BackendUserMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// Where appends a list predicates to the BackendUserMutation builder.
func (m *BackendUserMutation) Where(ps ...predicate.BackendUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackendUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackendUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackendUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackendUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackendUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackendUser).
func (m *BackendUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackendUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, backenduser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backenduser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, backenduser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, backenduser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, backenduser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, backenduser.FieldNickname)
	}
	if m.merchant_id != nil {
		fields = append(fields, backenduser.FieldMerchantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackendUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backenduser.FieldCreatedAt:
		return m.CreatedAt()
	case backenduser.FieldUpdatedAt:
		return m.UpdatedAt()
	case backenduser.FieldDeletedAt:
		return m.DeletedAt()
	case backenduser.FieldUsername:
		return m.Username()
	case backenduser.FieldHashedPassword:
		return m.HashedPassword()
	case backenduser.FieldNickname:
		return m.Nickname()
	case backenduser.FieldMerchantID:
		return m.MerchantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackendUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backenduser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backenduser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backenduser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case backenduser.FieldUsername:
		return m.OldUsername(ctx)
	case backenduser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case backenduser.FieldNickname:
		return m.OldNickname(ctx)
	case backenduser.FieldMerchantID:
		return m.OldMerchantID(ctx)
	}
	return nil, fmt.Errorf("unknown BackendUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackendUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backenduser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backenduser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case backenduser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case backenduser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case backenduser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case backenduser.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	}
	return fmt.Errorf("unknown BackendUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackendUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, backenduser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackendUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backenduser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackendUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backenduser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackendUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackendUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackendUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackendUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BackendUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackendUserMutation) ResetField(name string) error {
	switch name {
	case backenduser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backenduser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backenduser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case backenduser.FieldUsername:
		m.ResetUsername()
		return nil
	case backenduser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case backenduser.FieldNickname:
		m.ResetNickname()
		return nil
	case backenduser.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	}
	return fmt.Errorf("unknown BackendUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackendUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackendUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackendUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackendUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackendUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackendUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackendUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BackendUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackendUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BackendUser edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	merchant_id      *uuid.UUID
	store_id         *uuid.UUID
	inherit_tax_rate *bool
	tax_rate_id      *uuid.UUID
	inherit_stall    *bool
	stall_id         *uuid.UUID
	product_count    *int
	addproduct_count *int
	sort_order       *int
	addsort_order    *int
	clearedFields    map[string]struct{}
	children         map[uuid.UUID]struct{}
	removedchildren  map[uuid.UUID]struct{}
	clearedchildren  bool
	parent           *uuid.UUID
	clearedparent    bool
	products         map[uuid.UUID]struct{}
	removedproducts  map[uuid.UUID]struct{}
	clearedproducts  bool
	done             bool
	oldValue         func(context.Context) (*Category, error)
	predicates       []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uuid.UUID) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *CategoryMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CategoryMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *CategoryMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *CategoryMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *CategoryMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *CategoryMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *CategoryMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *CategoryMutation) ResetStoreID() {
	m.store_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
}

// SetInheritTaxRate sets the "inherit_tax_rate" field.
func (m *CategoryMutation) SetInheritTaxRate(b bool) {
	m.inherit_tax_rate = &b
}

// InheritTaxRate returns the value of the "inherit_tax_rate" field in the mutation.
func (m *CategoryMutation) InheritTaxRate() (r bool, exists bool) {
	v := m.inherit_tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritTaxRate returns the old "inherit_tax_rate" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldInheritTaxRate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritTaxRate: %w", err)
	}
	return oldValue.InheritTaxRate, nil
}

// ResetInheritTaxRate resets all changes to the "inherit_tax_rate" field.
func (m *CategoryMutation) ResetInheritTaxRate() {
	m.inherit_tax_rate = nil
}

// SetTaxRateID sets the "tax_rate_id" field.
func (m *CategoryMutation) SetTaxRateID(u uuid.UUID) {
	m.tax_rate_id = &u
}

// TaxRateID returns the value of the "tax_rate_id" field in the mutation.
func (m *CategoryMutation) TaxRateID() (r uuid.UUID, exists bool) {
	v := m.tax_rate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRateID returns the old "tax_rate_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldTaxRateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRateID: %w", err)
	}
	return oldValue.TaxRateID, nil
}

// ClearTaxRateID clears the value of the "tax_rate_id" field.
func (m *CategoryMutation) ClearTaxRateID() {
	m.tax_rate_id = nil
	m.clearedFields[category.FieldTaxRateID] = struct{}{}
}

// TaxRateIDCleared returns if the "tax_rate_id" field was cleared in this mutation.
func (m *CategoryMutation) TaxRateIDCleared() bool {
	_, ok := m.clearedFields[category.FieldTaxRateID]
	return ok
}

// ResetTaxRateID resets all changes to the "tax_rate_id" field.
func (m *CategoryMutation) ResetTaxRateID() {
	m.tax_rate_id = nil
	delete(m.clearedFields, category.FieldTaxRateID)
}

// SetInheritStall sets the "inherit_stall" field.
func (m *CategoryMutation) SetInheritStall(b bool) {
	m.inherit_stall = &b
}

// InheritStall returns the value of the "inherit_stall" field in the mutation.
func (m *CategoryMutation) InheritStall() (r bool, exists bool) {
	v := m.inherit_stall
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritStall returns the old "inherit_stall" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldInheritStall(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritStall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritStall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritStall: %w", err)
	}
	return oldValue.InheritStall, nil
}

// ResetInheritStall resets all changes to the "inherit_stall" field.
func (m *CategoryMutation) ResetInheritStall() {
	m.inherit_stall = nil
}

// SetStallID sets the "stall_id" field.
func (m *CategoryMutation) SetStallID(u uuid.UUID) {
	m.stall_id = &u
}

// StallID returns the value of the "stall_id" field in the mutation.
func (m *CategoryMutation) StallID() (r uuid.UUID, exists bool) {
	v := m.stall_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStallID returns the old "stall_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStallID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStallID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStallID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStallID: %w", err)
	}
	return oldValue.StallID, nil
}

// ClearStallID clears the value of the "stall_id" field.
func (m *CategoryMutation) ClearStallID() {
	m.stall_id = nil
	m.clearedFields[category.FieldStallID] = struct{}{}
}

// StallIDCleared returns if the "stall_id" field was cleared in this mutation.
func (m *CategoryMutation) StallIDCleared() bool {
	_, ok := m.clearedFields[category.FieldStallID]
	return ok
}

// ResetStallID resets all changes to the "stall_id" field.
func (m *CategoryMutation) ResetStallID() {
	m.stall_id = nil
	delete(m.clearedFields, category.FieldStallID)
}

// SetProductCount sets the "product_count" field.
func (m *CategoryMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *CategoryMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *CategoryMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *CategoryMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *CategoryMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *CategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *CategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *CategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *CategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *CategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CategoryMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CategoryMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CategoryMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CategoryMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.merchant_id != nil {
		fields = append(fields, category.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, category.FieldStoreID)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.inherit_tax_rate != nil {
		fields = append(fields, category.FieldInheritTaxRate)
	}
	if m.tax_rate_id != nil {
		fields = append(fields, category.FieldTaxRateID)
	}
	if m.inherit_stall != nil {
		fields = append(fields, category.FieldInheritStall)
	}
	if m.stall_id != nil {
		fields = append(fields, category.FieldStallID)
	}
	if m.product_count != nil {
		fields = append(fields, category.FieldProductCount)
	}
	if m.sort_order != nil {
		fields = append(fields, category.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldMerchantID:
		return m.MerchantID()
	case category.FieldStoreID:
		return m.StoreID()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldInheritTaxRate:
		return m.InheritTaxRate()
	case category.FieldTaxRateID:
		return m.TaxRateID()
	case category.FieldInheritStall:
		return m.InheritStall()
	case category.FieldStallID:
		return m.StallID()
	case category.FieldProductCount:
		return m.ProductCount()
	case category.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case category.FieldStoreID:
		return m.OldStoreID(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldInheritTaxRate:
		return m.OldInheritTaxRate(ctx)
	case category.FieldTaxRateID:
		return m.OldTaxRateID(ctx)
	case category.FieldInheritStall:
		return m.OldInheritStall(ctx)
	case category.FieldStallID:
		return m.OldStallID(ctx)
	case category.FieldProductCount:
		return m.OldProductCount(ctx)
	case category.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case category.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldInheritTaxRate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritTaxRate(v)
		return nil
	case category.FieldTaxRateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRateID(v)
		return nil
	case category.FieldInheritStall:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritStall(v)
		return nil
	case category.FieldStallID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStallID(v)
		return nil
	case category.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	case category.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, category.FieldProductCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, category.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldDeletedAt:
		return m.AddedDeletedAt()
	case category.FieldProductCount:
		return m.AddedProductCount()
	case category.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case category.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	case category.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldTaxRateID) {
		fields = append(fields, category.FieldTaxRateID)
	}
	if m.FieldCleared(category.FieldStallID) {
		fields = append(fields, category.FieldStallID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldTaxRateID:
		m.ClearTaxRateID()
		return nil
	case category.FieldStallID:
		m.ClearStallID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case category.FieldStoreID:
		m.ResetStoreID()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldInheritTaxRate:
		m.ResetInheritTaxRate()
		return nil
	case category.FieldTaxRateID:
		m.ResetTaxRateID()
		return nil
	case category.FieldInheritStall:
		m.ResetInheritStall()
		return nil
	case category.FieldStallID:
		m.ResetStallID()
		return nil
	case category.FieldProductCount:
		m.ResetProductCount()
		return nil
	case category.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.products != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.removedproducts != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedproducts {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeChildren:
		return m.clearedchildren
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	sort             *int
	addsort          *int
	clearedFields    map[string]struct{}
	country          *uuid.UUID
	clearedcountry   bool
	province         *uuid.UUID
	clearedprovince  bool
	districts        map[uuid.UUID]struct{}
	removeddistricts map[uuid.UUID]struct{}
	cleareddistricts bool
	merchants        map[uuid.UUID]struct{}
	removedmerchants map[uuid.UUID]struct{}
	clearedmerchants bool
	stores           map[uuid.UUID]struct{}
	removedstores    map[uuid.UUID]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*City, error)
	predicates       []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id uuid.UUID) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of City entities.
func (m *CityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CityMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CityMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *CityMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CityMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCountryID sets the "country_id" field.
func (m *CityMutation) SetCountryID(u uuid.UUID) {
	m.country = &u
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *CityMutation) CountryID() (r uuid.UUID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCountryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *CityMutation) ResetCountryID() {
	m.country = nil
}

// SetProvinceID sets the "province_id" field.
func (m *CityMutation) SetProvinceID(u uuid.UUID) {
	m.province = &u
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *CityMutation) ProvinceID() (r uuid.UUID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldProvinceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *CityMutation) ResetProvinceID() {
	m.province = nil
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *CityMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *CityMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *CityMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *CityMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *CityMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *CityMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[city.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *CityMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *CityMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *CityMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *CityMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[city.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *CityMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *CityMutation) ProvinceIDs() (ids []uuid.UUID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *CityMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *CityMutation) AddDistrictIDs(ids ...uuid.UUID) {
	if m.districts == nil {
		m.districts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *CityMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *CityMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *CityMutation) RemoveDistrictIDs(ids ...uuid.UUID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *CityMutation) RemovedDistrictsIDs() (ids []uuid.UUID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *CityMutation) DistrictsIDs() (ids []uuid.UUID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *CityMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// AddMerchantIDs adds the "merchants" edge to the Merchant entity by ids.
func (m *CityMutation) AddMerchantIDs(ids ...uuid.UUID) {
	if m.merchants == nil {
		m.merchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.merchants[ids[i]] = struct{}{}
	}
}

// ClearMerchants clears the "merchants" edge to the Merchant entity.
func (m *CityMutation) ClearMerchants() {
	m.clearedmerchants = true
}

// MerchantsCleared reports if the "merchants" edge to the Merchant entity was cleared.
func (m *CityMutation) MerchantsCleared() bool {
	return m.clearedmerchants
}

// RemoveMerchantIDs removes the "merchants" edge to the Merchant entity by IDs.
func (m *CityMutation) RemoveMerchantIDs(ids ...uuid.UUID) {
	if m.removedmerchants == nil {
		m.removedmerchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.merchants, ids[i])
		m.removedmerchants[ids[i]] = struct{}{}
	}
}

// RemovedMerchants returns the removed IDs of the "merchants" edge to the Merchant entity.
func (m *CityMutation) RemovedMerchantsIDs() (ids []uuid.UUID) {
	for id := range m.removedmerchants {
		ids = append(ids, id)
	}
	return
}

// MerchantsIDs returns the "merchants" edge IDs in the mutation.
func (m *CityMutation) MerchantsIDs() (ids []uuid.UUID) {
	for id := range m.merchants {
		ids = append(ids, id)
	}
	return
}

// ResetMerchants resets all changes to the "merchants" edge.
func (m *CityMutation) ResetMerchants() {
	m.merchants = nil
	m.clearedmerchants = false
	m.removedmerchants = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *CityMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *CityMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *CityMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *CityMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *CityMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *CityMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *CityMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.City, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.country != nil {
		fields = append(fields, city.FieldCountryID)
	}
	if m.province != nil {
		fields = append(fields, city.FieldProvinceID)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, city.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldDeletedAt:
		return m.DeletedAt()
	case city.FieldCountryID:
		return m.CountryID()
	case city.FieldProvinceID:
		return m.ProvinceID()
	case city.FieldName:
		return m.Name()
	case city.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case city.FieldCountryID:
		return m.OldCountryID(ctx)
	case city.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case city.FieldCountryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case city.FieldProvinceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.addsort != nil {
		fields = append(fields, city.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldDeletedAt:
		return m.AddedDeletedAt()
	case city.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case city.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case city.FieldCountryID:
		m.ResetCountryID()
		return nil
	case city.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.country != nil {
		edges = append(edges, city.EdgeCountry)
	}
	if m.province != nil {
		edges = append(edges, city.EdgeProvince)
	}
	if m.districts != nil {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.merchants != nil {
		edges = append(edges, city.EdgeMerchants)
	}
	if m.stores != nil {
		edges = append(edges, city.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.merchants))
		for id := range m.merchants {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddistricts != nil {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.removedmerchants != nil {
		edges = append(edges, city.EdgeMerchants)
	}
	if m.removedstores != nil {
		edges = append(edges, city.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.removedmerchants))
		for id := range m.removedmerchants {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcountry {
		edges = append(edges, city.EdgeCountry)
	}
	if m.clearedprovince {
		edges = append(edges, city.EdgeProvince)
	}
	if m.cleareddistricts {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.clearedmerchants {
		edges = append(edges, city.EdgeMerchants)
	}
	if m.clearedstores {
		edges = append(edges, city.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeCountry:
		return m.clearedcountry
	case city.EdgeProvince:
		return m.clearedprovince
	case city.EdgeDistricts:
		return m.cleareddistricts
	case city.EdgeMerchants:
		return m.clearedmerchants
	case city.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeCountry:
		m.ClearCountry()
		return nil
	case city.EdgeProvince:
		m.ClearProvince()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeCountry:
		m.ResetCountry()
		return nil
	case city.EdgeProvince:
		m.ResetProvince()
		return nil
	case city.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case city.EdgeMerchants:
		m.ResetMerchants()
		return nil
	case city.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	sort             *int
	addsort          *int
	clearedFields    map[string]struct{}
	provinces        map[uuid.UUID]struct{}
	removedprovinces map[uuid.UUID]struct{}
	clearedprovinces bool
	cities           map[uuid.UUID]struct{}
	removedcities    map[uuid.UUID]struct{}
	clearedcities    bool
	districts        map[uuid.UUID]struct{}
	removeddistricts map[uuid.UUID]struct{}
	cleareddistricts bool
	merchants        map[uuid.UUID]struct{}
	removedmerchants map[uuid.UUID]struct{}
	clearedmerchants bool
	stores           map[uuid.UUID]struct{}
	removedstores    map[uuid.UUID]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*Country, error)
	predicates       []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id uuid.UUID) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CountryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CountryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CountryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CountryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CountryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CountryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CountryMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CountryMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *CountryMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CountryMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CountryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *CountryMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *CountryMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *CountryMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *CountryMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *CountryMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// AddProvinceIDs adds the "provinces" edge to the Province entity by ids.
func (m *CountryMutation) AddProvinceIDs(ids ...uuid.UUID) {
	if m.provinces == nil {
		m.provinces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.provinces[ids[i]] = struct{}{}
	}
}

// ClearProvinces clears the "provinces" edge to the Province entity.
func (m *CountryMutation) ClearProvinces() {
	m.clearedprovinces = true
}

// ProvincesCleared reports if the "provinces" edge to the Province entity was cleared.
func (m *CountryMutation) ProvincesCleared() bool {
	return m.clearedprovinces
}

// RemoveProvinceIDs removes the "provinces" edge to the Province entity by IDs.
func (m *CountryMutation) RemoveProvinceIDs(ids ...uuid.UUID) {
	if m.removedprovinces == nil {
		m.removedprovinces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.provinces, ids[i])
		m.removedprovinces[ids[i]] = struct{}{}
	}
}

// RemovedProvinces returns the removed IDs of the "provinces" edge to the Province entity.
func (m *CountryMutation) RemovedProvincesIDs() (ids []uuid.UUID) {
	for id := range m.removedprovinces {
		ids = append(ids, id)
	}
	return
}

// ProvincesIDs returns the "provinces" edge IDs in the mutation.
func (m *CountryMutation) ProvincesIDs() (ids []uuid.UUID) {
	for id := range m.provinces {
		ids = append(ids, id)
	}
	return
}

// ResetProvinces resets all changes to the "provinces" edge.
func (m *CountryMutation) ResetProvinces() {
	m.provinces = nil
	m.clearedprovinces = false
	m.removedprovinces = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *CountryMutation) AddCityIDs(ids ...uuid.UUID) {
	if m.cities == nil {
		m.cities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *CountryMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *CountryMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *CountryMutation) RemoveCityIDs(ids ...uuid.UUID) {
	if m.removedcities == nil {
		m.removedcities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *CountryMutation) RemovedCitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *CountryMutation) CitiesIDs() (ids []uuid.UUID) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *CountryMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *CountryMutation) AddDistrictIDs(ids ...uuid.UUID) {
	if m.districts == nil {
		m.districts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *CountryMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *CountryMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *CountryMutation) RemoveDistrictIDs(ids ...uuid.UUID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *CountryMutation) RemovedDistrictsIDs() (ids []uuid.UUID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *CountryMutation) DistrictsIDs() (ids []uuid.UUID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *CountryMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// AddMerchantIDs adds the "merchants" edge to the Merchant entity by ids.
func (m *CountryMutation) AddMerchantIDs(ids ...uuid.UUID) {
	if m.merchants == nil {
		m.merchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.merchants[ids[i]] = struct{}{}
	}
}

// ClearMerchants clears the "merchants" edge to the Merchant entity.
func (m *CountryMutation) ClearMerchants() {
	m.clearedmerchants = true
}

// MerchantsCleared reports if the "merchants" edge to the Merchant entity was cleared.
func (m *CountryMutation) MerchantsCleared() bool {
	return m.clearedmerchants
}

// RemoveMerchantIDs removes the "merchants" edge to the Merchant entity by IDs.
func (m *CountryMutation) RemoveMerchantIDs(ids ...uuid.UUID) {
	if m.removedmerchants == nil {
		m.removedmerchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.merchants, ids[i])
		m.removedmerchants[ids[i]] = struct{}{}
	}
}

// RemovedMerchants returns the removed IDs of the "merchants" edge to the Merchant entity.
func (m *CountryMutation) RemovedMerchantsIDs() (ids []uuid.UUID) {
	for id := range m.removedmerchants {
		ids = append(ids, id)
	}
	return
}

// MerchantsIDs returns the "merchants" edge IDs in the mutation.
func (m *CountryMutation) MerchantsIDs() (ids []uuid.UUID) {
	for id := range m.merchants {
		ids = append(ids, id)
	}
	return
}

// ResetMerchants resets all changes to the "merchants" edge.
func (m *CountryMutation) ResetMerchants() {
	m.merchants = nil
	m.clearedmerchants = false
	m.removedmerchants = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *CountryMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *CountryMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *CountryMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *CountryMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *CountryMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *CountryMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *CountryMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, country.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, country.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, country.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, country.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCreatedAt:
		return m.CreatedAt()
	case country.FieldUpdatedAt:
		return m.UpdatedAt()
	case country.FieldDeletedAt:
		return m.DeletedAt()
	case country.FieldName:
		return m.Name()
	case country.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case country.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case country.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case country.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case country.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, country.FieldDeletedAt)
	}
	if m.addsort != nil {
		fields = append(fields, country.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case country.FieldDeletedAt:
		return m.AddedDeletedAt()
	case country.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case country.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case country.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case country.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case country.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.provinces != nil {
		edges = append(edges, country.EdgeProvinces)
	}
	if m.cities != nil {
		edges = append(edges, country.EdgeCities)
	}
	if m.districts != nil {
		edges = append(edges, country.EdgeDistricts)
	}
	if m.merchants != nil {
		edges = append(edges, country.EdgeMerchants)
	}
	if m.stores != nil {
		edges = append(edges, country.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.provinces))
		for id := range m.provinces {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.merchants))
		for id := range m.merchants {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprovinces != nil {
		edges = append(edges, country.EdgeProvinces)
	}
	if m.removedcities != nil {
		edges = append(edges, country.EdgeCities)
	}
	if m.removeddistricts != nil {
		edges = append(edges, country.EdgeDistricts)
	}
	if m.removedmerchants != nil {
		edges = append(edges, country.EdgeMerchants)
	}
	if m.removedstores != nil {
		edges = append(edges, country.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.removedprovinces))
		for id := range m.removedprovinces {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.removedmerchants))
		for id := range m.removedmerchants {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedprovinces {
		edges = append(edges, country.EdgeProvinces)
	}
	if m.clearedcities {
		edges = append(edges, country.EdgeCities)
	}
	if m.cleareddistricts {
		edges = append(edges, country.EdgeDistricts)
	}
	if m.clearedmerchants {
		edges = append(edges, country.EdgeMerchants)
	}
	if m.clearedstores {
		edges = append(edges, country.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeProvinces:
		return m.clearedprovinces
	case country.EdgeCities:
		return m.clearedcities
	case country.EdgeDistricts:
		return m.cleareddistricts
	case country.EdgeMerchants:
		return m.clearedmerchants
	case country.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeProvinces:
		m.ResetProvinces()
		return nil
	case country.EdgeCities:
		m.ResetCities()
		return nil
	case country.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case country.EdgeMerchants:
		m.ResetMerchants()
		return nil
	case country.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	code            *string
	department_type *domain.DepartmentType
	enable          *bool
	clearedFields   map[string]struct{}
	merchant        *uuid.UUID
	clearedmerchant bool
	store           *uuid.UUID
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*Department, error)
	predicates      []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id uuid.UUID) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DepartmentMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DepartmentMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DepartmentMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DepartmentMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DepartmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *DepartmentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DepartmentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DepartmentMutation) ResetCode() {
	m.code = nil
}

// SetDepartmentType sets the "department_type" field.
func (m *DepartmentMutation) SetDepartmentType(dt domain.DepartmentType) {
	m.department_type = &dt
}

// DepartmentType returns the value of the "department_type" field in the mutation.
func (m *DepartmentMutation) DepartmentType() (r domain.DepartmentType, exists bool) {
	v := m.department_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentType returns the old "department_type" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDepartmentType(ctx context.Context) (v domain.DepartmentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentType: %w", err)
	}
	return oldValue.DepartmentType, nil
}

// ResetDepartmentType resets all changes to the "department_type" field.
func (m *DepartmentMutation) ResetDepartmentType() {
	m.department_type = nil
}

// SetEnable sets the "enable" field.
func (m *DepartmentMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *DepartmentMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *DepartmentMutation) ResetEnable() {
	m.enable = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *DepartmentMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *DepartmentMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *DepartmentMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[department.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *DepartmentMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[department.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *DepartmentMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, department.FieldMerchantID)
}

// SetStoreID sets the "store_id" field.
func (m *DepartmentMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *DepartmentMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *DepartmentMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[department.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *DepartmentMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[department.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *DepartmentMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, department.FieldStoreID)
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *DepartmentMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[department.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *DepartmentMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *DepartmentMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *DepartmentMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[department.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *DepartmentMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *DepartmentMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.code != nil {
		fields = append(fields, department.FieldCode)
	}
	if m.department_type != nil {
		fields = append(fields, department.FieldDepartmentType)
	}
	if m.enable != nil {
		fields = append(fields, department.FieldEnable)
	}
	if m.merchant != nil {
		fields = append(fields, department.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, department.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	case department.FieldDeletedAt:
		return m.DeletedAt()
	case department.FieldName:
		return m.Name()
	case department.FieldCode:
		return m.Code()
	case department.FieldDepartmentType:
		return m.DepartmentType()
	case department.FieldEnable:
		return m.Enable()
	case department.FieldMerchantID:
		return m.MerchantID()
	case department.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case department.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldCode:
		return m.OldCode(ctx)
	case department.FieldDepartmentType:
		return m.OldDepartmentType(ctx)
	case department.FieldEnable:
		return m.OldEnable(ctx)
	case department.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case department.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case department.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case department.FieldDepartmentType:
		v, ok := value.(domain.DepartmentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentType(v)
		return nil
	case department.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case department.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case department.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case department.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldMerchantID) {
		fields = append(fields, department.FieldMerchantID)
	}
	if m.FieldCleared(department.FieldStoreID) {
		fields = append(fields, department.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case department.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case department.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldCode:
		m.ResetCode()
		return nil
	case department.FieldDepartmentType:
		m.ResetDepartmentType()
		return nil
	case department.FieldEnable:
		m.ResetEnable()
		return nil
	case department.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case department.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.merchant != nil {
		edges = append(edges, department.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, department.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmerchant {
		edges = append(edges, department.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, department.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeMerchant:
		return m.clearedmerchant
	case department.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case department.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case department.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *int64
	adddeleted_at             *int64
	name                      *string
	device_type               *domain.DeviceType
	device_code               *string
	device_brand              *string
	device_model              *string
	location                  *domain.DeviceLocation
	enabled                   *bool
	status                    *domain.DeviceStatus
	ip                        *string
	sort_order                *int
	addsort_order             *int
	paper_size                *domain.PaperSize
	order_channels            *[]domain.OrderChannel
	appendorder_channels      []domain.OrderChannel
	dining_ways               *[]domain.DiningWay
	appenddining_ways         []domain.DiningWay
	device_stall_print_type   *domain.DeviceStallPrintType
	device_stall_receipt_type *domain.DeviceStallReceiptType
	open_cash_drawer          *bool
	clearedFields             map[string]struct{}
	merchant                  *uuid.UUID
	clearedmerchant           bool
	store                     *uuid.UUID
	clearedstore              bool
	stall                     *uuid.UUID
	clearedstall              bool
	done                      bool
	oldValue                  func(context.Context) (*Device, error)
	predicates                []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id uuid.UUID) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DeviceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DeviceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *DeviceMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *DeviceMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *DeviceMutation) ResetMerchantID() {
	m.merchant = nil
}

// SetStoreID sets the "store_id" field.
func (m *DeviceMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *DeviceMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *DeviceMutation) ResetStoreID() {
	m.store = nil
}

// SetDeviceType sets the "device_type" field.
func (m *DeviceMutation) SetDeviceType(dt domain.DeviceType) {
	m.device_type = &dt
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *DeviceMutation) DeviceType() (r domain.DeviceType, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceType(ctx context.Context) (v domain.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *DeviceMutation) ResetDeviceType() {
	m.device_type = nil
}

// SetDeviceCode sets the "device_code" field.
func (m *DeviceMutation) SetDeviceCode(s string) {
	m.device_code = &s
}

// DeviceCode returns the value of the "device_code" field in the mutation.
func (m *DeviceMutation) DeviceCode() (r string, exists bool) {
	v := m.device_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceCode returns the old "device_code" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceCode: %w", err)
	}
	return oldValue.DeviceCode, nil
}

// ResetDeviceCode resets all changes to the "device_code" field.
func (m *DeviceMutation) ResetDeviceCode() {
	m.device_code = nil
}

// SetDeviceBrand sets the "device_brand" field.
func (m *DeviceMutation) SetDeviceBrand(s string) {
	m.device_brand = &s
}

// DeviceBrand returns the value of the "device_brand" field in the mutation.
func (m *DeviceMutation) DeviceBrand() (r string, exists bool) {
	v := m.device_brand
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceBrand returns the old "device_brand" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceBrand: %w", err)
	}
	return oldValue.DeviceBrand, nil
}

// ClearDeviceBrand clears the value of the "device_brand" field.
func (m *DeviceMutation) ClearDeviceBrand() {
	m.device_brand = nil
	m.clearedFields[device.FieldDeviceBrand] = struct{}{}
}

// DeviceBrandCleared returns if the "device_brand" field was cleared in this mutation.
func (m *DeviceMutation) DeviceBrandCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceBrand]
	return ok
}

// ResetDeviceBrand resets all changes to the "device_brand" field.
func (m *DeviceMutation) ResetDeviceBrand() {
	m.device_brand = nil
	delete(m.clearedFields, device.FieldDeviceBrand)
}

// SetDeviceModel sets the "device_model" field.
func (m *DeviceMutation) SetDeviceModel(s string) {
	m.device_model = &s
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *DeviceMutation) DeviceModel() (r string, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// ClearDeviceModel clears the value of the "device_model" field.
func (m *DeviceMutation) ClearDeviceModel() {
	m.device_model = nil
	m.clearedFields[device.FieldDeviceModel] = struct{}{}
}

// DeviceModelCleared returns if the "device_model" field was cleared in this mutation.
func (m *DeviceMutation) DeviceModelCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceModel]
	return ok
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *DeviceMutation) ResetDeviceModel() {
	m.device_model = nil
	delete(m.clearedFields, device.FieldDeviceModel)
}

// SetLocation sets the "location" field.
func (m *DeviceMutation) SetLocation(dl domain.DeviceLocation) {
	m.location = &dl
}

// Location returns the value of the "location" field in the mutation.
func (m *DeviceMutation) Location() (r domain.DeviceLocation, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLocation(ctx context.Context) (v domain.DeviceLocation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *DeviceMutation) ResetLocation() {
	m.location = nil
}

// SetEnabled sets the "enabled" field.
func (m *DeviceMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *DeviceMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *DeviceMutation) ResetEnabled() {
	m.enabled = nil
}

// SetStatus sets the "status" field.
func (m *DeviceMutation) SetStatus(ds domain.DeviceStatus) {
	m.status = &ds
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceMutation) Status() (r domain.DeviceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStatus(ctx context.Context) (v domain.DeviceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DeviceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[device.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DeviceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[device.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, device.FieldStatus)
}

// SetIP sets the "ip" field.
func (m *DeviceMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *DeviceMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *DeviceMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[device.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *DeviceMutation) IPCleared() bool {
	_, ok := m.clearedFields[device.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *DeviceMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, device.FieldIP)
}

// SetSortOrder sets the "sort_order" field.
func (m *DeviceMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *DeviceMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *DeviceMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *DeviceMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortOrder clears the value of the "sort_order" field.
func (m *DeviceMutation) ClearSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	m.clearedFields[device.FieldSortOrder] = struct{}{}
}

// SortOrderCleared returns if the "sort_order" field was cleared in this mutation.
func (m *DeviceMutation) SortOrderCleared() bool {
	_, ok := m.clearedFields[device.FieldSortOrder]
	return ok
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *DeviceMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
	delete(m.clearedFields, device.FieldSortOrder)
}

// SetPaperSize sets the "paper_size" field.
func (m *DeviceMutation) SetPaperSize(ds domain.PaperSize) {
	m.paper_size = &ds
}

// PaperSize returns the value of the "paper_size" field in the mutation.
func (m *DeviceMutation) PaperSize() (r domain.PaperSize, exists bool) {
	v := m.paper_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperSize returns the old "paper_size" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldPaperSize(ctx context.Context) (v domain.PaperSize, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperSize: %w", err)
	}
	return oldValue.PaperSize, nil
}

// ClearPaperSize clears the value of the "paper_size" field.
func (m *DeviceMutation) ClearPaperSize() {
	m.paper_size = nil
	m.clearedFields[device.FieldPaperSize] = struct{}{}
}

// PaperSizeCleared returns if the "paper_size" field was cleared in this mutation.
func (m *DeviceMutation) PaperSizeCleared() bool {
	_, ok := m.clearedFields[device.FieldPaperSize]
	return ok
}

// ResetPaperSize resets all changes to the "paper_size" field.
func (m *DeviceMutation) ResetPaperSize() {
	m.paper_size = nil
	delete(m.clearedFields, device.FieldPaperSize)
}

// SetStallID sets the "stall_id" field.
func (m *DeviceMutation) SetStallID(u uuid.UUID) {
	m.stall = &u
}

// StallID returns the value of the "stall_id" field in the mutation.
func (m *DeviceMutation) StallID() (r uuid.UUID, exists bool) {
	v := m.stall
	if v == nil {
		return
	}
	return *v, true
}

// OldStallID returns the old "stall_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldStallID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStallID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStallID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStallID: %w", err)
	}
	return oldValue.StallID, nil
}

// ClearStallID clears the value of the "stall_id" field.
func (m *DeviceMutation) ClearStallID() {
	m.stall = nil
	m.clearedFields[device.FieldStallID] = struct{}{}
}

// StallIDCleared returns if the "stall_id" field was cleared in this mutation.
func (m *DeviceMutation) StallIDCleared() bool {
	_, ok := m.clearedFields[device.FieldStallID]
	return ok
}

// ResetStallID resets all changes to the "stall_id" field.
func (m *DeviceMutation) ResetStallID() {
	m.stall = nil
	delete(m.clearedFields, device.FieldStallID)
}

// SetOrderChannels sets the "order_channels" field.
func (m *DeviceMutation) SetOrderChannels(dc []domain.OrderChannel) {
	m.order_channels = &dc
	m.appendorder_channels = nil
}

// OrderChannels returns the value of the "order_channels" field in the mutation.
func (m *DeviceMutation) OrderChannels() (r []domain.OrderChannel, exists bool) {
	v := m.order_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderChannels returns the old "order_channels" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldOrderChannels(ctx context.Context) (v []domain.OrderChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderChannels: %w", err)
	}
	return oldValue.OrderChannels, nil
}

// AppendOrderChannels adds dc to the "order_channels" field.
func (m *DeviceMutation) AppendOrderChannels(dc []domain.OrderChannel) {
	m.appendorder_channels = append(m.appendorder_channels, dc...)
}

// AppendedOrderChannels returns the list of values that were appended to the "order_channels" field in this mutation.
func (m *DeviceMutation) AppendedOrderChannels() ([]domain.OrderChannel, bool) {
	if len(m.appendorder_channels) == 0 {
		return nil, false
	}
	return m.appendorder_channels, true
}

// ClearOrderChannels clears the value of the "order_channels" field.
func (m *DeviceMutation) ClearOrderChannels() {
	m.order_channels = nil
	m.appendorder_channels = nil
	m.clearedFields[device.FieldOrderChannels] = struct{}{}
}

// OrderChannelsCleared returns if the "order_channels" field was cleared in this mutation.
func (m *DeviceMutation) OrderChannelsCleared() bool {
	_, ok := m.clearedFields[device.FieldOrderChannels]
	return ok
}

// ResetOrderChannels resets all changes to the "order_channels" field.
func (m *DeviceMutation) ResetOrderChannels() {
	m.order_channels = nil
	m.appendorder_channels = nil
	delete(m.clearedFields, device.FieldOrderChannels)
}

// SetDiningWays sets the "dining_ways" field.
func (m *DeviceMutation) SetDiningWays(dw []domain.DiningWay) {
	m.dining_ways = &dw
	m.appenddining_ways = nil
}

// DiningWays returns the value of the "dining_ways" field in the mutation.
func (m *DeviceMutation) DiningWays() (r []domain.DiningWay, exists bool) {
	v := m.dining_ways
	if v == nil {
		return
	}
	return *v, true
}

// OldDiningWays returns the old "dining_ways" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDiningWays(ctx context.Context) (v []domain.DiningWay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiningWays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiningWays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiningWays: %w", err)
	}
	return oldValue.DiningWays, nil
}

// AppendDiningWays adds dw to the "dining_ways" field.
func (m *DeviceMutation) AppendDiningWays(dw []domain.DiningWay) {
	m.appenddining_ways = append(m.appenddining_ways, dw...)
}

// AppendedDiningWays returns the list of values that were appended to the "dining_ways" field in this mutation.
func (m *DeviceMutation) AppendedDiningWays() ([]domain.DiningWay, bool) {
	if len(m.appenddining_ways) == 0 {
		return nil, false
	}
	return m.appenddining_ways, true
}

// ClearDiningWays clears the value of the "dining_ways" field.
func (m *DeviceMutation) ClearDiningWays() {
	m.dining_ways = nil
	m.appenddining_ways = nil
	m.clearedFields[device.FieldDiningWays] = struct{}{}
}

// DiningWaysCleared returns if the "dining_ways" field was cleared in this mutation.
func (m *DeviceMutation) DiningWaysCleared() bool {
	_, ok := m.clearedFields[device.FieldDiningWays]
	return ok
}

// ResetDiningWays resets all changes to the "dining_ways" field.
func (m *DeviceMutation) ResetDiningWays() {
	m.dining_ways = nil
	m.appenddining_ways = nil
	delete(m.clearedFields, device.FieldDiningWays)
}

// SetDeviceStallPrintType sets the "device_stall_print_type" field.
func (m *DeviceMutation) SetDeviceStallPrintType(dspt domain.DeviceStallPrintType) {
	m.device_stall_print_type = &dspt
}

// DeviceStallPrintType returns the value of the "device_stall_print_type" field in the mutation.
func (m *DeviceMutation) DeviceStallPrintType() (r domain.DeviceStallPrintType, exists bool) {
	v := m.device_stall_print_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceStallPrintType returns the old "device_stall_print_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceStallPrintType(ctx context.Context) (v domain.DeviceStallPrintType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceStallPrintType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceStallPrintType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceStallPrintType: %w", err)
	}
	return oldValue.DeviceStallPrintType, nil
}

// ClearDeviceStallPrintType clears the value of the "device_stall_print_type" field.
func (m *DeviceMutation) ClearDeviceStallPrintType() {
	m.device_stall_print_type = nil
	m.clearedFields[device.FieldDeviceStallPrintType] = struct{}{}
}

// DeviceStallPrintTypeCleared returns if the "device_stall_print_type" field was cleared in this mutation.
func (m *DeviceMutation) DeviceStallPrintTypeCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceStallPrintType]
	return ok
}

// ResetDeviceStallPrintType resets all changes to the "device_stall_print_type" field.
func (m *DeviceMutation) ResetDeviceStallPrintType() {
	m.device_stall_print_type = nil
	delete(m.clearedFields, device.FieldDeviceStallPrintType)
}

// SetDeviceStallReceiptType sets the "device_stall_receipt_type" field.
func (m *DeviceMutation) SetDeviceStallReceiptType(dsrt domain.DeviceStallReceiptType) {
	m.device_stall_receipt_type = &dsrt
}

// DeviceStallReceiptType returns the value of the "device_stall_receipt_type" field in the mutation.
func (m *DeviceMutation) DeviceStallReceiptType() (r domain.DeviceStallReceiptType, exists bool) {
	v := m.device_stall_receipt_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceStallReceiptType returns the old "device_stall_receipt_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceStallReceiptType(ctx context.Context) (v domain.DeviceStallReceiptType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceStallReceiptType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceStallReceiptType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceStallReceiptType: %w", err)
	}
	return oldValue.DeviceStallReceiptType, nil
}

// ClearDeviceStallReceiptType clears the value of the "device_stall_receipt_type" field.
func (m *DeviceMutation) ClearDeviceStallReceiptType() {
	m.device_stall_receipt_type = nil
	m.clearedFields[device.FieldDeviceStallReceiptType] = struct{}{}
}

// DeviceStallReceiptTypeCleared returns if the "device_stall_receipt_type" field was cleared in this mutation.
func (m *DeviceMutation) DeviceStallReceiptTypeCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceStallReceiptType]
	return ok
}

// ResetDeviceStallReceiptType resets all changes to the "device_stall_receipt_type" field.
func (m *DeviceMutation) ResetDeviceStallReceiptType() {
	m.device_stall_receipt_type = nil
	delete(m.clearedFields, device.FieldDeviceStallReceiptType)
}

// SetOpenCashDrawer sets the "open_cash_drawer" field.
func (m *DeviceMutation) SetOpenCashDrawer(b bool) {
	m.open_cash_drawer = &b
}

// OpenCashDrawer returns the value of the "open_cash_drawer" field in the mutation.
func (m *DeviceMutation) OpenCashDrawer() (r bool, exists bool) {
	v := m.open_cash_drawer
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenCashDrawer returns the old "open_cash_drawer" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldOpenCashDrawer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenCashDrawer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenCashDrawer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenCashDrawer: %w", err)
	}
	return oldValue.OpenCashDrawer, nil
}

// ClearOpenCashDrawer clears the value of the "open_cash_drawer" field.
func (m *DeviceMutation) ClearOpenCashDrawer() {
	m.open_cash_drawer = nil
	m.clearedFields[device.FieldOpenCashDrawer] = struct{}{}
}

// OpenCashDrawerCleared returns if the "open_cash_drawer" field was cleared in this mutation.
func (m *DeviceMutation) OpenCashDrawerCleared() bool {
	_, ok := m.clearedFields[device.FieldOpenCashDrawer]
	return ok
}

// ResetOpenCashDrawer resets all changes to the "open_cash_drawer" field.
func (m *DeviceMutation) ResetOpenCashDrawer() {
	m.open_cash_drawer = nil
	delete(m.clearedFields, device.FieldOpenCashDrawer)
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *DeviceMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[device.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *DeviceMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *DeviceMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *DeviceMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[device.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *DeviceMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *DeviceMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearStall clears the "stall" edge to the Stall entity.
func (m *DeviceMutation) ClearStall() {
	m.clearedstall = true
	m.clearedFields[device.FieldStallID] = struct{}{}
}

// StallCleared reports if the "stall" edge to the Stall entity was cleared.
func (m *DeviceMutation) StallCleared() bool {
	return m.StallIDCleared() || m.clearedstall
}

// StallIDs returns the "stall" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StallID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) StallIDs() (ids []uuid.UUID) {
	if id := m.stall; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStall resets all changes to the "stall" edge.
func (m *DeviceMutation) ResetStall() {
	m.stall = nil
	m.clearedstall = false
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.merchant != nil {
		fields = append(fields, device.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, device.FieldStoreID)
	}
	if m.device_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	if m.device_code != nil {
		fields = append(fields, device.FieldDeviceCode)
	}
	if m.device_brand != nil {
		fields = append(fields, device.FieldDeviceBrand)
	}
	if m.device_model != nil {
		fields = append(fields, device.FieldDeviceModel)
	}
	if m.location != nil {
		fields = append(fields, device.FieldLocation)
	}
	if m.enabled != nil {
		fields = append(fields, device.FieldEnabled)
	}
	if m.status != nil {
		fields = append(fields, device.FieldStatus)
	}
	if m.ip != nil {
		fields = append(fields, device.FieldIP)
	}
	if m.sort_order != nil {
		fields = append(fields, device.FieldSortOrder)
	}
	if m.paper_size != nil {
		fields = append(fields, device.FieldPaperSize)
	}
	if m.stall != nil {
		fields = append(fields, device.FieldStallID)
	}
	if m.order_channels != nil {
		fields = append(fields, device.FieldOrderChannels)
	}
	if m.dining_ways != nil {
		fields = append(fields, device.FieldDiningWays)
	}
	if m.device_stall_print_type != nil {
		fields = append(fields, device.FieldDeviceStallPrintType)
	}
	if m.device_stall_receipt_type != nil {
		fields = append(fields, device.FieldDeviceStallReceiptType)
	}
	if m.open_cash_drawer != nil {
		fields = append(fields, device.FieldOpenCashDrawer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldName:
		return m.Name()
	case device.FieldMerchantID:
		return m.MerchantID()
	case device.FieldStoreID:
		return m.StoreID()
	case device.FieldDeviceType:
		return m.DeviceType()
	case device.FieldDeviceCode:
		return m.DeviceCode()
	case device.FieldDeviceBrand:
		return m.DeviceBrand()
	case device.FieldDeviceModel:
		return m.DeviceModel()
	case device.FieldLocation:
		return m.Location()
	case device.FieldEnabled:
		return m.Enabled()
	case device.FieldStatus:
		return m.Status()
	case device.FieldIP:
		return m.IP()
	case device.FieldSortOrder:
		return m.SortOrder()
	case device.FieldPaperSize:
		return m.PaperSize()
	case device.FieldStallID:
		return m.StallID()
	case device.FieldOrderChannels:
		return m.OrderChannels()
	case device.FieldDiningWays:
		return m.DiningWays()
	case device.FieldDeviceStallPrintType:
		return m.DeviceStallPrintType()
	case device.FieldDeviceStallReceiptType:
		return m.DeviceStallReceiptType()
	case device.FieldOpenCashDrawer:
		return m.OpenCashDrawer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case device.FieldStoreID:
		return m.OldStoreID(ctx)
	case device.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case device.FieldDeviceCode:
		return m.OldDeviceCode(ctx)
	case device.FieldDeviceBrand:
		return m.OldDeviceBrand(ctx)
	case device.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case device.FieldLocation:
		return m.OldLocation(ctx)
	case device.FieldEnabled:
		return m.OldEnabled(ctx)
	case device.FieldStatus:
		return m.OldStatus(ctx)
	case device.FieldIP:
		return m.OldIP(ctx)
	case device.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case device.FieldPaperSize:
		return m.OldPaperSize(ctx)
	case device.FieldStallID:
		return m.OldStallID(ctx)
	case device.FieldOrderChannels:
		return m.OldOrderChannels(ctx)
	case device.FieldDiningWays:
		return m.OldDiningWays(ctx)
	case device.FieldDeviceStallPrintType:
		return m.OldDeviceStallPrintType(ctx)
	case device.FieldDeviceStallReceiptType:
		return m.OldDeviceStallReceiptType(ctx)
	case device.FieldOpenCashDrawer:
		return m.OldOpenCashDrawer(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case device.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(domain.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case device.FieldDeviceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceCode(v)
		return nil
	case device.FieldDeviceBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceBrand(v)
		return nil
	case device.FieldDeviceModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case device.FieldLocation:
		v, ok := value.(domain.DeviceLocation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case device.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case device.FieldStatus:
		v, ok := value.(domain.DeviceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case device.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case device.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case device.FieldPaperSize:
		v, ok := value.(domain.PaperSize)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperSize(v)
		return nil
	case device.FieldStallID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStallID(v)
		return nil
	case device.FieldOrderChannels:
		v, ok := value.([]domain.OrderChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderChannels(v)
		return nil
	case device.FieldDiningWays:
		v, ok := value.([]domain.DiningWay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiningWays(v)
		return nil
	case device.FieldDeviceStallPrintType:
		v, ok := value.(domain.DeviceStallPrintType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceStallPrintType(v)
		return nil
	case device.FieldDeviceStallReceiptType:
		v, ok := value.(domain.DeviceStallReceiptType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceStallReceiptType(v)
		return nil
	case device.FieldOpenCashDrawer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenCashDrawer(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.addsort_order != nil {
		fields = append(fields, device.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeletedAt:
		return m.AddedDeletedAt()
	case device.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case device.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeviceBrand) {
		fields = append(fields, device.FieldDeviceBrand)
	}
	if m.FieldCleared(device.FieldDeviceModel) {
		fields = append(fields, device.FieldDeviceModel)
	}
	if m.FieldCleared(device.FieldStatus) {
		fields = append(fields, device.FieldStatus)
	}
	if m.FieldCleared(device.FieldIP) {
		fields = append(fields, device.FieldIP)
	}
	if m.FieldCleared(device.FieldSortOrder) {
		fields = append(fields, device.FieldSortOrder)
	}
	if m.FieldCleared(device.FieldPaperSize) {
		fields = append(fields, device.FieldPaperSize)
	}
	if m.FieldCleared(device.FieldStallID) {
		fields = append(fields, device.FieldStallID)
	}
	if m.FieldCleared(device.FieldOrderChannels) {
		fields = append(fields, device.FieldOrderChannels)
	}
	if m.FieldCleared(device.FieldDiningWays) {
		fields = append(fields, device.FieldDiningWays)
	}
	if m.FieldCleared(device.FieldDeviceStallPrintType) {
		fields = append(fields, device.FieldDeviceStallPrintType)
	}
	if m.FieldCleared(device.FieldDeviceStallReceiptType) {
		fields = append(fields, device.FieldDeviceStallReceiptType)
	}
	if m.FieldCleared(device.FieldOpenCashDrawer) {
		fields = append(fields, device.FieldOpenCashDrawer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeviceBrand:
		m.ClearDeviceBrand()
		return nil
	case device.FieldDeviceModel:
		m.ClearDeviceModel()
		return nil
	case device.FieldStatus:
		m.ClearStatus()
		return nil
	case device.FieldIP:
		m.ClearIP()
		return nil
	case device.FieldSortOrder:
		m.ClearSortOrder()
		return nil
	case device.FieldPaperSize:
		m.ClearPaperSize()
		return nil
	case device.FieldStallID:
		m.ClearStallID()
		return nil
	case device.FieldOrderChannels:
		m.ClearOrderChannels()
		return nil
	case device.FieldDiningWays:
		m.ClearDiningWays()
		return nil
	case device.FieldDeviceStallPrintType:
		m.ClearDeviceStallPrintType()
		return nil
	case device.FieldDeviceStallReceiptType:
		m.ClearDeviceStallReceiptType()
		return nil
	case device.FieldOpenCashDrawer:
		m.ClearOpenCashDrawer()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case device.FieldStoreID:
		m.ResetStoreID()
		return nil
	case device.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case device.FieldDeviceCode:
		m.ResetDeviceCode()
		return nil
	case device.FieldDeviceBrand:
		m.ResetDeviceBrand()
		return nil
	case device.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case device.FieldLocation:
		m.ResetLocation()
		return nil
	case device.FieldEnabled:
		m.ResetEnabled()
		return nil
	case device.FieldStatus:
		m.ResetStatus()
		return nil
	case device.FieldIP:
		m.ResetIP()
		return nil
	case device.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case device.FieldPaperSize:
		m.ResetPaperSize()
		return nil
	case device.FieldStallID:
		m.ResetStallID()
		return nil
	case device.FieldOrderChannels:
		m.ResetOrderChannels()
		return nil
	case device.FieldDiningWays:
		m.ResetDiningWays()
		return nil
	case device.FieldDeviceStallPrintType:
		m.ResetDeviceStallPrintType()
		return nil
	case device.FieldDeviceStallReceiptType:
		m.ResetDeviceStallReceiptType()
		return nil
	case device.FieldOpenCashDrawer:
		m.ResetOpenCashDrawer()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.merchant != nil {
		edges = append(edges, device.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, device.EdgeStore)
	}
	if m.stall != nil {
		edges = append(edges, device.EdgeStall)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeStall:
		if id := m.stall; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmerchant {
		edges = append(edges, device.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, device.EdgeStore)
	}
	if m.clearedstall {
		edges = append(edges, device.EdgeStall)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeMerchant:
		return m.clearedmerchant
	case device.EdgeStore:
		return m.clearedstore
	case device.EdgeStall:
		return m.clearedstall
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case device.EdgeStore:
		m.ClearStore()
		return nil
	case device.EdgeStall:
		m.ClearStall()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case device.EdgeStore:
		m.ResetStore()
		return nil
	case device.EdgeStall:
		m.ResetStall()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	sort             *int
	addsort          *int
	clearedFields    map[string]struct{}
	country          *uuid.UUID
	clearedcountry   bool
	province         *uuid.UUID
	clearedprovince  bool
	city             *uuid.UUID
	clearedcity      bool
	merchants        map[uuid.UUID]struct{}
	removedmerchants map[uuid.UUID]struct{}
	clearedmerchants bool
	stores           map[uuid.UUID]struct{}
	removedstores    map[uuid.UUID]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*District, error)
	predicates       []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id uuid.UUID) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of District entities.
func (m *DistrictMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistrictMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistrictMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().District.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DistrictMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DistrictMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DistrictMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DistrictMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DistrictMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DistrictMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DistrictMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DistrictMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DistrictMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DistrictMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DistrictMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCountryID sets the "country_id" field.
func (m *DistrictMutation) SetCountryID(u uuid.UUID) {
	m.country = &u
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *DistrictMutation) CountryID() (r uuid.UUID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCountryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *DistrictMutation) ResetCountryID() {
	m.country = nil
}

// SetProvinceID sets the "province_id" field.
func (m *DistrictMutation) SetProvinceID(u uuid.UUID) {
	m.province = &u
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *DistrictMutation) ProvinceID() (r uuid.UUID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldProvinceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *DistrictMutation) ResetProvinceID() {
	m.province = nil
}

// SetCityID sets the "city_id" field.
func (m *DistrictMutation) SetCityID(u uuid.UUID) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *DistrictMutation) CityID() (r uuid.UUID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *DistrictMutation) ResetCityID() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *DistrictMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DistrictMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DistrictMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *DistrictMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DistrictMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *DistrictMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DistrictMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *DistrictMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *DistrictMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[district.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *DistrictMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *DistrictMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *DistrictMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[district.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *DistrictMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) ProvinceIDs() (ids []uuid.UUID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *DistrictMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *DistrictMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[district.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *DistrictMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) CityIDs() (ids []uuid.UUID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *DistrictMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddMerchantIDs adds the "merchants" edge to the Merchant entity by ids.
func (m *DistrictMutation) AddMerchantIDs(ids ...uuid.UUID) {
	if m.merchants == nil {
		m.merchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.merchants[ids[i]] = struct{}{}
	}
}

// ClearMerchants clears the "merchants" edge to the Merchant entity.
func (m *DistrictMutation) ClearMerchants() {
	m.clearedmerchants = true
}

// MerchantsCleared reports if the "merchants" edge to the Merchant entity was cleared.
func (m *DistrictMutation) MerchantsCleared() bool {
	return m.clearedmerchants
}

// RemoveMerchantIDs removes the "merchants" edge to the Merchant entity by IDs.
func (m *DistrictMutation) RemoveMerchantIDs(ids ...uuid.UUID) {
	if m.removedmerchants == nil {
		m.removedmerchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.merchants, ids[i])
		m.removedmerchants[ids[i]] = struct{}{}
	}
}

// RemovedMerchants returns the removed IDs of the "merchants" edge to the Merchant entity.
func (m *DistrictMutation) RemovedMerchantsIDs() (ids []uuid.UUID) {
	for id := range m.removedmerchants {
		ids = append(ids, id)
	}
	return
}

// MerchantsIDs returns the "merchants" edge IDs in the mutation.
func (m *DistrictMutation) MerchantsIDs() (ids []uuid.UUID) {
	for id := range m.merchants {
		ids = append(ids, id)
	}
	return
}

// ResetMerchants resets all changes to the "merchants" edge.
func (m *DistrictMutation) ResetMerchants() {
	m.merchants = nil
	m.clearedmerchants = false
	m.removedmerchants = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *DistrictMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *DistrictMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *DistrictMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *DistrictMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *DistrictMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *DistrictMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *DistrictMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the DistrictMutation builder.
func (m *DistrictMutation) Where(ps ...predicate.District) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistrictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistrictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.District, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistrictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, district.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, district.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, district.FieldDeletedAt)
	}
	if m.country != nil {
		fields = append(fields, district.FieldCountryID)
	}
	if m.province != nil {
		fields = append(fields, district.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, district.FieldCityID)
	}
	if m.name != nil {
		fields = append(fields, district.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, district.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldCreatedAt:
		return m.CreatedAt()
	case district.FieldUpdatedAt:
		return m.UpdatedAt()
	case district.FieldDeletedAt:
		return m.DeletedAt()
	case district.FieldCountryID:
		return m.CountryID()
	case district.FieldProvinceID:
		return m.ProvinceID()
	case district.FieldCityID:
		return m.CityID()
	case district.FieldName:
		return m.Name()
	case district.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case district.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case district.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case district.FieldCountryID:
		return m.OldCountryID(ctx)
	case district.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case district.FieldCityID:
		return m.OldCityID(ctx)
	case district.FieldName:
		return m.OldName(ctx)
	case district.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case district.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case district.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case district.FieldCountryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case district.FieldProvinceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case district.FieldCityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case district.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case district.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, district.FieldDeletedAt)
	}
	if m.addsort != nil {
		fields = append(fields, district.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case district.FieldDeletedAt:
		return m.AddedDeletedAt()
	case district.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	case district.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case district.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case district.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case district.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case district.FieldCountryID:
		m.ResetCountryID()
		return nil
	case district.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case district.FieldCityID:
		m.ResetCityID()
		return nil
	case district.FieldName:
		m.ResetName()
		return nil
	case district.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.country != nil {
		edges = append(edges, district.EdgeCountry)
	}
	if m.province != nil {
		edges = append(edges, district.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, district.EdgeCity)
	}
	if m.merchants != nil {
		edges = append(edges, district.EdgeMerchants)
	}
	if m.stores != nil {
		edges = append(edges, district.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.merchants))
		for id := range m.merchants {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmerchants != nil {
		edges = append(edges, district.EdgeMerchants)
	}
	if m.removedstores != nil {
		edges = append(edges, district.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.removedmerchants))
		for id := range m.removedmerchants {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcountry {
		edges = append(edges, district.EdgeCountry)
	}
	if m.clearedprovince {
		edges = append(edges, district.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, district.EdgeCity)
	}
	if m.clearedmerchants {
		edges = append(edges, district.EdgeMerchants)
	}
	if m.clearedstores {
		edges = append(edges, district.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeCountry:
		return m.clearedcountry
	case district.EdgeProvince:
		return m.clearedprovince
	case district.EdgeCity:
		return m.clearedcity
	case district.EdgeMerchants:
		return m.clearedmerchants
	case district.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	case district.EdgeCountry:
		m.ClearCountry()
		return nil
	case district.EdgeProvince:
		m.ClearProvince()
		return nil
	case district.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeCountry:
		m.ResetCountry()
		return nil
	case district.EdgeProvince:
		m.ResetProvince()
		return nil
	case district.EdgeCity:
		m.ResetCity()
		return nil
	case district.EdgeMerchants:
		m.ResetMerchants()
		return nil
	case district.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int64
	adddeleted_at     *int64
	merchant_id       *uuid.UUID
	name              *string
	distribution_rule *domain.MenuDistributionRule
	store_count       *int
	addstore_count    *int
	item_count        *int
	additem_count     *int
	clearedFields     map[string]struct{}
	items             map[uuid.UUID]struct{}
	removeditems      map[uuid.UUID]struct{}
	cleareditems      bool
	stores            map[uuid.UUID]struct{}
	removedstores     map[uuid.UUID]struct{}
	clearedstores     bool
	done              bool
	oldValue          func(context.Context) (*Menu, error)
	predicates        []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uuid.UUID) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MenuMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MenuMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *MenuMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *MenuMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MenuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *MenuMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *MenuMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *MenuMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetDistributionRule sets the "distribution_rule" field.
func (m *MenuMutation) SetDistributionRule(ddr domain.MenuDistributionRule) {
	m.distribution_rule = &ddr
}

// DistributionRule returns the value of the "distribution_rule" field in the mutation.
func (m *MenuMutation) DistributionRule() (r domain.MenuDistributionRule, exists bool) {
	v := m.distribution_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldDistributionRule returns the old "distribution_rule" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDistributionRule(ctx context.Context) (v domain.MenuDistributionRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistributionRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistributionRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistributionRule: %w", err)
	}
	return oldValue.DistributionRule, nil
}

// ResetDistributionRule resets all changes to the "distribution_rule" field.
func (m *MenuMutation) ResetDistributionRule() {
	m.distribution_rule = nil
}

// SetStoreCount sets the "store_count" field.
func (m *MenuMutation) SetStoreCount(i int) {
	m.store_count = &i
	m.addstore_count = nil
}

// StoreCount returns the value of the "store_count" field in the mutation.
func (m *MenuMutation) StoreCount() (r int, exists bool) {
	v := m.store_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreCount returns the old "store_count" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStoreCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreCount: %w", err)
	}
	return oldValue.StoreCount, nil
}

// AddStoreCount adds i to the "store_count" field.
func (m *MenuMutation) AddStoreCount(i int) {
	if m.addstore_count != nil {
		*m.addstore_count += i
	} else {
		m.addstore_count = &i
	}
}

// AddedStoreCount returns the value that was added to the "store_count" field in this mutation.
func (m *MenuMutation) AddedStoreCount() (r int, exists bool) {
	v := m.addstore_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreCount resets all changes to the "store_count" field.
func (m *MenuMutation) ResetStoreCount() {
	m.store_count = nil
	m.addstore_count = nil
}

// SetItemCount sets the "item_count" field.
func (m *MenuMutation) SetItemCount(i int) {
	m.item_count = &i
	m.additem_count = nil
}

// ItemCount returns the value of the "item_count" field in the mutation.
func (m *MenuMutation) ItemCount() (r int, exists bool) {
	v := m.item_count
	if v == nil {
		return
	}
	return *v, true
}

// OldItemCount returns the old "item_count" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldItemCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemCount: %w", err)
	}
	return oldValue.ItemCount, nil
}

// AddItemCount adds i to the "item_count" field.
func (m *MenuMutation) AddItemCount(i int) {
	if m.additem_count != nil {
		*m.additem_count += i
	} else {
		m.additem_count = &i
	}
}

// AddedItemCount returns the value that was added to the "item_count" field in this mutation.
func (m *MenuMutation) AddedItemCount() (r int, exists bool) {
	v := m.additem_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemCount resets all changes to the "item_count" field.
func (m *MenuMutation) ResetItemCount() {
	m.item_count = nil
	m.additem_count = nil
}

// AddItemIDs adds the "items" edge to the MenuItem entity by ids.
func (m *MenuMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the MenuItem entity.
func (m *MenuMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the MenuItem entity was cleared.
func (m *MenuMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the MenuItem entity by IDs.
func (m *MenuMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the MenuItem entity.
func (m *MenuMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *MenuMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *MenuMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *MenuMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *MenuMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *MenuMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *MenuMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *MenuMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *MenuMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *MenuMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, menu.FieldDeletedAt)
	}
	if m.merchant_id != nil {
		fields = append(fields, menu.FieldMerchantID)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.distribution_rule != nil {
		fields = append(fields, menu.FieldDistributionRule)
	}
	if m.store_count != nil {
		fields = append(fields, menu.FieldStoreCount)
	}
	if m.item_count != nil {
		fields = append(fields, menu.FieldItemCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldDeletedAt:
		return m.DeletedAt()
	case menu.FieldMerchantID:
		return m.MerchantID()
	case menu.FieldName:
		return m.Name()
	case menu.FieldDistributionRule:
		return m.DistributionRule()
	case menu.FieldStoreCount:
		return m.StoreCount()
	case menu.FieldItemCount:
		return m.ItemCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case menu.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldDistributionRule:
		return m.OldDistributionRule(ctx)
	case menu.FieldStoreCount:
		return m.OldStoreCount(ctx)
	case menu.FieldItemCount:
		return m.OldItemCount(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case menu.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldDistributionRule:
		v, ok := value.(domain.MenuDistributionRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistributionRule(v)
		return nil
	case menu.FieldStoreCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreCount(v)
		return nil
	case menu.FieldItemCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemCount(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, menu.FieldDeletedAt)
	}
	if m.addstore_count != nil {
		fields = append(fields, menu.FieldStoreCount)
	}
	if m.additem_count != nil {
		fields = append(fields, menu.FieldItemCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldDeletedAt:
		return m.AddedDeletedAt()
	case menu.FieldStoreCount:
		return m.AddedStoreCount()
	case menu.FieldItemCount:
		return m.AddedItemCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case menu.FieldStoreCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreCount(v)
		return nil
	case menu.FieldItemCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemCount(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case menu.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldDistributionRule:
		m.ResetDistributionRule()
		return nil
	case menu.FieldStoreCount:
		m.ResetStoreCount()
		return nil
	case menu.FieldItemCount:
		m.ResetItemCount()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.items != nil {
		edges = append(edges, menu.EdgeItems)
	}
	if m.stores != nil {
		edges = append(edges, menu.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, menu.EdgeItems)
	}
	if m.removedstores != nil {
		edges = append(edges, menu.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditems {
		edges = append(edges, menu.EdgeItems)
	}
	if m.clearedstores {
		edges = append(edges, menu.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeItems:
		return m.cleareditems
	case menu.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeItems:
		m.ResetItems()
		return nil
	case menu.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuItemMutation represents an operation that mutates the MenuItem nodes in the graph.
type MenuItemMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int64
	adddeleted_at  *int64
	sale_rule      *domain.MenuItemSaleRule
	base_price     *decimal.Decimal
	member_price   *decimal.Decimal
	clearedFields  map[string]struct{}
	menu           *uuid.UUID
	clearedmenu    bool
	product        *uuid.UUID
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*MenuItem, error)
	predicates     []predicate.MenuItem
}

var _ ent.Mutation = (*MenuItemMutation)(nil)

// menuitemOption allows management of the mutation configuration using functional options.
type menuitemOption func(*MenuItemMutation)

// newMenuItemMutation creates new mutation for the MenuItem entity.
func newMenuItemMutation(c config, op Op, opts ...menuitemOption) *MenuItemMutation {
	m := &MenuItemMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuItemID sets the ID field of the mutation.
func withMenuItemID(id uuid.UUID) menuitemOption {
	return func(m *MenuItemMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuItem
		)
		m.oldValue = func(ctx context.Context) (*MenuItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuItem sets the old MenuItem of the mutation.
func withMenuItem(node *MenuItem) menuitemOption {
	return func(m *MenuItemMutation) {
		m.oldValue = func(context.Context) (*MenuItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuItem entities.
func (m *MenuItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MenuItemMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MenuItemMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *MenuItemMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *MenuItemMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MenuItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMenuID sets the "menu_id" field.
func (m *MenuItemMutation) SetMenuID(u uuid.UUID) {
	m.menu = &u
}

// MenuID returns the value of the "menu_id" field in the mutation.
func (m *MenuItemMutation) MenuID() (r uuid.UUID, exists bool) {
	v := m.menu
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old "menu_id" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldMenuID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// ResetMenuID resets all changes to the "menu_id" field.
func (m *MenuItemMutation) ResetMenuID() {
	m.menu = nil
}

// SetProductID sets the "product_id" field.
func (m *MenuItemMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MenuItemMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MenuItemMutation) ResetProductID() {
	m.product = nil
}

// SetSaleRule sets the "sale_rule" field.
func (m *MenuItemMutation) SetSaleRule(disr domain.MenuItemSaleRule) {
	m.sale_rule = &disr
}

// SaleRule returns the value of the "sale_rule" field in the mutation.
func (m *MenuItemMutation) SaleRule() (r domain.MenuItemSaleRule, exists bool) {
	v := m.sale_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleRule returns the old "sale_rule" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldSaleRule(ctx context.Context) (v domain.MenuItemSaleRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleRule: %w", err)
	}
	return oldValue.SaleRule, nil
}

// ResetSaleRule resets all changes to the "sale_rule" field.
func (m *MenuItemMutation) ResetSaleRule() {
	m.sale_rule = nil
}

// SetBasePrice sets the "base_price" field.
func (m *MenuItemMutation) SetBasePrice(d decimal.Decimal) {
	m.base_price = &d
}

// BasePrice returns the value of the "base_price" field in the mutation.
func (m *MenuItemMutation) BasePrice() (r decimal.Decimal, exists bool) {
	v := m.base_price
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePrice returns the old "base_price" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldBasePrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePrice: %w", err)
	}
	return oldValue.BasePrice, nil
}

// ClearBasePrice clears the value of the "base_price" field.
func (m *MenuItemMutation) ClearBasePrice() {
	m.base_price = nil
	m.clearedFields[menuitem.FieldBasePrice] = struct{}{}
}

// BasePriceCleared returns if the "base_price" field was cleared in this mutation.
func (m *MenuItemMutation) BasePriceCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldBasePrice]
	return ok
}

// ResetBasePrice resets all changes to the "base_price" field.
func (m *MenuItemMutation) ResetBasePrice() {
	m.base_price = nil
	delete(m.clearedFields, menuitem.FieldBasePrice)
}

// SetMemberPrice sets the "member_price" field.
func (m *MenuItemMutation) SetMemberPrice(d decimal.Decimal) {
	m.member_price = &d
}

// MemberPrice returns the value of the "member_price" field in the mutation.
func (m *MenuItemMutation) MemberPrice() (r decimal.Decimal, exists bool) {
	v := m.member_price
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPrice returns the old "member_price" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldMemberPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPrice: %w", err)
	}
	return oldValue.MemberPrice, nil
}

// ClearMemberPrice clears the value of the "member_price" field.
func (m *MenuItemMutation) ClearMemberPrice() {
	m.member_price = nil
	m.clearedFields[menuitem.FieldMemberPrice] = struct{}{}
}

// MemberPriceCleared returns if the "member_price" field was cleared in this mutation.
func (m *MenuItemMutation) MemberPriceCleared() bool {
	_, ok := m.clearedFields[menuitem.FieldMemberPrice]
	return ok
}

// ResetMemberPrice resets all changes to the "member_price" field.
func (m *MenuItemMutation) ResetMemberPrice() {
	m.member_price = nil
	delete(m.clearedFields, menuitem.FieldMemberPrice)
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *MenuItemMutation) ClearMenu() {
	m.clearedmenu = true
	m.clearedFields[menuitem.FieldMenuID] = struct{}{}
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *MenuItemMutation) MenuCleared() bool {
	return m.clearedmenu
}

// MenuIDs returns the "menu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenuID instead. It exists only for internal usage by the builders.
func (m *MenuItemMutation) MenuIDs() (ids []uuid.UUID) {
	if id := m.menu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *MenuItemMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *MenuItemMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[menuitem.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *MenuItemMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *MenuItemMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *MenuItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the MenuItemMutation builder.
func (m *MenuItemMutation) Where(ps ...predicate.MenuItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuItem).
func (m *MenuItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, menuitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, menuitem.FieldDeletedAt)
	}
	if m.menu != nil {
		fields = append(fields, menuitem.FieldMenuID)
	}
	if m.product != nil {
		fields = append(fields, menuitem.FieldProductID)
	}
	if m.sale_rule != nil {
		fields = append(fields, menuitem.FieldSaleRule)
	}
	if m.base_price != nil {
		fields = append(fields, menuitem.FieldBasePrice)
	}
	if m.member_price != nil {
		fields = append(fields, menuitem.FieldMemberPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldCreatedAt:
		return m.CreatedAt()
	case menuitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuitem.FieldDeletedAt:
		return m.DeletedAt()
	case menuitem.FieldMenuID:
		return m.MenuID()
	case menuitem.FieldProductID:
		return m.ProductID()
	case menuitem.FieldSaleRule:
		return m.SaleRule()
	case menuitem.FieldBasePrice:
		return m.BasePrice()
	case menuitem.FieldMemberPrice:
		return m.MemberPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case menuitem.FieldMenuID:
		return m.OldMenuID(ctx)
	case menuitem.FieldProductID:
		return m.OldProductID(ctx)
	case menuitem.FieldSaleRule:
		return m.OldSaleRule(ctx)
	case menuitem.FieldBasePrice:
		return m.OldBasePrice(ctx)
	case menuitem.FieldMemberPrice:
		return m.OldMemberPrice(ctx)
	}
	return nil, fmt.Errorf("unknown MenuItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuitem.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case menuitem.FieldMenuID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	case menuitem.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case menuitem.FieldSaleRule:
		v, ok := value.(domain.MenuItemSaleRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleRule(v)
		return nil
	case menuitem.FieldBasePrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePrice(v)
		return nil
	case menuitem.FieldMemberPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuItemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, menuitem.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menuitem.FieldBasePrice) {
		fields = append(fields, menuitem.FieldBasePrice)
	}
	if m.FieldCleared(menuitem.FieldMemberPrice) {
		fields = append(fields, menuitem.FieldMemberPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuItemMutation) ClearField(name string) error {
	switch name {
	case menuitem.FieldBasePrice:
		m.ClearBasePrice()
		return nil
	case menuitem.FieldMemberPrice:
		m.ClearMemberPrice()
		return nil
	}
	return fmt.Errorf("unknown MenuItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuItemMutation) ResetField(name string) error {
	switch name {
	case menuitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case menuitem.FieldMenuID:
		m.ResetMenuID()
		return nil
	case menuitem.FieldProductID:
		m.ResetProductID()
		return nil
	case menuitem.FieldSaleRule:
		m.ResetSaleRule()
		return nil
	case menuitem.FieldBasePrice:
		m.ResetBasePrice()
		return nil
	case menuitem.FieldMemberPrice:
		m.ResetMemberPrice()
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menu != nil {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.product != nil {
		edges = append(edges, menuitem.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuitem.EdgeMenu:
		if id := m.menu; id != nil {
			return []ent.Value{*id}
		}
	case menuitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenu {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.clearedproduct {
		edges = append(edges, menuitem.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuItemMutation) EdgeCleared(name string) bool {
	switch name {
	case menuitem.EdgeMenu:
		return m.clearedmenu
	case menuitem.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuItemMutation) ClearEdge(name string) error {
	switch name {
	case menuitem.EdgeMenu:
		m.ClearMenu()
		return nil
	case menuitem.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown MenuItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuItemMutation) ResetEdge(name string) error {
	switch name {
	case menuitem.EdgeMenu:
		m.ResetMenu()
		return nil
	case menuitem.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown MenuItem edge %s", name)
}

// MerchantMutation represents an operation that mutates the Merchant nodes in the graph.
type MerchantMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *int64
	adddeleted_at                 *int64
	merchant_code                 *string
	merchant_name                 *string
	merchant_short_name           *string
	merchant_type                 *domain.MerchantType
	brand_name                    *string
	admin_phone_number            *string
	expire_utc                    *time.Time
	merchant_logo                 *string
	description                   *string
	status                        *domain.MerchantStatus
	address                       *string
	lng                           *string
	lat                           *string
	super_account                 *string
	clearedFields                 map[string]struct{}
	merchant_business_type        *uuid.UUID
	clearedmerchant_business_type bool
	country                       *uuid.UUID
	clearedcountry                bool
	province                      *uuid.UUID
	clearedprovince               bool
	city                          *uuid.UUID
	clearedcity                   bool
	district                      *uuid.UUID
	cleareddistrict               bool
	backend_users                 map[uuid.UUID]struct{}
	removedbackend_users          map[uuid.UUID]struct{}
	clearedbackend_users          bool
	stores                        map[uuid.UUID]struct{}
	removedstores                 map[uuid.UUID]struct{}
	clearedstores                 bool
	merchant_renewals             map[uuid.UUID]struct{}
	removedmerchant_renewals      map[uuid.UUID]struct{}
	clearedmerchant_renewals      bool
	remark_categories             map[uuid.UUID]struct{}
	removedremark_categories      map[uuid.UUID]struct{}
	clearedremark_categories      bool
	remarks                       map[uuid.UUID]struct{}
	removedremarks                map[uuid.UUID]struct{}
	clearedremarks                bool
	stalls                        map[uuid.UUID]struct{}
	removedstalls                 map[uuid.UUID]struct{}
	clearedstalls                 bool
	additional_fees               map[uuid.UUID]struct{}
	removedadditional_fees        map[uuid.UUID]struct{}
	clearedadditional_fees        bool
	tax_fees                      map[uuid.UUID]struct{}
	removedtax_fees               map[uuid.UUID]struct{}
	clearedtax_fees               bool
	devices                       map[uuid.UUID]struct{}
	removeddevices                map[uuid.UUID]struct{}
	cleareddevices                bool
	departments                   map[uuid.UUID]struct{}
	removeddepartments            map[uuid.UUID]struct{}
	cleareddepartments            bool
	roles                         map[uuid.UUID]struct{}
	removedroles                  map[uuid.UUID]struct{}
	clearedroles                  bool
	store_users                   map[uuid.UUID]struct{}
	removedstore_users            map[uuid.UUID]struct{}
	clearedstore_users            bool
	done                          bool
	oldValue                      func(context.Context) (*Merchant, error)
	predicates                    []predicate.Merchant
}

var _ ent.Mutation = (*MerchantMutation)(nil)

// merchantOption allows management of the mutation configuration using functional options.
type merchantOption func(*MerchantMutation)

// newMerchantMutation creates new mutation for the Merchant entity.
func newMerchantMutation(c config, op Op, opts ...merchantOption) *MerchantMutation {
	m := &MerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantID sets the ID field of the mutation.
func withMerchantID(id uuid.UUID) merchantOption {
	return func(m *MerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *Merchant
		)
		m.oldValue = func(ctx context.Context) (*Merchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Merchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchant sets the old Merchant of the mutation.
func withMerchant(node *Merchant) merchantOption {
	return func(m *MerchantMutation) {
		m.oldValue = func(context.Context) (*Merchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Merchant entities.
func (m *MerchantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Merchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MerchantMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MerchantMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *MerchantMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *MerchantMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MerchantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMerchantCode sets the "merchant_code" field.
func (m *MerchantMutation) SetMerchantCode(s string) {
	m.merchant_code = &s
}

// MerchantCode returns the value of the "merchant_code" field in the mutation.
func (m *MerchantMutation) MerchantCode() (r string, exists bool) {
	v := m.merchant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantCode returns the old "merchant_code" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldMerchantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantCode: %w", err)
	}
	return oldValue.MerchantCode, nil
}

// ClearMerchantCode clears the value of the "merchant_code" field.
func (m *MerchantMutation) ClearMerchantCode() {
	m.merchant_code = nil
	m.clearedFields[merchant.FieldMerchantCode] = struct{}{}
}

// MerchantCodeCleared returns if the "merchant_code" field was cleared in this mutation.
func (m *MerchantMutation) MerchantCodeCleared() bool {
	_, ok := m.clearedFields[merchant.FieldMerchantCode]
	return ok
}

// ResetMerchantCode resets all changes to the "merchant_code" field.
func (m *MerchantMutation) ResetMerchantCode() {
	m.merchant_code = nil
	delete(m.clearedFields, merchant.FieldMerchantCode)
}

// SetMerchantName sets the "merchant_name" field.
func (m *MerchantMutation) SetMerchantName(s string) {
	m.merchant_name = &s
}

// MerchantName returns the value of the "merchant_name" field in the mutation.
func (m *MerchantMutation) MerchantName() (r string, exists bool) {
	v := m.merchant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantName returns the old "merchant_name" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldMerchantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantName: %w", err)
	}
	return oldValue.MerchantName, nil
}

// ResetMerchantName resets all changes to the "merchant_name" field.
func (m *MerchantMutation) ResetMerchantName() {
	m.merchant_name = nil
}

// SetMerchantShortName sets the "merchant_short_name" field.
func (m *MerchantMutation) SetMerchantShortName(s string) {
	m.merchant_short_name = &s
}

// MerchantShortName returns the value of the "merchant_short_name" field in the mutation.
func (m *MerchantMutation) MerchantShortName() (r string, exists bool) {
	v := m.merchant_short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantShortName returns the old "merchant_short_name" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldMerchantShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantShortName: %w", err)
	}
	return oldValue.MerchantShortName, nil
}

// ClearMerchantShortName clears the value of the "merchant_short_name" field.
func (m *MerchantMutation) ClearMerchantShortName() {
	m.merchant_short_name = nil
	m.clearedFields[merchant.FieldMerchantShortName] = struct{}{}
}

// MerchantShortNameCleared returns if the "merchant_short_name" field was cleared in this mutation.
func (m *MerchantMutation) MerchantShortNameCleared() bool {
	_, ok := m.clearedFields[merchant.FieldMerchantShortName]
	return ok
}

// ResetMerchantShortName resets all changes to the "merchant_short_name" field.
func (m *MerchantMutation) ResetMerchantShortName() {
	m.merchant_short_name = nil
	delete(m.clearedFields, merchant.FieldMerchantShortName)
}

// SetMerchantType sets the "merchant_type" field.
func (m *MerchantMutation) SetMerchantType(dt domain.MerchantType) {
	m.merchant_type = &dt
}

// MerchantType returns the value of the "merchant_type" field in the mutation.
func (m *MerchantMutation) MerchantType() (r domain.MerchantType, exists bool) {
	v := m.merchant_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantType returns the old "merchant_type" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldMerchantType(ctx context.Context) (v domain.MerchantType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantType: %w", err)
	}
	return oldValue.MerchantType, nil
}

// ResetMerchantType resets all changes to the "merchant_type" field.
func (m *MerchantMutation) ResetMerchantType() {
	m.merchant_type = nil
}

// SetBrandName sets the "brand_name" field.
func (m *MerchantMutation) SetBrandName(s string) {
	m.brand_name = &s
}

// BrandName returns the value of the "brand_name" field in the mutation.
func (m *MerchantMutation) BrandName() (r string, exists bool) {
	v := m.brand_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandName returns the old "brand_name" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldBrandName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandName: %w", err)
	}
	return oldValue.BrandName, nil
}

// ClearBrandName clears the value of the "brand_name" field.
func (m *MerchantMutation) ClearBrandName() {
	m.brand_name = nil
	m.clearedFields[merchant.FieldBrandName] = struct{}{}
}

// BrandNameCleared returns if the "brand_name" field was cleared in this mutation.
func (m *MerchantMutation) BrandNameCleared() bool {
	_, ok := m.clearedFields[merchant.FieldBrandName]
	return ok
}

// ResetBrandName resets all changes to the "brand_name" field.
func (m *MerchantMutation) ResetBrandName() {
	m.brand_name = nil
	delete(m.clearedFields, merchant.FieldBrandName)
}

// SetAdminPhoneNumber sets the "admin_phone_number" field.
func (m *MerchantMutation) SetAdminPhoneNumber(s string) {
	m.admin_phone_number = &s
}

// AdminPhoneNumber returns the value of the "admin_phone_number" field in the mutation.
func (m *MerchantMutation) AdminPhoneNumber() (r string, exists bool) {
	v := m.admin_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminPhoneNumber returns the old "admin_phone_number" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldAdminPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminPhoneNumber: %w", err)
	}
	return oldValue.AdminPhoneNumber, nil
}

// ResetAdminPhoneNumber resets all changes to the "admin_phone_number" field.
func (m *MerchantMutation) ResetAdminPhoneNumber() {
	m.admin_phone_number = nil
}

// SetExpireUtc sets the "expire_utc" field.
func (m *MerchantMutation) SetExpireUtc(t time.Time) {
	m.expire_utc = &t
}

// ExpireUtc returns the value of the "expire_utc" field in the mutation.
func (m *MerchantMutation) ExpireUtc() (r time.Time, exists bool) {
	v := m.expire_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireUtc returns the old "expire_utc" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldExpireUtc(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireUtc: %w", err)
	}
	return oldValue.ExpireUtc, nil
}

// ClearExpireUtc clears the value of the "expire_utc" field.
func (m *MerchantMutation) ClearExpireUtc() {
	m.expire_utc = nil
	m.clearedFields[merchant.FieldExpireUtc] = struct{}{}
}

// ExpireUtcCleared returns if the "expire_utc" field was cleared in this mutation.
func (m *MerchantMutation) ExpireUtcCleared() bool {
	_, ok := m.clearedFields[merchant.FieldExpireUtc]
	return ok
}

// ResetExpireUtc resets all changes to the "expire_utc" field.
func (m *MerchantMutation) ResetExpireUtc() {
	m.expire_utc = nil
	delete(m.clearedFields, merchant.FieldExpireUtc)
}

// SetBusinessTypeID sets the "business_type_id" field.
func (m *MerchantMutation) SetBusinessTypeID(u uuid.UUID) {
	m.merchant_business_type = &u
}

// BusinessTypeID returns the value of the "business_type_id" field in the mutation.
func (m *MerchantMutation) BusinessTypeID() (r uuid.UUID, exists bool) {
	v := m.merchant_business_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessTypeID returns the old "business_type_id" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldBusinessTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessTypeID: %w", err)
	}
	return oldValue.BusinessTypeID, nil
}

// ResetBusinessTypeID resets all changes to the "business_type_id" field.
func (m *MerchantMutation) ResetBusinessTypeID() {
	m.merchant_business_type = nil
}

// SetMerchantLogo sets the "merchant_logo" field.
func (m *MerchantMutation) SetMerchantLogo(s string) {
	m.merchant_logo = &s
}

// MerchantLogo returns the value of the "merchant_logo" field in the mutation.
func (m *MerchantMutation) MerchantLogo() (r string, exists bool) {
	v := m.merchant_logo
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantLogo returns the old "merchant_logo" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldMerchantLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantLogo: %w", err)
	}
	return oldValue.MerchantLogo, nil
}

// ResetMerchantLogo resets all changes to the "merchant_logo" field.
func (m *MerchantMutation) ResetMerchantLogo() {
	m.merchant_logo = nil
}

// SetDescription sets the "description" field.
func (m *MerchantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MerchantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MerchantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[merchant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MerchantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[merchant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MerchantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, merchant.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *MerchantMutation) SetStatus(ds domain.MerchantStatus) {
	m.status = &ds
}

// Status returns the value of the "status" field in the mutation.
func (m *MerchantMutation) Status() (r domain.MerchantStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldStatus(ctx context.Context) (v domain.MerchantStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MerchantMutation) ResetStatus() {
	m.status = nil
}

// SetCountryID sets the "country_id" field.
func (m *MerchantMutation) SetCountryID(u uuid.UUID) {
	m.country = &u
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *MerchantMutation) CountryID() (r uuid.UUID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCountryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ClearCountryID clears the value of the "country_id" field.
func (m *MerchantMutation) ClearCountryID() {
	m.country = nil
	m.clearedFields[merchant.FieldCountryID] = struct{}{}
}

// CountryIDCleared returns if the "country_id" field was cleared in this mutation.
func (m *MerchantMutation) CountryIDCleared() bool {
	_, ok := m.clearedFields[merchant.FieldCountryID]
	return ok
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *MerchantMutation) ResetCountryID() {
	m.country = nil
	delete(m.clearedFields, merchant.FieldCountryID)
}

// SetProvinceID sets the "province_id" field.
func (m *MerchantMutation) SetProvinceID(u uuid.UUID) {
	m.province = &u
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *MerchantMutation) ProvinceID() (r uuid.UUID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldProvinceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ClearProvinceID clears the value of the "province_id" field.
func (m *MerchantMutation) ClearProvinceID() {
	m.province = nil
	m.clearedFields[merchant.FieldProvinceID] = struct{}{}
}

// ProvinceIDCleared returns if the "province_id" field was cleared in this mutation.
func (m *MerchantMutation) ProvinceIDCleared() bool {
	_, ok := m.clearedFields[merchant.FieldProvinceID]
	return ok
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *MerchantMutation) ResetProvinceID() {
	m.province = nil
	delete(m.clearedFields, merchant.FieldProvinceID)
}

// SetCityID sets the "city_id" field.
func (m *MerchantMutation) SetCityID(u uuid.UUID) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *MerchantMutation) CityID() (r uuid.UUID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *MerchantMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[merchant.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *MerchantMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[merchant.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *MerchantMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, merchant.FieldCityID)
}

// SetDistrictID sets the "district_id" field.
func (m *MerchantMutation) SetDistrictID(u uuid.UUID) {
	m.district = &u
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *MerchantMutation) DistrictID() (r uuid.UUID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldDistrictID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ClearDistrictID clears the value of the "district_id" field.
func (m *MerchantMutation) ClearDistrictID() {
	m.district = nil
	m.clearedFields[merchant.FieldDistrictID] = struct{}{}
}

// DistrictIDCleared returns if the "district_id" field was cleared in this mutation.
func (m *MerchantMutation) DistrictIDCleared() bool {
	_, ok := m.clearedFields[merchant.FieldDistrictID]
	return ok
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *MerchantMutation) ResetDistrictID() {
	m.district = nil
	delete(m.clearedFields, merchant.FieldDistrictID)
}

// SetAddress sets the "address" field.
func (m *MerchantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *MerchantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *MerchantMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[merchant.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *MerchantMutation) AddressCleared() bool {
	_, ok := m.clearedFields[merchant.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *MerchantMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, merchant.FieldAddress)
}

// SetLng sets the "lng" field.
func (m *MerchantMutation) SetLng(s string) {
	m.lng = &s
}

// Lng returns the value of the "lng" field in the mutation.
func (m *MerchantMutation) Lng() (r string, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldLng(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// ClearLng clears the value of the "lng" field.
func (m *MerchantMutation) ClearLng() {
	m.lng = nil
	m.clearedFields[merchant.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *MerchantMutation) LngCleared() bool {
	_, ok := m.clearedFields[merchant.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *MerchantMutation) ResetLng() {
	m.lng = nil
	delete(m.clearedFields, merchant.FieldLng)
}

// SetLat sets the "lat" field.
func (m *MerchantMutation) SetLat(s string) {
	m.lat = &s
}

// Lat returns the value of the "lat" field in the mutation.
func (m *MerchantMutation) Lat() (r string, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldLat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// ClearLat clears the value of the "lat" field.
func (m *MerchantMutation) ClearLat() {
	m.lat = nil
	m.clearedFields[merchant.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *MerchantMutation) LatCleared() bool {
	_, ok := m.clearedFields[merchant.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *MerchantMutation) ResetLat() {
	m.lat = nil
	delete(m.clearedFields, merchant.FieldLat)
}

// SetSuperAccount sets the "super_account" field.
func (m *MerchantMutation) SetSuperAccount(s string) {
	m.super_account = &s
}

// SuperAccount returns the value of the "super_account" field in the mutation.
func (m *MerchantMutation) SuperAccount() (r string, exists bool) {
	v := m.super_account
	if v == nil {
		return
	}
	return *v, true
}

// OldSuperAccount returns the old "super_account" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldSuperAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuperAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuperAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuperAccount: %w", err)
	}
	return oldValue.SuperAccount, nil
}

// ResetSuperAccount resets all changes to the "super_account" field.
func (m *MerchantMutation) ResetSuperAccount() {
	m.super_account = nil
}

// SetMerchantBusinessTypeID sets the "merchant_business_type" edge to the MerchantBusinessType entity by id.
func (m *MerchantMutation) SetMerchantBusinessTypeID(id uuid.UUID) {
	m.merchant_business_type = &id
}

// ClearMerchantBusinessType clears the "merchant_business_type" edge to the MerchantBusinessType entity.
func (m *MerchantMutation) ClearMerchantBusinessType() {
	m.clearedmerchant_business_type = true
	m.clearedFields[merchant.FieldBusinessTypeID] = struct{}{}
}

// MerchantBusinessTypeCleared reports if the "merchant_business_type" edge to the MerchantBusinessType entity was cleared.
func (m *MerchantMutation) MerchantBusinessTypeCleared() bool {
	return m.clearedmerchant_business_type
}

// MerchantBusinessTypeID returns the "merchant_business_type" edge ID in the mutation.
func (m *MerchantMutation) MerchantBusinessTypeID() (id uuid.UUID, exists bool) {
	if m.merchant_business_type != nil {
		return *m.merchant_business_type, true
	}
	return
}

// MerchantBusinessTypeIDs returns the "merchant_business_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantBusinessTypeID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) MerchantBusinessTypeIDs() (ids []uuid.UUID) {
	if id := m.merchant_business_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchantBusinessType resets all changes to the "merchant_business_type" edge.
func (m *MerchantMutation) ResetMerchantBusinessType() {
	m.merchant_business_type = nil
	m.clearedmerchant_business_type = false
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *MerchantMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[merchant.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *MerchantMutation) CountryCleared() bool {
	return m.CountryIDCleared() || m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *MerchantMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *MerchantMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[merchant.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *MerchantMutation) ProvinceCleared() bool {
	return m.ProvinceIDCleared() || m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) ProvinceIDs() (ids []uuid.UUID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *MerchantMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *MerchantMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[merchant.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *MerchantMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) CityIDs() (ids []uuid.UUID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *MerchantMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *MerchantMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[merchant.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *MerchantMutation) DistrictCleared() bool {
	return m.DistrictIDCleared() || m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) DistrictIDs() (ids []uuid.UUID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *MerchantMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// AddBackendUserIDs adds the "backend_users" edge to the BackendUser entity by ids.
func (m *MerchantMutation) AddBackendUserIDs(ids ...uuid.UUID) {
	if m.backend_users == nil {
		m.backend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.backend_users[ids[i]] = struct{}{}
	}
}

// ClearBackendUsers clears the "backend_users" edge to the BackendUser entity.
func (m *MerchantMutation) ClearBackendUsers() {
	m.clearedbackend_users = true
}

// BackendUsersCleared reports if the "backend_users" edge to the BackendUser entity was cleared.
func (m *MerchantMutation) BackendUsersCleared() bool {
	return m.clearedbackend_users
}

// RemoveBackendUserIDs removes the "backend_users" edge to the BackendUser entity by IDs.
func (m *MerchantMutation) RemoveBackendUserIDs(ids ...uuid.UUID) {
	if m.removedbackend_users == nil {
		m.removedbackend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.backend_users, ids[i])
		m.removedbackend_users[ids[i]] = struct{}{}
	}
}

// RemovedBackendUsers returns the removed IDs of the "backend_users" edge to the BackendUser entity.
func (m *MerchantMutation) RemovedBackendUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedbackend_users {
		ids = append(ids, id)
	}
	return
}

// BackendUsersIDs returns the "backend_users" edge IDs in the mutation.
func (m *MerchantMutation) BackendUsersIDs() (ids []uuid.UUID) {
	for id := range m.backend_users {
		ids = append(ids, id)
	}
	return
}

// ResetBackendUsers resets all changes to the "backend_users" edge.
func (m *MerchantMutation) ResetBackendUsers() {
	m.backend_users = nil
	m.clearedbackend_users = false
	m.removedbackend_users = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *MerchantMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *MerchantMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *MerchantMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *MerchantMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *MerchantMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *MerchantMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *MerchantMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// AddMerchantRenewalIDs adds the "merchant_renewals" edge to the MerchantRenewal entity by ids.
func (m *MerchantMutation) AddMerchantRenewalIDs(ids ...uuid.UUID) {
	if m.merchant_renewals == nil {
		m.merchant_renewals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.merchant_renewals[ids[i]] = struct{}{}
	}
}

// ClearMerchantRenewals clears the "merchant_renewals" edge to the MerchantRenewal entity.
func (m *MerchantMutation) ClearMerchantRenewals() {
	m.clearedmerchant_renewals = true
}

// MerchantRenewalsCleared reports if the "merchant_renewals" edge to the MerchantRenewal entity was cleared.
func (m *MerchantMutation) MerchantRenewalsCleared() bool {
	return m.clearedmerchant_renewals
}

// RemoveMerchantRenewalIDs removes the "merchant_renewals" edge to the MerchantRenewal entity by IDs.
func (m *MerchantMutation) RemoveMerchantRenewalIDs(ids ...uuid.UUID) {
	if m.removedmerchant_renewals == nil {
		m.removedmerchant_renewals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.merchant_renewals, ids[i])
		m.removedmerchant_renewals[ids[i]] = struct{}{}
	}
}

// RemovedMerchantRenewals returns the removed IDs of the "merchant_renewals" edge to the MerchantRenewal entity.
func (m *MerchantMutation) RemovedMerchantRenewalsIDs() (ids []uuid.UUID) {
	for id := range m.removedmerchant_renewals {
		ids = append(ids, id)
	}
	return
}

// MerchantRenewalsIDs returns the "merchant_renewals" edge IDs in the mutation.
func (m *MerchantMutation) MerchantRenewalsIDs() (ids []uuid.UUID) {
	for id := range m.merchant_renewals {
		ids = append(ids, id)
	}
	return
}

// ResetMerchantRenewals resets all changes to the "merchant_renewals" edge.
func (m *MerchantMutation) ResetMerchantRenewals() {
	m.merchant_renewals = nil
	m.clearedmerchant_renewals = false
	m.removedmerchant_renewals = nil
}

// AddRemarkCategoryIDs adds the "remark_categories" edge to the RemarkCategory entity by ids.
func (m *MerchantMutation) AddRemarkCategoryIDs(ids ...uuid.UUID) {
	if m.remark_categories == nil {
		m.remark_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.remark_categories[ids[i]] = struct{}{}
	}
}

// ClearRemarkCategories clears the "remark_categories" edge to the RemarkCategory entity.
func (m *MerchantMutation) ClearRemarkCategories() {
	m.clearedremark_categories = true
}

// RemarkCategoriesCleared reports if the "remark_categories" edge to the RemarkCategory entity was cleared.
func (m *MerchantMutation) RemarkCategoriesCleared() bool {
	return m.clearedremark_categories
}

// RemoveRemarkCategoryIDs removes the "remark_categories" edge to the RemarkCategory entity by IDs.
func (m *MerchantMutation) RemoveRemarkCategoryIDs(ids ...uuid.UUID) {
	if m.removedremark_categories == nil {
		m.removedremark_categories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.remark_categories, ids[i])
		m.removedremark_categories[ids[i]] = struct{}{}
	}
}

// RemovedRemarkCategories returns the removed IDs of the "remark_categories" edge to the RemarkCategory entity.
func (m *MerchantMutation) RemovedRemarkCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedremark_categories {
		ids = append(ids, id)
	}
	return
}

// RemarkCategoriesIDs returns the "remark_categories" edge IDs in the mutation.
func (m *MerchantMutation) RemarkCategoriesIDs() (ids []uuid.UUID) {
	for id := range m.remark_categories {
		ids = append(ids, id)
	}
	return
}

// ResetRemarkCategories resets all changes to the "remark_categories" edge.
func (m *MerchantMutation) ResetRemarkCategories() {
	m.remark_categories = nil
	m.clearedremark_categories = false
	m.removedremark_categories = nil
}

// AddRemarkIDs adds the "remarks" edge to the Remark entity by ids.
func (m *MerchantMutation) AddRemarkIDs(ids ...uuid.UUID) {
	if m.remarks == nil {
		m.remarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.remarks[ids[i]] = struct{}{}
	}
}

// ClearRemarks clears the "remarks" edge to the Remark entity.
func (m *MerchantMutation) ClearRemarks() {
	m.clearedremarks = true
}

// RemarksCleared reports if the "remarks" edge to the Remark entity was cleared.
func (m *MerchantMutation) RemarksCleared() bool {
	return m.clearedremarks
}

// RemoveRemarkIDs removes the "remarks" edge to the Remark entity by IDs.
func (m *MerchantMutation) RemoveRemarkIDs(ids ...uuid.UUID) {
	if m.removedremarks == nil {
		m.removedremarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.remarks, ids[i])
		m.removedremarks[ids[i]] = struct{}{}
	}
}

// RemovedRemarks returns the removed IDs of the "remarks" edge to the Remark entity.
func (m *MerchantMutation) RemovedRemarksIDs() (ids []uuid.UUID) {
	for id := range m.removedremarks {
		ids = append(ids, id)
	}
	return
}

// RemarksIDs returns the "remarks" edge IDs in the mutation.
func (m *MerchantMutation) RemarksIDs() (ids []uuid.UUID) {
	for id := range m.remarks {
		ids = append(ids, id)
	}
	return
}

// ResetRemarks resets all changes to the "remarks" edge.
func (m *MerchantMutation) ResetRemarks() {
	m.remarks = nil
	m.clearedremarks = false
	m.removedremarks = nil
}

// AddStallIDs adds the "stalls" edge to the Stall entity by ids.
func (m *MerchantMutation) AddStallIDs(ids ...uuid.UUID) {
	if m.stalls == nil {
		m.stalls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stalls[ids[i]] = struct{}{}
	}
}

// ClearStalls clears the "stalls" edge to the Stall entity.
func (m *MerchantMutation) ClearStalls() {
	m.clearedstalls = true
}

// StallsCleared reports if the "stalls" edge to the Stall entity was cleared.
func (m *MerchantMutation) StallsCleared() bool {
	return m.clearedstalls
}

// RemoveStallIDs removes the "stalls" edge to the Stall entity by IDs.
func (m *MerchantMutation) RemoveStallIDs(ids ...uuid.UUID) {
	if m.removedstalls == nil {
		m.removedstalls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stalls, ids[i])
		m.removedstalls[ids[i]] = struct{}{}
	}
}

// RemovedStalls returns the removed IDs of the "stalls" edge to the Stall entity.
func (m *MerchantMutation) RemovedStallsIDs() (ids []uuid.UUID) {
	for id := range m.removedstalls {
		ids = append(ids, id)
	}
	return
}

// StallsIDs returns the "stalls" edge IDs in the mutation.
func (m *MerchantMutation) StallsIDs() (ids []uuid.UUID) {
	for id := range m.stalls {
		ids = append(ids, id)
	}
	return
}

// ResetStalls resets all changes to the "stalls" edge.
func (m *MerchantMutation) ResetStalls() {
	m.stalls = nil
	m.clearedstalls = false
	m.removedstalls = nil
}

// AddAdditionalFeeIDs adds the "additional_fees" edge to the AdditionalFee entity by ids.
func (m *MerchantMutation) AddAdditionalFeeIDs(ids ...uuid.UUID) {
	if m.additional_fees == nil {
		m.additional_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.additional_fees[ids[i]] = struct{}{}
	}
}

// ClearAdditionalFees clears the "additional_fees" edge to the AdditionalFee entity.
func (m *MerchantMutation) ClearAdditionalFees() {
	m.clearedadditional_fees = true
}

// AdditionalFeesCleared reports if the "additional_fees" edge to the AdditionalFee entity was cleared.
func (m *MerchantMutation) AdditionalFeesCleared() bool {
	return m.clearedadditional_fees
}

// RemoveAdditionalFeeIDs removes the "additional_fees" edge to the AdditionalFee entity by IDs.
func (m *MerchantMutation) RemoveAdditionalFeeIDs(ids ...uuid.UUID) {
	if m.removedadditional_fees == nil {
		m.removedadditional_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.additional_fees, ids[i])
		m.removedadditional_fees[ids[i]] = struct{}{}
	}
}

// RemovedAdditionalFees returns the removed IDs of the "additional_fees" edge to the AdditionalFee entity.
func (m *MerchantMutation) RemovedAdditionalFeesIDs() (ids []uuid.UUID) {
	for id := range m.removedadditional_fees {
		ids = append(ids, id)
	}
	return
}

// AdditionalFeesIDs returns the "additional_fees" edge IDs in the mutation.
func (m *MerchantMutation) AdditionalFeesIDs() (ids []uuid.UUID) {
	for id := range m.additional_fees {
		ids = append(ids, id)
	}
	return
}

// ResetAdditionalFees resets all changes to the "additional_fees" edge.
func (m *MerchantMutation) ResetAdditionalFees() {
	m.additional_fees = nil
	m.clearedadditional_fees = false
	m.removedadditional_fees = nil
}

// AddTaxFeeIDs adds the "tax_fees" edge to the TaxFee entity by ids.
func (m *MerchantMutation) AddTaxFeeIDs(ids ...uuid.UUID) {
	if m.tax_fees == nil {
		m.tax_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tax_fees[ids[i]] = struct{}{}
	}
}

// ClearTaxFees clears the "tax_fees" edge to the TaxFee entity.
func (m *MerchantMutation) ClearTaxFees() {
	m.clearedtax_fees = true
}

// TaxFeesCleared reports if the "tax_fees" edge to the TaxFee entity was cleared.
func (m *MerchantMutation) TaxFeesCleared() bool {
	return m.clearedtax_fees
}

// RemoveTaxFeeIDs removes the "tax_fees" edge to the TaxFee entity by IDs.
func (m *MerchantMutation) RemoveTaxFeeIDs(ids ...uuid.UUID) {
	if m.removedtax_fees == nil {
		m.removedtax_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tax_fees, ids[i])
		m.removedtax_fees[ids[i]] = struct{}{}
	}
}

// RemovedTaxFees returns the removed IDs of the "tax_fees" edge to the TaxFee entity.
func (m *MerchantMutation) RemovedTaxFeesIDs() (ids []uuid.UUID) {
	for id := range m.removedtax_fees {
		ids = append(ids, id)
	}
	return
}

// TaxFeesIDs returns the "tax_fees" edge IDs in the mutation.
func (m *MerchantMutation) TaxFeesIDs() (ids []uuid.UUID) {
	for id := range m.tax_fees {
		ids = append(ids, id)
	}
	return
}

// ResetTaxFees resets all changes to the "tax_fees" edge.
func (m *MerchantMutation) ResetTaxFees() {
	m.tax_fees = nil
	m.clearedtax_fees = false
	m.removedtax_fees = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *MerchantMutation) AddDeviceIDs(ids ...uuid.UUID) {
	if m.devices == nil {
		m.devices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *MerchantMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *MerchantMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *MerchantMutation) RemoveDeviceIDs(ids ...uuid.UUID) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *MerchantMutation) RemovedDevicesIDs() (ids []uuid.UUID) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *MerchantMutation) DevicesIDs() (ids []uuid.UUID) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *MerchantMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddDepartmentIDs adds the "departments" edge to the Department entity by ids.
func (m *MerchantMutation) AddDepartmentIDs(ids ...uuid.UUID) {
	if m.departments == nil {
		m.departments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// ClearDepartments clears the "departments" edge to the Department entity.
func (m *MerchantMutation) ClearDepartments() {
	m.cleareddepartments = true
}

// DepartmentsCleared reports if the "departments" edge to the Department entity was cleared.
func (m *MerchantMutation) DepartmentsCleared() bool {
	return m.cleareddepartments
}

// RemoveDepartmentIDs removes the "departments" edge to the Department entity by IDs.
func (m *MerchantMutation) RemoveDepartmentIDs(ids ...uuid.UUID) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.departments, ids[i])
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed IDs of the "departments" edge to the Department entity.
func (m *MerchantMutation) RemovedDepartmentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the "departments" edge IDs in the mutation.
func (m *MerchantMutation) DepartmentsIDs() (ids []uuid.UUID) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments resets all changes to the "departments" edge.
func (m *MerchantMutation) ResetDepartments() {
	m.departments = nil
	m.cleareddepartments = false
	m.removeddepartments = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MerchantMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MerchantMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MerchantMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MerchantMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MerchantMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MerchantMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MerchantMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddStoreUserIDs adds the "store_users" edge to the StoreUser entity by ids.
func (m *MerchantMutation) AddStoreUserIDs(ids ...uuid.UUID) {
	if m.store_users == nil {
		m.store_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.store_users[ids[i]] = struct{}{}
	}
}

// ClearStoreUsers clears the "store_users" edge to the StoreUser entity.
func (m *MerchantMutation) ClearStoreUsers() {
	m.clearedstore_users = true
}

// StoreUsersCleared reports if the "store_users" edge to the StoreUser entity was cleared.
func (m *MerchantMutation) StoreUsersCleared() bool {
	return m.clearedstore_users
}

// RemoveStoreUserIDs removes the "store_users" edge to the StoreUser entity by IDs.
func (m *MerchantMutation) RemoveStoreUserIDs(ids ...uuid.UUID) {
	if m.removedstore_users == nil {
		m.removedstore_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.store_users, ids[i])
		m.removedstore_users[ids[i]] = struct{}{}
	}
}

// RemovedStoreUsers returns the removed IDs of the "store_users" edge to the StoreUser entity.
func (m *MerchantMutation) RemovedStoreUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedstore_users {
		ids = append(ids, id)
	}
	return
}

// StoreUsersIDs returns the "store_users" edge IDs in the mutation.
func (m *MerchantMutation) StoreUsersIDs() (ids []uuid.UUID) {
	for id := range m.store_users {
		ids = append(ids, id)
	}
	return
}

// ResetStoreUsers resets all changes to the "store_users" edge.
func (m *MerchantMutation) ResetStoreUsers() {
	m.store_users = nil
	m.clearedstore_users = false
	m.removedstore_users = nil
}

// Where appends a list predicates to the MerchantMutation builder.
func (m *MerchantMutation) Where(ps ...predicate.Merchant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MerchantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MerchantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Merchant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MerchantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MerchantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Merchant).
func (m *MerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, merchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, merchant.FieldDeletedAt)
	}
	if m.merchant_code != nil {
		fields = append(fields, merchant.FieldMerchantCode)
	}
	if m.merchant_name != nil {
		fields = append(fields, merchant.FieldMerchantName)
	}
	if m.merchant_short_name != nil {
		fields = append(fields, merchant.FieldMerchantShortName)
	}
	if m.merchant_type != nil {
		fields = append(fields, merchant.FieldMerchantType)
	}
	if m.brand_name != nil {
		fields = append(fields, merchant.FieldBrandName)
	}
	if m.admin_phone_number != nil {
		fields = append(fields, merchant.FieldAdminPhoneNumber)
	}
	if m.expire_utc != nil {
		fields = append(fields, merchant.FieldExpireUtc)
	}
	if m.merchant_business_type != nil {
		fields = append(fields, merchant.FieldBusinessTypeID)
	}
	if m.merchant_logo != nil {
		fields = append(fields, merchant.FieldMerchantLogo)
	}
	if m.description != nil {
		fields = append(fields, merchant.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, merchant.FieldStatus)
	}
	if m.country != nil {
		fields = append(fields, merchant.FieldCountryID)
	}
	if m.province != nil {
		fields = append(fields, merchant.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, merchant.FieldCityID)
	}
	if m.district != nil {
		fields = append(fields, merchant.FieldDistrictID)
	}
	if m.address != nil {
		fields = append(fields, merchant.FieldAddress)
	}
	if m.lng != nil {
		fields = append(fields, merchant.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, merchant.FieldLat)
	}
	if m.super_account != nil {
		fields = append(fields, merchant.FieldSuperAccount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldCreatedAt:
		return m.CreatedAt()
	case merchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchant.FieldDeletedAt:
		return m.DeletedAt()
	case merchant.FieldMerchantCode:
		return m.MerchantCode()
	case merchant.FieldMerchantName:
		return m.MerchantName()
	case merchant.FieldMerchantShortName:
		return m.MerchantShortName()
	case merchant.FieldMerchantType:
		return m.MerchantType()
	case merchant.FieldBrandName:
		return m.BrandName()
	case merchant.FieldAdminPhoneNumber:
		return m.AdminPhoneNumber()
	case merchant.FieldExpireUtc:
		return m.ExpireUtc()
	case merchant.FieldBusinessTypeID:
		return m.BusinessTypeID()
	case merchant.FieldMerchantLogo:
		return m.MerchantLogo()
	case merchant.FieldDescription:
		return m.Description()
	case merchant.FieldStatus:
		return m.Status()
	case merchant.FieldCountryID:
		return m.CountryID()
	case merchant.FieldProvinceID:
		return m.ProvinceID()
	case merchant.FieldCityID:
		return m.CityID()
	case merchant.FieldDistrictID:
		return m.DistrictID()
	case merchant.FieldAddress:
		return m.Address()
	case merchant.FieldLng:
		return m.Lng()
	case merchant.FieldLat:
		return m.Lat()
	case merchant.FieldSuperAccount:
		return m.SuperAccount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case merchant.FieldMerchantCode:
		return m.OldMerchantCode(ctx)
	case merchant.FieldMerchantName:
		return m.OldMerchantName(ctx)
	case merchant.FieldMerchantShortName:
		return m.OldMerchantShortName(ctx)
	case merchant.FieldMerchantType:
		return m.OldMerchantType(ctx)
	case merchant.FieldBrandName:
		return m.OldBrandName(ctx)
	case merchant.FieldAdminPhoneNumber:
		return m.OldAdminPhoneNumber(ctx)
	case merchant.FieldExpireUtc:
		return m.OldExpireUtc(ctx)
	case merchant.FieldBusinessTypeID:
		return m.OldBusinessTypeID(ctx)
	case merchant.FieldMerchantLogo:
		return m.OldMerchantLogo(ctx)
	case merchant.FieldDescription:
		return m.OldDescription(ctx)
	case merchant.FieldStatus:
		return m.OldStatus(ctx)
	case merchant.FieldCountryID:
		return m.OldCountryID(ctx)
	case merchant.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case merchant.FieldCityID:
		return m.OldCityID(ctx)
	case merchant.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case merchant.FieldAddress:
		return m.OldAddress(ctx)
	case merchant.FieldLng:
		return m.OldLng(ctx)
	case merchant.FieldLat:
		return m.OldLat(ctx)
	case merchant.FieldSuperAccount:
		return m.OldSuperAccount(ctx)
	}
	return nil, fmt.Errorf("unknown Merchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchant.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case merchant.FieldMerchantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantCode(v)
		return nil
	case merchant.FieldMerchantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantName(v)
		return nil
	case merchant.FieldMerchantShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantShortName(v)
		return nil
	case merchant.FieldMerchantType:
		v, ok := value.(domain.MerchantType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantType(v)
		return nil
	case merchant.FieldBrandName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandName(v)
		return nil
	case merchant.FieldAdminPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminPhoneNumber(v)
		return nil
	case merchant.FieldExpireUtc:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireUtc(v)
		return nil
	case merchant.FieldBusinessTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessTypeID(v)
		return nil
	case merchant.FieldMerchantLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantLogo(v)
		return nil
	case merchant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case merchant.FieldStatus:
		v, ok := value.(domain.MerchantStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case merchant.FieldCountryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case merchant.FieldProvinceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case merchant.FieldCityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case merchant.FieldDistrictID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case merchant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case merchant.FieldLng:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case merchant.FieldLat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case merchant.FieldSuperAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuperAccount(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, merchant.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(merchant.FieldMerchantCode) {
		fields = append(fields, merchant.FieldMerchantCode)
	}
	if m.FieldCleared(merchant.FieldMerchantShortName) {
		fields = append(fields, merchant.FieldMerchantShortName)
	}
	if m.FieldCleared(merchant.FieldBrandName) {
		fields = append(fields, merchant.FieldBrandName)
	}
	if m.FieldCleared(merchant.FieldExpireUtc) {
		fields = append(fields, merchant.FieldExpireUtc)
	}
	if m.FieldCleared(merchant.FieldDescription) {
		fields = append(fields, merchant.FieldDescription)
	}
	if m.FieldCleared(merchant.FieldCountryID) {
		fields = append(fields, merchant.FieldCountryID)
	}
	if m.FieldCleared(merchant.FieldProvinceID) {
		fields = append(fields, merchant.FieldProvinceID)
	}
	if m.FieldCleared(merchant.FieldCityID) {
		fields = append(fields, merchant.FieldCityID)
	}
	if m.FieldCleared(merchant.FieldDistrictID) {
		fields = append(fields, merchant.FieldDistrictID)
	}
	if m.FieldCleared(merchant.FieldAddress) {
		fields = append(fields, merchant.FieldAddress)
	}
	if m.FieldCleared(merchant.FieldLng) {
		fields = append(fields, merchant.FieldLng)
	}
	if m.FieldCleared(merchant.FieldLat) {
		fields = append(fields, merchant.FieldLat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantMutation) ClearField(name string) error {
	switch name {
	case merchant.FieldMerchantCode:
		m.ClearMerchantCode()
		return nil
	case merchant.FieldMerchantShortName:
		m.ClearMerchantShortName()
		return nil
	case merchant.FieldBrandName:
		m.ClearBrandName()
		return nil
	case merchant.FieldExpireUtc:
		m.ClearExpireUtc()
		return nil
	case merchant.FieldDescription:
		m.ClearDescription()
		return nil
	case merchant.FieldCountryID:
		m.ClearCountryID()
		return nil
	case merchant.FieldProvinceID:
		m.ClearProvinceID()
		return nil
	case merchant.FieldCityID:
		m.ClearCityID()
		return nil
	case merchant.FieldDistrictID:
		m.ClearDistrictID()
		return nil
	case merchant.FieldAddress:
		m.ClearAddress()
		return nil
	case merchant.FieldLng:
		m.ClearLng()
		return nil
	case merchant.FieldLat:
		m.ClearLat()
		return nil
	}
	return fmt.Errorf("unknown Merchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantMutation) ResetField(name string) error {
	switch name {
	case merchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case merchant.FieldMerchantCode:
		m.ResetMerchantCode()
		return nil
	case merchant.FieldMerchantName:
		m.ResetMerchantName()
		return nil
	case merchant.FieldMerchantShortName:
		m.ResetMerchantShortName()
		return nil
	case merchant.FieldMerchantType:
		m.ResetMerchantType()
		return nil
	case merchant.FieldBrandName:
		m.ResetBrandName()
		return nil
	case merchant.FieldAdminPhoneNumber:
		m.ResetAdminPhoneNumber()
		return nil
	case merchant.FieldExpireUtc:
		m.ResetExpireUtc()
		return nil
	case merchant.FieldBusinessTypeID:
		m.ResetBusinessTypeID()
		return nil
	case merchant.FieldMerchantLogo:
		m.ResetMerchantLogo()
		return nil
	case merchant.FieldDescription:
		m.ResetDescription()
		return nil
	case merchant.FieldStatus:
		m.ResetStatus()
		return nil
	case merchant.FieldCountryID:
		m.ResetCountryID()
		return nil
	case merchant.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case merchant.FieldCityID:
		m.ResetCityID()
		return nil
	case merchant.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case merchant.FieldAddress:
		m.ResetAddress()
		return nil
	case merchant.FieldLng:
		m.ResetLng()
		return nil
	case merchant.FieldLat:
		m.ResetLat()
		return nil
	case merchant.FieldSuperAccount:
		m.ResetSuperAccount()
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.merchant_business_type != nil {
		edges = append(edges, merchant.EdgeMerchantBusinessType)
	}
	if m.country != nil {
		edges = append(edges, merchant.EdgeCountry)
	}
	if m.province != nil {
		edges = append(edges, merchant.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, merchant.EdgeCity)
	}
	if m.district != nil {
		edges = append(edges, merchant.EdgeDistrict)
	}
	if m.backend_users != nil {
		edges = append(edges, merchant.EdgeBackendUsers)
	}
	if m.stores != nil {
		edges = append(edges, merchant.EdgeStores)
	}
	if m.merchant_renewals != nil {
		edges = append(edges, merchant.EdgeMerchantRenewals)
	}
	if m.remark_categories != nil {
		edges = append(edges, merchant.EdgeRemarkCategories)
	}
	if m.remarks != nil {
		edges = append(edges, merchant.EdgeRemarks)
	}
	if m.stalls != nil {
		edges = append(edges, merchant.EdgeStalls)
	}
	if m.additional_fees != nil {
		edges = append(edges, merchant.EdgeAdditionalFees)
	}
	if m.tax_fees != nil {
		edges = append(edges, merchant.EdgeTaxFees)
	}
	if m.devices != nil {
		edges = append(edges, merchant.EdgeDevices)
	}
	if m.departments != nil {
		edges = append(edges, merchant.EdgeDepartments)
	}
	if m.roles != nil {
		edges = append(edges, merchant.EdgeRoles)
	}
	if m.store_users != nil {
		edges = append(edges, merchant.EdgeStoreUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeMerchantBusinessType:
		if id := m.merchant_business_type; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeBackendUsers:
		ids := make([]ent.Value, 0, len(m.backend_users))
		for id := range m.backend_users {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeMerchantRenewals:
		ids := make([]ent.Value, 0, len(m.merchant_renewals))
		for id := range m.merchant_renewals {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeRemarkCategories:
		ids := make([]ent.Value, 0, len(m.remark_categories))
		for id := range m.remark_categories {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeRemarks:
		ids := make([]ent.Value, 0, len(m.remarks))
		for id := range m.remarks {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeStalls:
		ids := make([]ent.Value, 0, len(m.stalls))
		for id := range m.stalls {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeAdditionalFees:
		ids := make([]ent.Value, 0, len(m.additional_fees))
		for id := range m.additional_fees {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeTaxFees:
		ids := make([]ent.Value, 0, len(m.tax_fees))
		for id := range m.tax_fees {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeStoreUsers:
		ids := make([]ent.Value, 0, len(m.store_users))
		for id := range m.store_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedbackend_users != nil {
		edges = append(edges, merchant.EdgeBackendUsers)
	}
	if m.removedstores != nil {
		edges = append(edges, merchant.EdgeStores)
	}
	if m.removedmerchant_renewals != nil {
		edges = append(edges, merchant.EdgeMerchantRenewals)
	}
	if m.removedremark_categories != nil {
		edges = append(edges, merchant.EdgeRemarkCategories)
	}
	if m.removedremarks != nil {
		edges = append(edges, merchant.EdgeRemarks)
	}
	if m.removedstalls != nil {
		edges = append(edges, merchant.EdgeStalls)
	}
	if m.removedadditional_fees != nil {
		edges = append(edges, merchant.EdgeAdditionalFees)
	}
	if m.removedtax_fees != nil {
		edges = append(edges, merchant.EdgeTaxFees)
	}
	if m.removeddevices != nil {
		edges = append(edges, merchant.EdgeDevices)
	}
	if m.removeddepartments != nil {
		edges = append(edges, merchant.EdgeDepartments)
	}
	if m.removedroles != nil {
		edges = append(edges, merchant.EdgeRoles)
	}
	if m.removedstore_users != nil {
		edges = append(edges, merchant.EdgeStoreUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeBackendUsers:
		ids := make([]ent.Value, 0, len(m.removedbackend_users))
		for id := range m.removedbackend_users {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeMerchantRenewals:
		ids := make([]ent.Value, 0, len(m.removedmerchant_renewals))
		for id := range m.removedmerchant_renewals {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeRemarkCategories:
		ids := make([]ent.Value, 0, len(m.removedremark_categories))
		for id := range m.removedremark_categories {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeRemarks:
		ids := make([]ent.Value, 0, len(m.removedremarks))
		for id := range m.removedremarks {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeStalls:
		ids := make([]ent.Value, 0, len(m.removedstalls))
		for id := range m.removedstalls {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeAdditionalFees:
		ids := make([]ent.Value, 0, len(m.removedadditional_fees))
		for id := range m.removedadditional_fees {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeTaxFees:
		ids := make([]ent.Value, 0, len(m.removedtax_fees))
		for id := range m.removedtax_fees {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeStoreUsers:
		ids := make([]ent.Value, 0, len(m.removedstore_users))
		for id := range m.removedstore_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedmerchant_business_type {
		edges = append(edges, merchant.EdgeMerchantBusinessType)
	}
	if m.clearedcountry {
		edges = append(edges, merchant.EdgeCountry)
	}
	if m.clearedprovince {
		edges = append(edges, merchant.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, merchant.EdgeCity)
	}
	if m.cleareddistrict {
		edges = append(edges, merchant.EdgeDistrict)
	}
	if m.clearedbackend_users {
		edges = append(edges, merchant.EdgeBackendUsers)
	}
	if m.clearedstores {
		edges = append(edges, merchant.EdgeStores)
	}
	if m.clearedmerchant_renewals {
		edges = append(edges, merchant.EdgeMerchantRenewals)
	}
	if m.clearedremark_categories {
		edges = append(edges, merchant.EdgeRemarkCategories)
	}
	if m.clearedremarks {
		edges = append(edges, merchant.EdgeRemarks)
	}
	if m.clearedstalls {
		edges = append(edges, merchant.EdgeStalls)
	}
	if m.clearedadditional_fees {
		edges = append(edges, merchant.EdgeAdditionalFees)
	}
	if m.clearedtax_fees {
		edges = append(edges, merchant.EdgeTaxFees)
	}
	if m.cleareddevices {
		edges = append(edges, merchant.EdgeDevices)
	}
	if m.cleareddepartments {
		edges = append(edges, merchant.EdgeDepartments)
	}
	if m.clearedroles {
		edges = append(edges, merchant.EdgeRoles)
	}
	if m.clearedstore_users {
		edges = append(edges, merchant.EdgeStoreUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case merchant.EdgeMerchantBusinessType:
		return m.clearedmerchant_business_type
	case merchant.EdgeCountry:
		return m.clearedcountry
	case merchant.EdgeProvince:
		return m.clearedprovince
	case merchant.EdgeCity:
		return m.clearedcity
	case merchant.EdgeDistrict:
		return m.cleareddistrict
	case merchant.EdgeBackendUsers:
		return m.clearedbackend_users
	case merchant.EdgeStores:
		return m.clearedstores
	case merchant.EdgeMerchantRenewals:
		return m.clearedmerchant_renewals
	case merchant.EdgeRemarkCategories:
		return m.clearedremark_categories
	case merchant.EdgeRemarks:
		return m.clearedremarks
	case merchant.EdgeStalls:
		return m.clearedstalls
	case merchant.EdgeAdditionalFees:
		return m.clearedadditional_fees
	case merchant.EdgeTaxFees:
		return m.clearedtax_fees
	case merchant.EdgeDevices:
		return m.cleareddevices
	case merchant.EdgeDepartments:
		return m.cleareddepartments
	case merchant.EdgeRoles:
		return m.clearedroles
	case merchant.EdgeStoreUsers:
		return m.clearedstore_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantMutation) ClearEdge(name string) error {
	switch name {
	case merchant.EdgeMerchantBusinessType:
		m.ClearMerchantBusinessType()
		return nil
	case merchant.EdgeCountry:
		m.ClearCountry()
		return nil
	case merchant.EdgeProvince:
		m.ClearProvince()
		return nil
	case merchant.EdgeCity:
		m.ClearCity()
		return nil
	case merchant.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Merchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantMutation) ResetEdge(name string) error {
	switch name {
	case merchant.EdgeMerchantBusinessType:
		m.ResetMerchantBusinessType()
		return nil
	case merchant.EdgeCountry:
		m.ResetCountry()
		return nil
	case merchant.EdgeProvince:
		m.ResetProvince()
		return nil
	case merchant.EdgeCity:
		m.ResetCity()
		return nil
	case merchant.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case merchant.EdgeBackendUsers:
		m.ResetBackendUsers()
		return nil
	case merchant.EdgeStores:
		m.ResetStores()
		return nil
	case merchant.EdgeMerchantRenewals:
		m.ResetMerchantRenewals()
		return nil
	case merchant.EdgeRemarkCategories:
		m.ResetRemarkCategories()
		return nil
	case merchant.EdgeRemarks:
		m.ResetRemarks()
		return nil
	case merchant.EdgeStalls:
		m.ResetStalls()
		return nil
	case merchant.EdgeAdditionalFees:
		m.ResetAdditionalFees()
		return nil
	case merchant.EdgeTaxFees:
		m.ResetTaxFees()
		return nil
	case merchant.EdgeDevices:
		m.ResetDevices()
		return nil
	case merchant.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case merchant.EdgeRoles:
		m.ResetRoles()
		return nil
	case merchant.EdgeStoreUsers:
		m.ResetStoreUsers()
		return nil
	}
	return fmt.Errorf("unknown Merchant edge %s", name)
}

// MerchantBusinessTypeMutation represents an operation that mutates the MerchantBusinessType nodes in the graph.
type MerchantBusinessTypeMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	type_code        *string
	type_name        *string
	clearedFields    map[string]struct{}
	merchants        map[uuid.UUID]struct{}
	removedmerchants map[uuid.UUID]struct{}
	clearedmerchants bool
	stores           map[uuid.UUID]struct{}
	removedstores    map[uuid.UUID]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*MerchantBusinessType, error)
	predicates       []predicate.MerchantBusinessType
}

var _ ent.Mutation = (*MerchantBusinessTypeMutation)(nil)

// merchantbusinesstypeOption allows management of the mutation configuration using functional options.
type merchantbusinesstypeOption func(*MerchantBusinessTypeMutation)

// newMerchantBusinessTypeMutation creates new mutation for the MerchantBusinessType entity.
func newMerchantBusinessTypeMutation(c config, op Op, opts ...merchantbusinesstypeOption) *MerchantBusinessTypeMutation {
	m := &MerchantBusinessTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchantBusinessType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantBusinessTypeID sets the ID field of the mutation.
func withMerchantBusinessTypeID(id uuid.UUID) merchantbusinesstypeOption {
	return func(m *MerchantBusinessTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MerchantBusinessType
		)
		m.oldValue = func(ctx context.Context) (*MerchantBusinessType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MerchantBusinessType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchantBusinessType sets the old MerchantBusinessType of the mutation.
func withMerchantBusinessType(node *MerchantBusinessType) merchantbusinesstypeOption {
	return func(m *MerchantBusinessTypeMutation) {
		m.oldValue = func(context.Context) (*MerchantBusinessType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantBusinessTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantBusinessTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MerchantBusinessType entities.
func (m *MerchantBusinessTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantBusinessTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantBusinessTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MerchantBusinessType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantBusinessTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantBusinessTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MerchantBusinessType entity.
// If the MerchantBusinessType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantBusinessTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantBusinessTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantBusinessTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantBusinessTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MerchantBusinessType entity.
// If the MerchantBusinessType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantBusinessTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantBusinessTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MerchantBusinessTypeMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MerchantBusinessTypeMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MerchantBusinessType entity.
// If the MerchantBusinessType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantBusinessTypeMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *MerchantBusinessTypeMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *MerchantBusinessTypeMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MerchantBusinessTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTypeCode sets the "type_code" field.
func (m *MerchantBusinessTypeMutation) SetTypeCode(s string) {
	m.type_code = &s
}

// TypeCode returns the value of the "type_code" field in the mutation.
func (m *MerchantBusinessTypeMutation) TypeCode() (r string, exists bool) {
	v := m.type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "type_code" field's value of the MerchantBusinessType entity.
// If the MerchantBusinessType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantBusinessTypeMutation) OldTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ResetTypeCode resets all changes to the "type_code" field.
func (m *MerchantBusinessTypeMutation) ResetTypeCode() {
	m.type_code = nil
}

// SetTypeName sets the "type_name" field.
func (m *MerchantBusinessTypeMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *MerchantBusinessTypeMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the MerchantBusinessType entity.
// If the MerchantBusinessType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantBusinessTypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *MerchantBusinessTypeMutation) ResetTypeName() {
	m.type_name = nil
}

// AddMerchantIDs adds the "merchants" edge to the Merchant entity by ids.
func (m *MerchantBusinessTypeMutation) AddMerchantIDs(ids ...uuid.UUID) {
	if m.merchants == nil {
		m.merchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.merchants[ids[i]] = struct{}{}
	}
}

// ClearMerchants clears the "merchants" edge to the Merchant entity.
func (m *MerchantBusinessTypeMutation) ClearMerchants() {
	m.clearedmerchants = true
}

// MerchantsCleared reports if the "merchants" edge to the Merchant entity was cleared.
func (m *MerchantBusinessTypeMutation) MerchantsCleared() bool {
	return m.clearedmerchants
}

// RemoveMerchantIDs removes the "merchants" edge to the Merchant entity by IDs.
func (m *MerchantBusinessTypeMutation) RemoveMerchantIDs(ids ...uuid.UUID) {
	if m.removedmerchants == nil {
		m.removedmerchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.merchants, ids[i])
		m.removedmerchants[ids[i]] = struct{}{}
	}
}

// RemovedMerchants returns the removed IDs of the "merchants" edge to the Merchant entity.
func (m *MerchantBusinessTypeMutation) RemovedMerchantsIDs() (ids []uuid.UUID) {
	for id := range m.removedmerchants {
		ids = append(ids, id)
	}
	return
}

// MerchantsIDs returns the "merchants" edge IDs in the mutation.
func (m *MerchantBusinessTypeMutation) MerchantsIDs() (ids []uuid.UUID) {
	for id := range m.merchants {
		ids = append(ids, id)
	}
	return
}

// ResetMerchants resets all changes to the "merchants" edge.
func (m *MerchantBusinessTypeMutation) ResetMerchants() {
	m.merchants = nil
	m.clearedmerchants = false
	m.removedmerchants = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *MerchantBusinessTypeMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *MerchantBusinessTypeMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *MerchantBusinessTypeMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *MerchantBusinessTypeMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *MerchantBusinessTypeMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *MerchantBusinessTypeMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *MerchantBusinessTypeMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the MerchantBusinessTypeMutation builder.
func (m *MerchantBusinessTypeMutation) Where(ps ...predicate.MerchantBusinessType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MerchantBusinessTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MerchantBusinessTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MerchantBusinessType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MerchantBusinessTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MerchantBusinessTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MerchantBusinessType).
func (m *MerchantBusinessTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantBusinessTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, merchantbusinesstype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchantbusinesstype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, merchantbusinesstype.FieldDeletedAt)
	}
	if m.type_code != nil {
		fields = append(fields, merchantbusinesstype.FieldTypeCode)
	}
	if m.type_name != nil {
		fields = append(fields, merchantbusinesstype.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantBusinessTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchantbusinesstype.FieldCreatedAt:
		return m.CreatedAt()
	case merchantbusinesstype.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchantbusinesstype.FieldDeletedAt:
		return m.DeletedAt()
	case merchantbusinesstype.FieldTypeCode:
		return m.TypeCode()
	case merchantbusinesstype.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantBusinessTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchantbusinesstype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchantbusinesstype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchantbusinesstype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case merchantbusinesstype.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case merchantbusinesstype.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown MerchantBusinessType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantBusinessTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchantbusinesstype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchantbusinesstype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchantbusinesstype.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case merchantbusinesstype.FieldTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case merchantbusinesstype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantBusinessType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantBusinessTypeMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, merchantbusinesstype.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantBusinessTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case merchantbusinesstype.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantBusinessTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case merchantbusinesstype.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantBusinessType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantBusinessTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantBusinessTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantBusinessTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MerchantBusinessType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantBusinessTypeMutation) ResetField(name string) error {
	switch name {
	case merchantbusinesstype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchantbusinesstype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchantbusinesstype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case merchantbusinesstype.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case merchantbusinesstype.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown MerchantBusinessType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantBusinessTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.merchants != nil {
		edges = append(edges, merchantbusinesstype.EdgeMerchants)
	}
	if m.stores != nil {
		edges = append(edges, merchantbusinesstype.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantBusinessTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchantbusinesstype.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.merchants))
		for id := range m.merchants {
			ids = append(ids, id)
		}
		return ids
	case merchantbusinesstype.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantBusinessTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmerchants != nil {
		edges = append(edges, merchantbusinesstype.EdgeMerchants)
	}
	if m.removedstores != nil {
		edges = append(edges, merchantbusinesstype.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantBusinessTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case merchantbusinesstype.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.removedmerchants))
		for id := range m.removedmerchants {
			ids = append(ids, id)
		}
		return ids
	case merchantbusinesstype.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantBusinessTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmerchants {
		edges = append(edges, merchantbusinesstype.EdgeMerchants)
	}
	if m.clearedstores {
		edges = append(edges, merchantbusinesstype.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantBusinessTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case merchantbusinesstype.EdgeMerchants:
		return m.clearedmerchants
	case merchantbusinesstype.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantBusinessTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MerchantBusinessType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantBusinessTypeMutation) ResetEdge(name string) error {
	switch name {
	case merchantbusinesstype.EdgeMerchants:
		m.ResetMerchants()
		return nil
	case merchantbusinesstype.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown MerchantBusinessType edge %s", name)
}

// MerchantRenewalMutation represents an operation that mutates the MerchantRenewal nodes in the graph.
type MerchantRenewalMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *int64
	adddeleted_at          *int64
	purchase_duration      *int
	addpurchase_duration   *int
	purchase_duration_unit *domain.PurchaseDurationUnit
	operator_name          *string
	operator_account       *string
	clearedFields          map[string]struct{}
	merchant               *uuid.UUID
	clearedmerchant        bool
	done                   bool
	oldValue               func(context.Context) (*MerchantRenewal, error)
	predicates             []predicate.MerchantRenewal
}

var _ ent.Mutation = (*MerchantRenewalMutation)(nil)

// merchantrenewalOption allows management of the mutation configuration using functional options.
type merchantrenewalOption func(*MerchantRenewalMutation)

// newMerchantRenewalMutation creates new mutation for the MerchantRenewal entity.
func newMerchantRenewalMutation(c config, op Op, opts ...merchantrenewalOption) *MerchantRenewalMutation {
	m := &MerchantRenewalMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchantRenewal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantRenewalID sets the ID field of the mutation.
func withMerchantRenewalID(id uuid.UUID) merchantrenewalOption {
	return func(m *MerchantRenewalMutation) {
		var (
			err   error
			once  sync.Once
			value *MerchantRenewal
		)
		m.oldValue = func(ctx context.Context) (*MerchantRenewal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MerchantRenewal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchantRenewal sets the old MerchantRenewal of the mutation.
func withMerchantRenewal(node *MerchantRenewal) merchantrenewalOption {
	return func(m *MerchantRenewalMutation) {
		m.oldValue = func(context.Context) (*MerchantRenewal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantRenewalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantRenewalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MerchantRenewal entities.
func (m *MerchantRenewalMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantRenewalMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantRenewalMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MerchantRenewal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantRenewalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantRenewalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantRenewalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantRenewalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantRenewalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantRenewalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MerchantRenewalMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MerchantRenewalMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *MerchantRenewalMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *MerchantRenewalMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MerchantRenewalMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *MerchantRenewalMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *MerchantRenewalMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *MerchantRenewalMutation) ResetMerchantID() {
	m.merchant = nil
}

// SetPurchaseDuration sets the "purchase_duration" field.
func (m *MerchantRenewalMutation) SetPurchaseDuration(i int) {
	m.purchase_duration = &i
	m.addpurchase_duration = nil
}

// PurchaseDuration returns the value of the "purchase_duration" field in the mutation.
func (m *MerchantRenewalMutation) PurchaseDuration() (r int, exists bool) {
	v := m.purchase_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseDuration returns the old "purchase_duration" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldPurchaseDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseDuration: %w", err)
	}
	return oldValue.PurchaseDuration, nil
}

// AddPurchaseDuration adds i to the "purchase_duration" field.
func (m *MerchantRenewalMutation) AddPurchaseDuration(i int) {
	if m.addpurchase_duration != nil {
		*m.addpurchase_duration += i
	} else {
		m.addpurchase_duration = &i
	}
}

// AddedPurchaseDuration returns the value that was added to the "purchase_duration" field in this mutation.
func (m *MerchantRenewalMutation) AddedPurchaseDuration() (r int, exists bool) {
	v := m.addpurchase_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchaseDuration resets all changes to the "purchase_duration" field.
func (m *MerchantRenewalMutation) ResetPurchaseDuration() {
	m.purchase_duration = nil
	m.addpurchase_duration = nil
}

// SetPurchaseDurationUnit sets the "purchase_duration_unit" field.
func (m *MerchantRenewalMutation) SetPurchaseDurationUnit(ddu domain.PurchaseDurationUnit) {
	m.purchase_duration_unit = &ddu
}

// PurchaseDurationUnit returns the value of the "purchase_duration_unit" field in the mutation.
func (m *MerchantRenewalMutation) PurchaseDurationUnit() (r domain.PurchaseDurationUnit, exists bool) {
	v := m.purchase_duration_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseDurationUnit returns the old "purchase_duration_unit" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldPurchaseDurationUnit(ctx context.Context) (v domain.PurchaseDurationUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseDurationUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseDurationUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseDurationUnit: %w", err)
	}
	return oldValue.PurchaseDurationUnit, nil
}

// ResetPurchaseDurationUnit resets all changes to the "purchase_duration_unit" field.
func (m *MerchantRenewalMutation) ResetPurchaseDurationUnit() {
	m.purchase_duration_unit = nil
}

// SetOperatorName sets the "operator_name" field.
func (m *MerchantRenewalMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *MerchantRenewalMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *MerchantRenewalMutation) ResetOperatorName() {
	m.operator_name = nil
}

// SetOperatorAccount sets the "operator_account" field.
func (m *MerchantRenewalMutation) SetOperatorAccount(s string) {
	m.operator_account = &s
}

// OperatorAccount returns the value of the "operator_account" field in the mutation.
func (m *MerchantRenewalMutation) OperatorAccount() (r string, exists bool) {
	v := m.operator_account
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorAccount returns the old "operator_account" field's value of the MerchantRenewal entity.
// If the MerchantRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantRenewalMutation) OldOperatorAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorAccount: %w", err)
	}
	return oldValue.OperatorAccount, nil
}

// ResetOperatorAccount resets all changes to the "operator_account" field.
func (m *MerchantRenewalMutation) ResetOperatorAccount() {
	m.operator_account = nil
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *MerchantRenewalMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[merchantrenewal.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *MerchantRenewalMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *MerchantRenewalMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *MerchantRenewalMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the MerchantRenewalMutation builder.
func (m *MerchantRenewalMutation) Where(ps ...predicate.MerchantRenewal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MerchantRenewalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MerchantRenewalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MerchantRenewal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MerchantRenewalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MerchantRenewalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MerchantRenewal).
func (m *MerchantRenewalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantRenewalMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, merchantrenewal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchantrenewal.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, merchantrenewal.FieldDeletedAt)
	}
	if m.merchant != nil {
		fields = append(fields, merchantrenewal.FieldMerchantID)
	}
	if m.purchase_duration != nil {
		fields = append(fields, merchantrenewal.FieldPurchaseDuration)
	}
	if m.purchase_duration_unit != nil {
		fields = append(fields, merchantrenewal.FieldPurchaseDurationUnit)
	}
	if m.operator_name != nil {
		fields = append(fields, merchantrenewal.FieldOperatorName)
	}
	if m.operator_account != nil {
		fields = append(fields, merchantrenewal.FieldOperatorAccount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantRenewalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchantrenewal.FieldCreatedAt:
		return m.CreatedAt()
	case merchantrenewal.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchantrenewal.FieldDeletedAt:
		return m.DeletedAt()
	case merchantrenewal.FieldMerchantID:
		return m.MerchantID()
	case merchantrenewal.FieldPurchaseDuration:
		return m.PurchaseDuration()
	case merchantrenewal.FieldPurchaseDurationUnit:
		return m.PurchaseDurationUnit()
	case merchantrenewal.FieldOperatorName:
		return m.OperatorName()
	case merchantrenewal.FieldOperatorAccount:
		return m.OperatorAccount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantRenewalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchantrenewal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchantrenewal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchantrenewal.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case merchantrenewal.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case merchantrenewal.FieldPurchaseDuration:
		return m.OldPurchaseDuration(ctx)
	case merchantrenewal.FieldPurchaseDurationUnit:
		return m.OldPurchaseDurationUnit(ctx)
	case merchantrenewal.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case merchantrenewal.FieldOperatorAccount:
		return m.OldOperatorAccount(ctx)
	}
	return nil, fmt.Errorf("unknown MerchantRenewal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantRenewalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchantrenewal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchantrenewal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchantrenewal.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case merchantrenewal.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case merchantrenewal.FieldPurchaseDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseDuration(v)
		return nil
	case merchantrenewal.FieldPurchaseDurationUnit:
		v, ok := value.(domain.PurchaseDurationUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseDurationUnit(v)
		return nil
	case merchantrenewal.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case merchantrenewal.FieldOperatorAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorAccount(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantRenewal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantRenewalMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, merchantrenewal.FieldDeletedAt)
	}
	if m.addpurchase_duration != nil {
		fields = append(fields, merchantrenewal.FieldPurchaseDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantRenewalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case merchantrenewal.FieldDeletedAt:
		return m.AddedDeletedAt()
	case merchantrenewal.FieldPurchaseDuration:
		return m.AddedPurchaseDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantRenewalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case merchantrenewal.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case merchantrenewal.FieldPurchaseDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseDuration(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantRenewal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantRenewalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantRenewalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantRenewalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MerchantRenewal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantRenewalMutation) ResetField(name string) error {
	switch name {
	case merchantrenewal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchantrenewal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchantrenewal.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case merchantrenewal.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case merchantrenewal.FieldPurchaseDuration:
		m.ResetPurchaseDuration()
		return nil
	case merchantrenewal.FieldPurchaseDurationUnit:
		m.ResetPurchaseDurationUnit()
		return nil
	case merchantrenewal.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case merchantrenewal.FieldOperatorAccount:
		m.ResetOperatorAccount()
		return nil
	}
	return fmt.Errorf("unknown MerchantRenewal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantRenewalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.merchant != nil {
		edges = append(edges, merchantrenewal.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantRenewalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchantrenewal.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantRenewalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantRenewalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantRenewalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmerchant {
		edges = append(edges, merchantrenewal.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantRenewalMutation) EdgeCleared(name string) bool {
	switch name {
	case merchantrenewal.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantRenewalMutation) ClearEdge(name string) error {
	switch name {
	case merchantrenewal.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown MerchantRenewal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantRenewalMutation) ResetEdge(name string) error {
	switch name {
	case merchantrenewal.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown MerchantRenewal edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *int64
	adddeleted_at         *int64
	merchant_id           *uuid.UUID
	store_id              *uuid.UUID
	business_date         *string
	shift_no              *string
	order_no              *string
	order_type            *domain.OrderType
	placed_at             *time.Time
	paid_at               *time.Time
	completed_at          *time.Time
	placed_by             *uuid.UUID
	placed_by_name        *string
	dining_mode           *domain.DiningMode
	order_status          *domain.OrderStatus
	payment_status        *domain.PaymentStatus
	table_id              *uuid.UUID
	table_name            *string
	guest_count           *int
	addguest_count        *int
	store                 *domain.OrderStore
	channel               *domain.Channel
	pos                   *domain.OrderPOS
	cashier               *domain.OrderCashier
	tax_rates             *[]domain.OrderTaxRate
	appendtax_rates       []domain.OrderTaxRate
	fees                  *[]domain.OrderFee
	appendfees            []domain.OrderFee
	payments              *[]domain.OrderPayment
	appendpayments        []domain.OrderPayment
	amount                *domain.OrderAmount
	remark                *string
	clearedFields         map[string]struct{}
	order_products        map[uuid.UUID]struct{}
	removedorder_products map[uuid.UUID]struct{}
	clearedorder_products bool
	done                  bool
	oldValue              func(context.Context) (*Order, error)
	predicates            []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uuid.UUID) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *OrderMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *OrderMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *OrderMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *OrderMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *OrderMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *OrderMutation) ResetStoreID() {
	m.store_id = nil
}

// SetBusinessDate sets the "business_date" field.
func (m *OrderMutation) SetBusinessDate(s string) {
	m.business_date = &s
}

// BusinessDate returns the value of the "business_date" field in the mutation.
func (m *OrderMutation) BusinessDate() (r string, exists bool) {
	v := m.business_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessDate returns the old "business_date" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldBusinessDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessDate: %w", err)
	}
	return oldValue.BusinessDate, nil
}

// ResetBusinessDate resets all changes to the "business_date" field.
func (m *OrderMutation) ResetBusinessDate() {
	m.business_date = nil
}

// SetShiftNo sets the "shift_no" field.
func (m *OrderMutation) SetShiftNo(s string) {
	m.shift_no = &s
}

// ShiftNo returns the value of the "shift_no" field in the mutation.
func (m *OrderMutation) ShiftNo() (r string, exists bool) {
	v := m.shift_no
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftNo returns the old "shift_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShiftNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftNo: %w", err)
	}
	return oldValue.ShiftNo, nil
}

// ClearShiftNo clears the value of the "shift_no" field.
func (m *OrderMutation) ClearShiftNo() {
	m.shift_no = nil
	m.clearedFields[order.FieldShiftNo] = struct{}{}
}

// ShiftNoCleared returns if the "shift_no" field was cleared in this mutation.
func (m *OrderMutation) ShiftNoCleared() bool {
	_, ok := m.clearedFields[order.FieldShiftNo]
	return ok
}

// ResetShiftNo resets all changes to the "shift_no" field.
func (m *OrderMutation) ResetShiftNo() {
	m.shift_no = nil
	delete(m.clearedFields, order.FieldShiftNo)
}

// SetOrderNo sets the "order_no" field.
func (m *OrderMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetOrderType sets the "order_type" field.
func (m *OrderMutation) SetOrderType(dt domain.OrderType) {
	m.order_type = &dt
}

// OrderType returns the value of the "order_type" field in the mutation.
func (m *OrderMutation) OrderType() (r domain.OrderType, exists bool) {
	v := m.order_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderType returns the old "order_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderType(ctx context.Context) (v domain.OrderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderType: %w", err)
	}
	return oldValue.OrderType, nil
}

// ResetOrderType resets all changes to the "order_type" field.
func (m *OrderMutation) ResetOrderType() {
	m.order_type = nil
}

// SetPlacedAt sets the "placed_at" field.
func (m *OrderMutation) SetPlacedAt(t time.Time) {
	m.placed_at = &t
}

// PlacedAt returns the value of the "placed_at" field in the mutation.
func (m *OrderMutation) PlacedAt() (r time.Time, exists bool) {
	v := m.placed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacedAt returns the old "placed_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlacedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacedAt: %w", err)
	}
	return oldValue.PlacedAt, nil
}

// ClearPlacedAt clears the value of the "placed_at" field.
func (m *OrderMutation) ClearPlacedAt() {
	m.placed_at = nil
	m.clearedFields[order.FieldPlacedAt] = struct{}{}
}

// PlacedAtCleared returns if the "placed_at" field was cleared in this mutation.
func (m *OrderMutation) PlacedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldPlacedAt]
	return ok
}

// ResetPlacedAt resets all changes to the "placed_at" field.
func (m *OrderMutation) ResetPlacedAt() {
	m.placed_at = nil
	delete(m.clearedFields, order.FieldPlacedAt)
}

// SetPaidAt sets the "paid_at" field.
func (m *OrderMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *OrderMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *OrderMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[order.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *OrderMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[order.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *OrderMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, order.FieldPaidAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *OrderMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *OrderMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *OrderMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[order.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *OrderMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *OrderMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, order.FieldCompletedAt)
}

// SetPlacedBy sets the "placed_by" field.
func (m *OrderMutation) SetPlacedBy(u uuid.UUID) {
	m.placed_by = &u
}

// PlacedBy returns the value of the "placed_by" field in the mutation.
func (m *OrderMutation) PlacedBy() (r uuid.UUID, exists bool) {
	v := m.placed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacedBy returns the old "placed_by" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlacedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacedBy: %w", err)
	}
	return oldValue.PlacedBy, nil
}

// ClearPlacedBy clears the value of the "placed_by" field.
func (m *OrderMutation) ClearPlacedBy() {
	m.placed_by = nil
	m.clearedFields[order.FieldPlacedBy] = struct{}{}
}

// PlacedByCleared returns if the "placed_by" field was cleared in this mutation.
func (m *OrderMutation) PlacedByCleared() bool {
	_, ok := m.clearedFields[order.FieldPlacedBy]
	return ok
}

// ResetPlacedBy resets all changes to the "placed_by" field.
func (m *OrderMutation) ResetPlacedBy() {
	m.placed_by = nil
	delete(m.clearedFields, order.FieldPlacedBy)
}

// SetPlacedByName sets the "placed_by_name" field.
func (m *OrderMutation) SetPlacedByName(s string) {
	m.placed_by_name = &s
}

// PlacedByName returns the value of the "placed_by_name" field in the mutation.
func (m *OrderMutation) PlacedByName() (r string, exists bool) {
	v := m.placed_by_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacedByName returns the old "placed_by_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlacedByName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacedByName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacedByName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacedByName: %w", err)
	}
	return oldValue.PlacedByName, nil
}

// ClearPlacedByName clears the value of the "placed_by_name" field.
func (m *OrderMutation) ClearPlacedByName() {
	m.placed_by_name = nil
	m.clearedFields[order.FieldPlacedByName] = struct{}{}
}

// PlacedByNameCleared returns if the "placed_by_name" field was cleared in this mutation.
func (m *OrderMutation) PlacedByNameCleared() bool {
	_, ok := m.clearedFields[order.FieldPlacedByName]
	return ok
}

// ResetPlacedByName resets all changes to the "placed_by_name" field.
func (m *OrderMutation) ResetPlacedByName() {
	m.placed_by_name = nil
	delete(m.clearedFields, order.FieldPlacedByName)
}

// SetDiningMode sets the "dining_mode" field.
func (m *OrderMutation) SetDiningMode(dm domain.DiningMode) {
	m.dining_mode = &dm
}

// DiningMode returns the value of the "dining_mode" field in the mutation.
func (m *OrderMutation) DiningMode() (r domain.DiningMode, exists bool) {
	v := m.dining_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldDiningMode returns the old "dining_mode" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDiningMode(ctx context.Context) (v domain.DiningMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiningMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiningMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiningMode: %w", err)
	}
	return oldValue.DiningMode, nil
}

// ResetDiningMode resets all changes to the "dining_mode" field.
func (m *OrderMutation) ResetDiningMode() {
	m.dining_mode = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *OrderMutation) SetOrderStatus(ds domain.OrderStatus) {
	m.order_status = &ds
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *OrderMutation) OrderStatus() (r domain.OrderStatus, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderStatus(ctx context.Context) (v domain.OrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *OrderMutation) ResetOrderStatus() {
	m.order_status = nil
}

// SetPaymentStatus sets the "payment_status" field.
func (m *OrderMutation) SetPaymentStatus(ds domain.PaymentStatus) {
	m.payment_status = &ds
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *OrderMutation) PaymentStatus() (r domain.PaymentStatus, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaymentStatus(ctx context.Context) (v domain.PaymentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *OrderMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetTableID sets the "table_id" field.
func (m *OrderMutation) SetTableID(u uuid.UUID) {
	m.table_id = &u
}

// TableID returns the value of the "table_id" field in the mutation.
func (m *OrderMutation) TableID() (r uuid.UUID, exists bool) {
	v := m.table_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTableID returns the old "table_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTableID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableID: %w", err)
	}
	return oldValue.TableID, nil
}

// ClearTableID clears the value of the "table_id" field.
func (m *OrderMutation) ClearTableID() {
	m.table_id = nil
	m.clearedFields[order.FieldTableID] = struct{}{}
}

// TableIDCleared returns if the "table_id" field was cleared in this mutation.
func (m *OrderMutation) TableIDCleared() bool {
	_, ok := m.clearedFields[order.FieldTableID]
	return ok
}

// ResetTableID resets all changes to the "table_id" field.
func (m *OrderMutation) ResetTableID() {
	m.table_id = nil
	delete(m.clearedFields, order.FieldTableID)
}

// SetTableName sets the "table_name" field.
func (m *OrderMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *OrderMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ClearTableName clears the value of the "table_name" field.
func (m *OrderMutation) ClearTableName() {
	m.table_name = nil
	m.clearedFields[order.FieldTableName] = struct{}{}
}

// TableNameCleared returns if the "table_name" field was cleared in this mutation.
func (m *OrderMutation) TableNameCleared() bool {
	_, ok := m.clearedFields[order.FieldTableName]
	return ok
}

// ResetTableName resets all changes to the "table_name" field.
func (m *OrderMutation) ResetTableName() {
	m.table_name = nil
	delete(m.clearedFields, order.FieldTableName)
}

// SetGuestCount sets the "guest_count" field.
func (m *OrderMutation) SetGuestCount(i int) {
	m.guest_count = &i
	m.addguest_count = nil
}

// GuestCount returns the value of the "guest_count" field in the mutation.
func (m *OrderMutation) GuestCount() (r int, exists bool) {
	v := m.guest_count
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestCount returns the old "guest_count" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldGuestCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestCount: %w", err)
	}
	return oldValue.GuestCount, nil
}

// AddGuestCount adds i to the "guest_count" field.
func (m *OrderMutation) AddGuestCount(i int) {
	if m.addguest_count != nil {
		*m.addguest_count += i
	} else {
		m.addguest_count = &i
	}
}

// AddedGuestCount returns the value that was added to the "guest_count" field in this mutation.
func (m *OrderMutation) AddedGuestCount() (r int, exists bool) {
	v := m.addguest_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearGuestCount clears the value of the "guest_count" field.
func (m *OrderMutation) ClearGuestCount() {
	m.guest_count = nil
	m.addguest_count = nil
	m.clearedFields[order.FieldGuestCount] = struct{}{}
}

// GuestCountCleared returns if the "guest_count" field was cleared in this mutation.
func (m *OrderMutation) GuestCountCleared() bool {
	_, ok := m.clearedFields[order.FieldGuestCount]
	return ok
}

// ResetGuestCount resets all changes to the "guest_count" field.
func (m *OrderMutation) ResetGuestCount() {
	m.guest_count = nil
	m.addguest_count = nil
	delete(m.clearedFields, order.FieldGuestCount)
}

// SetStore sets the "store" field.
func (m *OrderMutation) SetStore(ds domain.OrderStore) {
	m.store = &ds
}

// Store returns the value of the "store" field in the mutation.
func (m *OrderMutation) Store() (r domain.OrderStore, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStore returns the old "store" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStore(ctx context.Context) (v domain.OrderStore, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStore: %w", err)
	}
	return oldValue.Store, nil
}

// ResetStore resets all changes to the "store" field.
func (m *OrderMutation) ResetStore() {
	m.store = nil
}

// SetChannel sets the "channel" field.
func (m *OrderMutation) SetChannel(d domain.Channel) {
	m.channel = &d
}

// Channel returns the value of the "channel" field in the mutation.
func (m *OrderMutation) Channel() (r domain.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannel(ctx context.Context) (v domain.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *OrderMutation) ResetChannel() {
	m.channel = nil
}

// SetPos sets the "pos" field.
func (m *OrderMutation) SetPos(dp domain.OrderPOS) {
	m.pos = &dp
}

// Pos returns the value of the "pos" field in the mutation.
func (m *OrderMutation) Pos() (r domain.OrderPOS, exists bool) {
	v := m.pos
	if v == nil {
		return
	}
	return *v, true
}

// OldPos returns the old "pos" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPos(ctx context.Context) (v domain.OrderPOS, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPos: %w", err)
	}
	return oldValue.Pos, nil
}

// ResetPos resets all changes to the "pos" field.
func (m *OrderMutation) ResetPos() {
	m.pos = nil
}

// SetCashier sets the "cashier" field.
func (m *OrderMutation) SetCashier(dc domain.OrderCashier) {
	m.cashier = &dc
}

// Cashier returns the value of the "cashier" field in the mutation.
func (m *OrderMutation) Cashier() (r domain.OrderCashier, exists bool) {
	v := m.cashier
	if v == nil {
		return
	}
	return *v, true
}

// OldCashier returns the old "cashier" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCashier(ctx context.Context) (v domain.OrderCashier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashier: %w", err)
	}
	return oldValue.Cashier, nil
}

// ResetCashier resets all changes to the "cashier" field.
func (m *OrderMutation) ResetCashier() {
	m.cashier = nil
}

// SetTaxRates sets the "tax_rates" field.
func (m *OrderMutation) SetTaxRates(dtr []domain.OrderTaxRate) {
	m.tax_rates = &dtr
	m.appendtax_rates = nil
}

// TaxRates returns the value of the "tax_rates" field in the mutation.
func (m *OrderMutation) TaxRates() (r []domain.OrderTaxRate, exists bool) {
	v := m.tax_rates
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRates returns the old "tax_rates" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTaxRates(ctx context.Context) (v []domain.OrderTaxRate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRates: %w", err)
	}
	return oldValue.TaxRates, nil
}

// AppendTaxRates adds dtr to the "tax_rates" field.
func (m *OrderMutation) AppendTaxRates(dtr []domain.OrderTaxRate) {
	m.appendtax_rates = append(m.appendtax_rates, dtr...)
}

// AppendedTaxRates returns the list of values that were appended to the "tax_rates" field in this mutation.
func (m *OrderMutation) AppendedTaxRates() ([]domain.OrderTaxRate, bool) {
	if len(m.appendtax_rates) == 0 {
		return nil, false
	}
	return m.appendtax_rates, true
}

// ClearTaxRates clears the value of the "tax_rates" field.
func (m *OrderMutation) ClearTaxRates() {
	m.tax_rates = nil
	m.appendtax_rates = nil
	m.clearedFields[order.FieldTaxRates] = struct{}{}
}

// TaxRatesCleared returns if the "tax_rates" field was cleared in this mutation.
func (m *OrderMutation) TaxRatesCleared() bool {
	_, ok := m.clearedFields[order.FieldTaxRates]
	return ok
}

// ResetTaxRates resets all changes to the "tax_rates" field.
func (m *OrderMutation) ResetTaxRates() {
	m.tax_rates = nil
	m.appendtax_rates = nil
	delete(m.clearedFields, order.FieldTaxRates)
}

// SetFees sets the "fees" field.
func (m *OrderMutation) SetFees(df []domain.OrderFee) {
	m.fees = &df
	m.appendfees = nil
}

// Fees returns the value of the "fees" field in the mutation.
func (m *OrderMutation) Fees() (r []domain.OrderFee, exists bool) {
	v := m.fees
	if v == nil {
		return
	}
	return *v, true
}

// OldFees returns the old "fees" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFees(ctx context.Context) (v []domain.OrderFee, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFees: %w", err)
	}
	return oldValue.Fees, nil
}

// AppendFees adds df to the "fees" field.
func (m *OrderMutation) AppendFees(df []domain.OrderFee) {
	m.appendfees = append(m.appendfees, df...)
}

// AppendedFees returns the list of values that were appended to the "fees" field in this mutation.
func (m *OrderMutation) AppendedFees() ([]domain.OrderFee, bool) {
	if len(m.appendfees) == 0 {
		return nil, false
	}
	return m.appendfees, true
}

// ClearFees clears the value of the "fees" field.
func (m *OrderMutation) ClearFees() {
	m.fees = nil
	m.appendfees = nil
	m.clearedFields[order.FieldFees] = struct{}{}
}

// FeesCleared returns if the "fees" field was cleared in this mutation.
func (m *OrderMutation) FeesCleared() bool {
	_, ok := m.clearedFields[order.FieldFees]
	return ok
}

// ResetFees resets all changes to the "fees" field.
func (m *OrderMutation) ResetFees() {
	m.fees = nil
	m.appendfees = nil
	delete(m.clearedFields, order.FieldFees)
}

// SetPayments sets the "payments" field.
func (m *OrderMutation) SetPayments(dp []domain.OrderPayment) {
	m.payments = &dp
	m.appendpayments = nil
}

// Payments returns the value of the "payments" field in the mutation.
func (m *OrderMutation) Payments() (r []domain.OrderPayment, exists bool) {
	v := m.payments
	if v == nil {
		return
	}
	return *v, true
}

// OldPayments returns the old "payments" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPayments(ctx context.Context) (v []domain.OrderPayment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayments: %w", err)
	}
	return oldValue.Payments, nil
}

// AppendPayments adds dp to the "payments" field.
func (m *OrderMutation) AppendPayments(dp []domain.OrderPayment) {
	m.appendpayments = append(m.appendpayments, dp...)
}

// AppendedPayments returns the list of values that were appended to the "payments" field in this mutation.
func (m *OrderMutation) AppendedPayments() ([]domain.OrderPayment, bool) {
	if len(m.appendpayments) == 0 {
		return nil, false
	}
	return m.appendpayments, true
}

// ClearPayments clears the value of the "payments" field.
func (m *OrderMutation) ClearPayments() {
	m.payments = nil
	m.appendpayments = nil
	m.clearedFields[order.FieldPayments] = struct{}{}
}

// PaymentsCleared returns if the "payments" field was cleared in this mutation.
func (m *OrderMutation) PaymentsCleared() bool {
	_, ok := m.clearedFields[order.FieldPayments]
	return ok
}

// ResetPayments resets all changes to the "payments" field.
func (m *OrderMutation) ResetPayments() {
	m.payments = nil
	m.appendpayments = nil
	delete(m.clearedFields, order.FieldPayments)
}

// SetAmount sets the "amount" field.
func (m *OrderMutation) SetAmount(da domain.OrderAmount) {
	m.amount = &da
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderMutation) Amount() (r domain.OrderAmount, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAmount(ctx context.Context) (v domain.OrderAmount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
}

// SetRemark sets the "remark" field.
func (m *OrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[order.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[order.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, order.FieldRemark)
}

// AddOrderProductIDs adds the "order_products" edge to the OrderProduct entity by ids.
func (m *OrderMutation) AddOrderProductIDs(ids ...uuid.UUID) {
	if m.order_products == nil {
		m.order_products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.order_products[ids[i]] = struct{}{}
	}
}

// ClearOrderProducts clears the "order_products" edge to the OrderProduct entity.
func (m *OrderMutation) ClearOrderProducts() {
	m.clearedorder_products = true
}

// OrderProductsCleared reports if the "order_products" edge to the OrderProduct entity was cleared.
func (m *OrderMutation) OrderProductsCleared() bool {
	return m.clearedorder_products
}

// RemoveOrderProductIDs removes the "order_products" edge to the OrderProduct entity by IDs.
func (m *OrderMutation) RemoveOrderProductIDs(ids ...uuid.UUID) {
	if m.removedorder_products == nil {
		m.removedorder_products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.order_products, ids[i])
		m.removedorder_products[ids[i]] = struct{}{}
	}
}

// RemovedOrderProducts returns the removed IDs of the "order_products" edge to the OrderProduct entity.
func (m *OrderMutation) RemovedOrderProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedorder_products {
		ids = append(ids, id)
	}
	return
}

// OrderProductsIDs returns the "order_products" edge IDs in the mutation.
func (m *OrderMutation) OrderProductsIDs() (ids []uuid.UUID) {
	for id := range m.order_products {
		ids = append(ids, id)
	}
	return
}

// ResetOrderProducts resets all changes to the "order_products" edge.
func (m *OrderMutation) ResetOrderProducts() {
	m.order_products = nil
	m.clearedorder_products = false
	m.removedorder_products = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.merchant_id != nil {
		fields = append(fields, order.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, order.FieldStoreID)
	}
	if m.business_date != nil {
		fields = append(fields, order.FieldBusinessDate)
	}
	if m.shift_no != nil {
		fields = append(fields, order.FieldShiftNo)
	}
	if m.order_no != nil {
		fields = append(fields, order.FieldOrderNo)
	}
	if m.order_type != nil {
		fields = append(fields, order.FieldOrderType)
	}
	if m.placed_at != nil {
		fields = append(fields, order.FieldPlacedAt)
	}
	if m.paid_at != nil {
		fields = append(fields, order.FieldPaidAt)
	}
	if m.completed_at != nil {
		fields = append(fields, order.FieldCompletedAt)
	}
	if m.placed_by != nil {
		fields = append(fields, order.FieldPlacedBy)
	}
	if m.placed_by_name != nil {
		fields = append(fields, order.FieldPlacedByName)
	}
	if m.dining_mode != nil {
		fields = append(fields, order.FieldDiningMode)
	}
	if m.order_status != nil {
		fields = append(fields, order.FieldOrderStatus)
	}
	if m.payment_status != nil {
		fields = append(fields, order.FieldPaymentStatus)
	}
	if m.table_id != nil {
		fields = append(fields, order.FieldTableID)
	}
	if m.table_name != nil {
		fields = append(fields, order.FieldTableName)
	}
	if m.guest_count != nil {
		fields = append(fields, order.FieldGuestCount)
	}
	if m.store != nil {
		fields = append(fields, order.FieldStore)
	}
	if m.channel != nil {
		fields = append(fields, order.FieldChannel)
	}
	if m.pos != nil {
		fields = append(fields, order.FieldPos)
	}
	if m.cashier != nil {
		fields = append(fields, order.FieldCashier)
	}
	if m.tax_rates != nil {
		fields = append(fields, order.FieldTaxRates)
	}
	if m.fees != nil {
		fields = append(fields, order.FieldFees)
	}
	if m.payments != nil {
		fields = append(fields, order.FieldPayments)
	}
	if m.amount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.remark != nil {
		fields = append(fields, order.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldMerchantID:
		return m.MerchantID()
	case order.FieldStoreID:
		return m.StoreID()
	case order.FieldBusinessDate:
		return m.BusinessDate()
	case order.FieldShiftNo:
		return m.ShiftNo()
	case order.FieldOrderNo:
		return m.OrderNo()
	case order.FieldOrderType:
		return m.OrderType()
	case order.FieldPlacedAt:
		return m.PlacedAt()
	case order.FieldPaidAt:
		return m.PaidAt()
	case order.FieldCompletedAt:
		return m.CompletedAt()
	case order.FieldPlacedBy:
		return m.PlacedBy()
	case order.FieldPlacedByName:
		return m.PlacedByName()
	case order.FieldDiningMode:
		return m.DiningMode()
	case order.FieldOrderStatus:
		return m.OrderStatus()
	case order.FieldPaymentStatus:
		return m.PaymentStatus()
	case order.FieldTableID:
		return m.TableID()
	case order.FieldTableName:
		return m.TableName()
	case order.FieldGuestCount:
		return m.GuestCount()
	case order.FieldStore:
		return m.Store()
	case order.FieldChannel:
		return m.Channel()
	case order.FieldPos:
		return m.Pos()
	case order.FieldCashier:
		return m.Cashier()
	case order.FieldTaxRates:
		return m.TaxRates()
	case order.FieldFees:
		return m.Fees()
	case order.FieldPayments:
		return m.Payments()
	case order.FieldAmount:
		return m.Amount()
	case order.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case order.FieldStoreID:
		return m.OldStoreID(ctx)
	case order.FieldBusinessDate:
		return m.OldBusinessDate(ctx)
	case order.FieldShiftNo:
		return m.OldShiftNo(ctx)
	case order.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case order.FieldOrderType:
		return m.OldOrderType(ctx)
	case order.FieldPlacedAt:
		return m.OldPlacedAt(ctx)
	case order.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case order.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case order.FieldPlacedBy:
		return m.OldPlacedBy(ctx)
	case order.FieldPlacedByName:
		return m.OldPlacedByName(ctx)
	case order.FieldDiningMode:
		return m.OldDiningMode(ctx)
	case order.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	case order.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case order.FieldTableID:
		return m.OldTableID(ctx)
	case order.FieldTableName:
		return m.OldTableName(ctx)
	case order.FieldGuestCount:
		return m.OldGuestCount(ctx)
	case order.FieldStore:
		return m.OldStore(ctx)
	case order.FieldChannel:
		return m.OldChannel(ctx)
	case order.FieldPos:
		return m.OldPos(ctx)
	case order.FieldCashier:
		return m.OldCashier(ctx)
	case order.FieldTaxRates:
		return m.OldTaxRates(ctx)
	case order.FieldFees:
		return m.OldFees(ctx)
	case order.FieldPayments:
		return m.OldPayments(ctx)
	case order.FieldAmount:
		return m.OldAmount(ctx)
	case order.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case order.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case order.FieldBusinessDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessDate(v)
		return nil
	case order.FieldShiftNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftNo(v)
		return nil
	case order.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case order.FieldOrderType:
		v, ok := value.(domain.OrderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderType(v)
		return nil
	case order.FieldPlacedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacedAt(v)
		return nil
	case order.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case order.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case order.FieldPlacedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacedBy(v)
		return nil
	case order.FieldPlacedByName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacedByName(v)
		return nil
	case order.FieldDiningMode:
		v, ok := value.(domain.DiningMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiningMode(v)
		return nil
	case order.FieldOrderStatus:
		v, ok := value.(domain.OrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	case order.FieldPaymentStatus:
		v, ok := value.(domain.PaymentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case order.FieldTableID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableID(v)
		return nil
	case order.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case order.FieldGuestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestCount(v)
		return nil
	case order.FieldStore:
		v, ok := value.(domain.OrderStore)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStore(v)
		return nil
	case order.FieldChannel:
		v, ok := value.(domain.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case order.FieldPos:
		v, ok := value.(domain.OrderPOS)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPos(v)
		return nil
	case order.FieldCashier:
		v, ok := value.(domain.OrderCashier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashier(v)
		return nil
	case order.FieldTaxRates:
		v, ok := value.([]domain.OrderTaxRate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRates(v)
		return nil
	case order.FieldFees:
		v, ok := value.([]domain.OrderFee)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFees(v)
		return nil
	case order.FieldPayments:
		v, ok := value.([]domain.OrderPayment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayments(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(domain.OrderAmount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case order.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.addguest_count != nil {
		fields = append(fields, order.FieldGuestCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldDeletedAt:
		return m.AddedDeletedAt()
	case order.FieldGuestCount:
		return m.AddedGuestCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case order.FieldGuestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuestCount(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldShiftNo) {
		fields = append(fields, order.FieldShiftNo)
	}
	if m.FieldCleared(order.FieldPlacedAt) {
		fields = append(fields, order.FieldPlacedAt)
	}
	if m.FieldCleared(order.FieldPaidAt) {
		fields = append(fields, order.FieldPaidAt)
	}
	if m.FieldCleared(order.FieldCompletedAt) {
		fields = append(fields, order.FieldCompletedAt)
	}
	if m.FieldCleared(order.FieldPlacedBy) {
		fields = append(fields, order.FieldPlacedBy)
	}
	if m.FieldCleared(order.FieldPlacedByName) {
		fields = append(fields, order.FieldPlacedByName)
	}
	if m.FieldCleared(order.FieldTableID) {
		fields = append(fields, order.FieldTableID)
	}
	if m.FieldCleared(order.FieldTableName) {
		fields = append(fields, order.FieldTableName)
	}
	if m.FieldCleared(order.FieldGuestCount) {
		fields = append(fields, order.FieldGuestCount)
	}
	if m.FieldCleared(order.FieldTaxRates) {
		fields = append(fields, order.FieldTaxRates)
	}
	if m.FieldCleared(order.FieldFees) {
		fields = append(fields, order.FieldFees)
	}
	if m.FieldCleared(order.FieldPayments) {
		fields = append(fields, order.FieldPayments)
	}
	if m.FieldCleared(order.FieldRemark) {
		fields = append(fields, order.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldShiftNo:
		m.ClearShiftNo()
		return nil
	case order.FieldPlacedAt:
		m.ClearPlacedAt()
		return nil
	case order.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case order.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case order.FieldPlacedBy:
		m.ClearPlacedBy()
		return nil
	case order.FieldPlacedByName:
		m.ClearPlacedByName()
		return nil
	case order.FieldTableID:
		m.ClearTableID()
		return nil
	case order.FieldTableName:
		m.ClearTableName()
		return nil
	case order.FieldGuestCount:
		m.ClearGuestCount()
		return nil
	case order.FieldTaxRates:
		m.ClearTaxRates()
		return nil
	case order.FieldFees:
		m.ClearFees()
		return nil
	case order.FieldPayments:
		m.ClearPayments()
		return nil
	case order.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case order.FieldStoreID:
		m.ResetStoreID()
		return nil
	case order.FieldBusinessDate:
		m.ResetBusinessDate()
		return nil
	case order.FieldShiftNo:
		m.ResetShiftNo()
		return nil
	case order.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case order.FieldOrderType:
		m.ResetOrderType()
		return nil
	case order.FieldPlacedAt:
		m.ResetPlacedAt()
		return nil
	case order.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case order.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case order.FieldPlacedBy:
		m.ResetPlacedBy()
		return nil
	case order.FieldPlacedByName:
		m.ResetPlacedByName()
		return nil
	case order.FieldDiningMode:
		m.ResetDiningMode()
		return nil
	case order.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	case order.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case order.FieldTableID:
		m.ResetTableID()
		return nil
	case order.FieldTableName:
		m.ResetTableName()
		return nil
	case order.FieldGuestCount:
		m.ResetGuestCount()
		return nil
	case order.FieldStore:
		m.ResetStore()
		return nil
	case order.FieldChannel:
		m.ResetChannel()
		return nil
	case order.FieldPos:
		m.ResetPos()
		return nil
	case order.FieldCashier:
		m.ResetCashier()
		return nil
	case order.FieldTaxRates:
		m.ResetTaxRates()
		return nil
	case order.FieldFees:
		m.ResetFees()
		return nil
	case order.FieldPayments:
		m.ResetPayments()
		return nil
	case order.FieldAmount:
		m.ResetAmount()
		return nil
	case order.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order_products != nil {
		edges = append(edges, order.EdgeOrderProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderProducts:
		ids := make([]ent.Value, 0, len(m.order_products))
		for id := range m.order_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorder_products != nil {
		edges = append(edges, order.EdgeOrderProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderProducts:
		ids := make([]ent.Value, 0, len(m.removedorder_products))
		for id := range m.removedorder_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder_products {
		edges = append(edges, order.EdgeOrderProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeOrderProducts:
		return m.clearedorder_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeOrderProducts:
		m.ResetOrderProducts()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderProductMutation represents an operation that mutates the OrderProduct nodes in the graph.
type OrderProductMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int64
	adddeleted_at        *int64
	order_item_id        *string
	index                *int
	addindex             *int
	product_id           *uuid.UUID
	product_name         *string
	product_type         *domain.ProductType
	category_id          *uuid.UUID
	unit_id              *uuid.UUID
	main_image           *string
	description          *string
	is_gift              *bool
	qty                  *int
	addqty               *int
	gift_qty             *int
	addgift_qty          *int
	subtotal             *decimal.Decimal
	discount_amount      *decimal.Decimal
	amount_before_tax    *decimal.Decimal
	tax_rate             *decimal.Decimal
	tax                  *decimal.Decimal
	amount_after_tax     *decimal.Decimal
	total                *decimal.Decimal
	promotion_discount   *decimal.Decimal
	void_qty             *int
	addvoid_qty          *int
	void_amount          *decimal.Decimal
	refund_reason        *string
	refunded_by          *uuid.UUID
	refunded_at          *time.Time
	note                 *string
	price                *decimal.Decimal
	groups               *domain.SetMealGroups
	appendgroups         domain.SetMealGroups
	spec_relations       *domain.ProductSpecRelations
	appendspec_relations domain.ProductSpecRelations
	attr_relations       *domain.ProductAttrRelations
	appendattr_relations domain.ProductAttrRelations
	clearedFields        map[string]struct{}
	_order               *uuid.UUID
	cleared_order        bool
	done                 bool
	oldValue             func(context.Context) (*OrderProduct, error)
	predicates           []predicate.OrderProduct
}

var _ ent.Mutation = (*OrderProductMutation)(nil)

// orderproductOption allows management of the mutation configuration using functional options.
type orderproductOption func(*OrderProductMutation)

// newOrderProductMutation creates new mutation for the OrderProduct entity.
func newOrderProductMutation(c config, op Op, opts ...orderproductOption) *OrderProductMutation {
	m := &OrderProductMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderProductID sets the ID field of the mutation.
func withOrderProductID(id uuid.UUID) orderproductOption {
	return func(m *OrderProductMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderProduct
		)
		m.oldValue = func(ctx context.Context) (*OrderProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderProduct sets the old OrderProduct of the mutation.
func withOrderProduct(node *OrderProduct) orderproductOption {
	return func(m *OrderProductMutation) {
		m.oldValue = func(context.Context) (*OrderProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderProduct entities.
func (m *OrderProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderProductMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderProductMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderProductMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *OrderProductMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderProductMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderProductMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderProductMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderProductMutation) ResetOrderID() {
	m._order = nil
}

// SetOrderItemID sets the "order_item_id" field.
func (m *OrderProductMutation) SetOrderItemID(s string) {
	m.order_item_id = &s
}

// OrderItemID returns the value of the "order_item_id" field in the mutation.
func (m *OrderProductMutation) OrderItemID() (r string, exists bool) {
	v := m.order_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemID returns the old "order_item_id" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldOrderItemID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemID: %w", err)
	}
	return oldValue.OrderItemID, nil
}

// ResetOrderItemID resets all changes to the "order_item_id" field.
func (m *OrderProductMutation) ResetOrderItemID() {
	m.order_item_id = nil
}

// SetIndex sets the "index" field.
func (m *OrderProductMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *OrderProductMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *OrderProductMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *OrderProductMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *OrderProductMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderProductMutation) SetProductID(u uuid.UUID) {
	m.product_id = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderProductMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderProductMutation) ResetProductID() {
	m.product_id = nil
}

// SetProductName sets the "product_name" field.
func (m *OrderProductMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *OrderProductMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *OrderProductMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductType sets the "product_type" field.
func (m *OrderProductMutation) SetProductType(dt domain.ProductType) {
	m.product_type = &dt
}

// ProductType returns the value of the "product_type" field in the mutation.
func (m *OrderProductMutation) ProductType() (r domain.ProductType, exists bool) {
	v := m.product_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProductType returns the old "product_type" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldProductType(ctx context.Context) (v domain.ProductType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductType: %w", err)
	}
	return oldValue.ProductType, nil
}

// ResetProductType resets all changes to the "product_type" field.
func (m *OrderProductMutation) ResetProductType() {
	m.product_type = nil
}

// SetCategoryID sets the "category_id" field.
func (m *OrderProductMutation) SetCategoryID(u uuid.UUID) {
	m.category_id = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *OrderProductMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *OrderProductMutation) ClearCategoryID() {
	m.category_id = nil
	m.clearedFields[orderproduct.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *OrderProductMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *OrderProductMutation) ResetCategoryID() {
	m.category_id = nil
	delete(m.clearedFields, orderproduct.FieldCategoryID)
}

// SetUnitID sets the "unit_id" field.
func (m *OrderProductMutation) SetUnitID(u uuid.UUID) {
	m.unit_id = &u
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *OrderProductMutation) UnitID() (r uuid.UUID, exists bool) {
	v := m.unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ClearUnitID clears the value of the "unit_id" field.
func (m *OrderProductMutation) ClearUnitID() {
	m.unit_id = nil
	m.clearedFields[orderproduct.FieldUnitID] = struct{}{}
}

// UnitIDCleared returns if the "unit_id" field was cleared in this mutation.
func (m *OrderProductMutation) UnitIDCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldUnitID]
	return ok
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *OrderProductMutation) ResetUnitID() {
	m.unit_id = nil
	delete(m.clearedFields, orderproduct.FieldUnitID)
}

// SetMainImage sets the "main_image" field.
func (m *OrderProductMutation) SetMainImage(s string) {
	m.main_image = &s
}

// MainImage returns the value of the "main_image" field in the mutation.
func (m *OrderProductMutation) MainImage() (r string, exists bool) {
	v := m.main_image
	if v == nil {
		return
	}
	return *v, true
}

// OldMainImage returns the old "main_image" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldMainImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainImage: %w", err)
	}
	return oldValue.MainImage, nil
}

// ResetMainImage resets all changes to the "main_image" field.
func (m *OrderProductMutation) ResetMainImage() {
	m.main_image = nil
}

// SetDescription sets the "description" field.
func (m *OrderProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrderProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OrderProductMutation) ResetDescription() {
	m.description = nil
}

// SetIsGift sets the "is_gift" field.
func (m *OrderProductMutation) SetIsGift(b bool) {
	m.is_gift = &b
}

// IsGift returns the value of the "is_gift" field in the mutation.
func (m *OrderProductMutation) IsGift() (r bool, exists bool) {
	v := m.is_gift
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGift returns the old "is_gift" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldIsGift(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGift is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGift requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGift: %w", err)
	}
	return oldValue.IsGift, nil
}

// ResetIsGift resets all changes to the "is_gift" field.
func (m *OrderProductMutation) ResetIsGift() {
	m.is_gift = nil
}

// SetQty sets the "qty" field.
func (m *OrderProductMutation) SetQty(i int) {
	m.qty = &i
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *OrderProductMutation) Qty() (r int, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds i to the "qty" field.
func (m *OrderProductMutation) AddQty(i int) {
	if m.addqty != nil {
		*m.addqty += i
	} else {
		m.addqty = &i
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *OrderProductMutation) AddedQty() (r int, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *OrderProductMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetGiftQty sets the "gift_qty" field.
func (m *OrderProductMutation) SetGiftQty(i int) {
	m.gift_qty = &i
	m.addgift_qty = nil
}

// GiftQty returns the value of the "gift_qty" field in the mutation.
func (m *OrderProductMutation) GiftQty() (r int, exists bool) {
	v := m.gift_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftQty returns the old "gift_qty" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldGiftQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftQty: %w", err)
	}
	return oldValue.GiftQty, nil
}

// AddGiftQty adds i to the "gift_qty" field.
func (m *OrderProductMutation) AddGiftQty(i int) {
	if m.addgift_qty != nil {
		*m.addgift_qty += i
	} else {
		m.addgift_qty = &i
	}
}

// AddedGiftQty returns the value that was added to the "gift_qty" field in this mutation.
func (m *OrderProductMutation) AddedGiftQty() (r int, exists bool) {
	v := m.addgift_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetGiftQty resets all changes to the "gift_qty" field.
func (m *OrderProductMutation) ResetGiftQty() {
	m.gift_qty = nil
	m.addgift_qty = nil
}

// SetSubtotal sets the "subtotal" field.
func (m *OrderProductMutation) SetSubtotal(d decimal.Decimal) {
	m.subtotal = &d
}

// Subtotal returns the value of the "subtotal" field in the mutation.
func (m *OrderProductMutation) Subtotal() (r decimal.Decimal, exists bool) {
	v := m.subtotal
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtotal returns the old "subtotal" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldSubtotal(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtotal: %w", err)
	}
	return oldValue.Subtotal, nil
}

// ClearSubtotal clears the value of the "subtotal" field.
func (m *OrderProductMutation) ClearSubtotal() {
	m.subtotal = nil
	m.clearedFields[orderproduct.FieldSubtotal] = struct{}{}
}

// SubtotalCleared returns if the "subtotal" field was cleared in this mutation.
func (m *OrderProductMutation) SubtotalCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldSubtotal]
	return ok
}

// ResetSubtotal resets all changes to the "subtotal" field.
func (m *OrderProductMutation) ResetSubtotal() {
	m.subtotal = nil
	delete(m.clearedFields, orderproduct.FieldSubtotal)
}

// SetDiscountAmount sets the "discount_amount" field.
func (m *OrderProductMutation) SetDiscountAmount(d decimal.Decimal) {
	m.discount_amount = &d
}

// DiscountAmount returns the value of the "discount_amount" field in the mutation.
func (m *OrderProductMutation) DiscountAmount() (r decimal.Decimal, exists bool) {
	v := m.discount_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountAmount returns the old "discount_amount" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldDiscountAmount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountAmount: %w", err)
	}
	return oldValue.DiscountAmount, nil
}

// ClearDiscountAmount clears the value of the "discount_amount" field.
func (m *OrderProductMutation) ClearDiscountAmount() {
	m.discount_amount = nil
	m.clearedFields[orderproduct.FieldDiscountAmount] = struct{}{}
}

// DiscountAmountCleared returns if the "discount_amount" field was cleared in this mutation.
func (m *OrderProductMutation) DiscountAmountCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldDiscountAmount]
	return ok
}

// ResetDiscountAmount resets all changes to the "discount_amount" field.
func (m *OrderProductMutation) ResetDiscountAmount() {
	m.discount_amount = nil
	delete(m.clearedFields, orderproduct.FieldDiscountAmount)
}

// SetAmountBeforeTax sets the "amount_before_tax" field.
func (m *OrderProductMutation) SetAmountBeforeTax(d decimal.Decimal) {
	m.amount_before_tax = &d
}

// AmountBeforeTax returns the value of the "amount_before_tax" field in the mutation.
func (m *OrderProductMutation) AmountBeforeTax() (r decimal.Decimal, exists bool) {
	v := m.amount_before_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountBeforeTax returns the old "amount_before_tax" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldAmountBeforeTax(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountBeforeTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountBeforeTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountBeforeTax: %w", err)
	}
	return oldValue.AmountBeforeTax, nil
}

// ClearAmountBeforeTax clears the value of the "amount_before_tax" field.
func (m *OrderProductMutation) ClearAmountBeforeTax() {
	m.amount_before_tax = nil
	m.clearedFields[orderproduct.FieldAmountBeforeTax] = struct{}{}
}

// AmountBeforeTaxCleared returns if the "amount_before_tax" field was cleared in this mutation.
func (m *OrderProductMutation) AmountBeforeTaxCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldAmountBeforeTax]
	return ok
}

// ResetAmountBeforeTax resets all changes to the "amount_before_tax" field.
func (m *OrderProductMutation) ResetAmountBeforeTax() {
	m.amount_before_tax = nil
	delete(m.clearedFields, orderproduct.FieldAmountBeforeTax)
}

// SetTaxRate sets the "tax_rate" field.
func (m *OrderProductMutation) SetTaxRate(d decimal.Decimal) {
	m.tax_rate = &d
}

// TaxRate returns the value of the "tax_rate" field in the mutation.
func (m *OrderProductMutation) TaxRate() (r decimal.Decimal, exists bool) {
	v := m.tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRate returns the old "tax_rate" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldTaxRate(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRate: %w", err)
	}
	return oldValue.TaxRate, nil
}

// ClearTaxRate clears the value of the "tax_rate" field.
func (m *OrderProductMutation) ClearTaxRate() {
	m.tax_rate = nil
	m.clearedFields[orderproduct.FieldTaxRate] = struct{}{}
}

// TaxRateCleared returns if the "tax_rate" field was cleared in this mutation.
func (m *OrderProductMutation) TaxRateCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldTaxRate]
	return ok
}

// ResetTaxRate resets all changes to the "tax_rate" field.
func (m *OrderProductMutation) ResetTaxRate() {
	m.tax_rate = nil
	delete(m.clearedFields, orderproduct.FieldTaxRate)
}

// SetTax sets the "tax" field.
func (m *OrderProductMutation) SetTax(d decimal.Decimal) {
	m.tax = &d
}

// Tax returns the value of the "tax" field in the mutation.
func (m *OrderProductMutation) Tax() (r decimal.Decimal, exists bool) {
	v := m.tax
	if v == nil {
		return
	}
	return *v, true
}

// OldTax returns the old "tax" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldTax(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTax: %w", err)
	}
	return oldValue.Tax, nil
}

// ClearTax clears the value of the "tax" field.
func (m *OrderProductMutation) ClearTax() {
	m.tax = nil
	m.clearedFields[orderproduct.FieldTax] = struct{}{}
}

// TaxCleared returns if the "tax" field was cleared in this mutation.
func (m *OrderProductMutation) TaxCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldTax]
	return ok
}

// ResetTax resets all changes to the "tax" field.
func (m *OrderProductMutation) ResetTax() {
	m.tax = nil
	delete(m.clearedFields, orderproduct.FieldTax)
}

// SetAmountAfterTax sets the "amount_after_tax" field.
func (m *OrderProductMutation) SetAmountAfterTax(d decimal.Decimal) {
	m.amount_after_tax = &d
}

// AmountAfterTax returns the value of the "amount_after_tax" field in the mutation.
func (m *OrderProductMutation) AmountAfterTax() (r decimal.Decimal, exists bool) {
	v := m.amount_after_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountAfterTax returns the old "amount_after_tax" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldAmountAfterTax(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountAfterTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountAfterTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountAfterTax: %w", err)
	}
	return oldValue.AmountAfterTax, nil
}

// ClearAmountAfterTax clears the value of the "amount_after_tax" field.
func (m *OrderProductMutation) ClearAmountAfterTax() {
	m.amount_after_tax = nil
	m.clearedFields[orderproduct.FieldAmountAfterTax] = struct{}{}
}

// AmountAfterTaxCleared returns if the "amount_after_tax" field was cleared in this mutation.
func (m *OrderProductMutation) AmountAfterTaxCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldAmountAfterTax]
	return ok
}

// ResetAmountAfterTax resets all changes to the "amount_after_tax" field.
func (m *OrderProductMutation) ResetAmountAfterTax() {
	m.amount_after_tax = nil
	delete(m.clearedFields, orderproduct.FieldAmountAfterTax)
}

// SetTotal sets the "total" field.
func (m *OrderProductMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderProductMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldTotal(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ClearTotal clears the value of the "total" field.
func (m *OrderProductMutation) ClearTotal() {
	m.total = nil
	m.clearedFields[orderproduct.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *OrderProductMutation) TotalCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderProductMutation) ResetTotal() {
	m.total = nil
	delete(m.clearedFields, orderproduct.FieldTotal)
}

// SetPromotionDiscount sets the "promotion_discount" field.
func (m *OrderProductMutation) SetPromotionDiscount(d decimal.Decimal) {
	m.promotion_discount = &d
}

// PromotionDiscount returns the value of the "promotion_discount" field in the mutation.
func (m *OrderProductMutation) PromotionDiscount() (r decimal.Decimal, exists bool) {
	v := m.promotion_discount
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionDiscount returns the old "promotion_discount" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldPromotionDiscount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionDiscount: %w", err)
	}
	return oldValue.PromotionDiscount, nil
}

// ClearPromotionDiscount clears the value of the "promotion_discount" field.
func (m *OrderProductMutation) ClearPromotionDiscount() {
	m.promotion_discount = nil
	m.clearedFields[orderproduct.FieldPromotionDiscount] = struct{}{}
}

// PromotionDiscountCleared returns if the "promotion_discount" field was cleared in this mutation.
func (m *OrderProductMutation) PromotionDiscountCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldPromotionDiscount]
	return ok
}

// ResetPromotionDiscount resets all changes to the "promotion_discount" field.
func (m *OrderProductMutation) ResetPromotionDiscount() {
	m.promotion_discount = nil
	delete(m.clearedFields, orderproduct.FieldPromotionDiscount)
}

// SetVoidQty sets the "void_qty" field.
func (m *OrderProductMutation) SetVoidQty(i int) {
	m.void_qty = &i
	m.addvoid_qty = nil
}

// VoidQty returns the value of the "void_qty" field in the mutation.
func (m *OrderProductMutation) VoidQty() (r int, exists bool) {
	v := m.void_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidQty returns the old "void_qty" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldVoidQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidQty: %w", err)
	}
	return oldValue.VoidQty, nil
}

// AddVoidQty adds i to the "void_qty" field.
func (m *OrderProductMutation) AddVoidQty(i int) {
	if m.addvoid_qty != nil {
		*m.addvoid_qty += i
	} else {
		m.addvoid_qty = &i
	}
}

// AddedVoidQty returns the value that was added to the "void_qty" field in this mutation.
func (m *OrderProductMutation) AddedVoidQty() (r int, exists bool) {
	v := m.addvoid_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoidQty resets all changes to the "void_qty" field.
func (m *OrderProductMutation) ResetVoidQty() {
	m.void_qty = nil
	m.addvoid_qty = nil
}

// SetVoidAmount sets the "void_amount" field.
func (m *OrderProductMutation) SetVoidAmount(d decimal.Decimal) {
	m.void_amount = &d
}

// VoidAmount returns the value of the "void_amount" field in the mutation.
func (m *OrderProductMutation) VoidAmount() (r decimal.Decimal, exists bool) {
	v := m.void_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidAmount returns the old "void_amount" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldVoidAmount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidAmount: %w", err)
	}
	return oldValue.VoidAmount, nil
}

// ClearVoidAmount clears the value of the "void_amount" field.
func (m *OrderProductMutation) ClearVoidAmount() {
	m.void_amount = nil
	m.clearedFields[orderproduct.FieldVoidAmount] = struct{}{}
}

// VoidAmountCleared returns if the "void_amount" field was cleared in this mutation.
func (m *OrderProductMutation) VoidAmountCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldVoidAmount]
	return ok
}

// ResetVoidAmount resets all changes to the "void_amount" field.
func (m *OrderProductMutation) ResetVoidAmount() {
	m.void_amount = nil
	delete(m.clearedFields, orderproduct.FieldVoidAmount)
}

// SetRefundReason sets the "refund_reason" field.
func (m *OrderProductMutation) SetRefundReason(s string) {
	m.refund_reason = &s
}

// RefundReason returns the value of the "refund_reason" field in the mutation.
func (m *OrderProductMutation) RefundReason() (r string, exists bool) {
	v := m.refund_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundReason returns the old "refund_reason" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldRefundReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundReason: %w", err)
	}
	return oldValue.RefundReason, nil
}

// ClearRefundReason clears the value of the "refund_reason" field.
func (m *OrderProductMutation) ClearRefundReason() {
	m.refund_reason = nil
	m.clearedFields[orderproduct.FieldRefundReason] = struct{}{}
}

// RefundReasonCleared returns if the "refund_reason" field was cleared in this mutation.
func (m *OrderProductMutation) RefundReasonCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldRefundReason]
	return ok
}

// ResetRefundReason resets all changes to the "refund_reason" field.
func (m *OrderProductMutation) ResetRefundReason() {
	m.refund_reason = nil
	delete(m.clearedFields, orderproduct.FieldRefundReason)
}

// SetRefundedBy sets the "refunded_by" field.
func (m *OrderProductMutation) SetRefundedBy(u uuid.UUID) {
	m.refunded_by = &u
}

// RefundedBy returns the value of the "refunded_by" field in the mutation.
func (m *OrderProductMutation) RefundedBy() (r uuid.UUID, exists bool) {
	v := m.refunded_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundedBy returns the old "refunded_by" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldRefundedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundedBy: %w", err)
	}
	return oldValue.RefundedBy, nil
}

// ClearRefundedBy clears the value of the "refunded_by" field.
func (m *OrderProductMutation) ClearRefundedBy() {
	m.refunded_by = nil
	m.clearedFields[orderproduct.FieldRefundedBy] = struct{}{}
}

// RefundedByCleared returns if the "refunded_by" field was cleared in this mutation.
func (m *OrderProductMutation) RefundedByCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldRefundedBy]
	return ok
}

// ResetRefundedBy resets all changes to the "refunded_by" field.
func (m *OrderProductMutation) ResetRefundedBy() {
	m.refunded_by = nil
	delete(m.clearedFields, orderproduct.FieldRefundedBy)
}

// SetRefundedAt sets the "refunded_at" field.
func (m *OrderProductMutation) SetRefundedAt(t time.Time) {
	m.refunded_at = &t
}

// RefundedAt returns the value of the "refunded_at" field in the mutation.
func (m *OrderProductMutation) RefundedAt() (r time.Time, exists bool) {
	v := m.refunded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundedAt returns the old "refunded_at" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldRefundedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundedAt: %w", err)
	}
	return oldValue.RefundedAt, nil
}

// ClearRefundedAt clears the value of the "refunded_at" field.
func (m *OrderProductMutation) ClearRefundedAt() {
	m.refunded_at = nil
	m.clearedFields[orderproduct.FieldRefundedAt] = struct{}{}
}

// RefundedAtCleared returns if the "refunded_at" field was cleared in this mutation.
func (m *OrderProductMutation) RefundedAtCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldRefundedAt]
	return ok
}

// ResetRefundedAt resets all changes to the "refunded_at" field.
func (m *OrderProductMutation) ResetRefundedAt() {
	m.refunded_at = nil
	delete(m.clearedFields, orderproduct.FieldRefundedAt)
}

// SetNote sets the "note" field.
func (m *OrderProductMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderProductMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderProductMutation) ClearNote() {
	m.note = nil
	m.clearedFields[orderproduct.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderProductMutation) NoteCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderProductMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, orderproduct.FieldNote)
}

// SetPrice sets the "price" field.
func (m *OrderProductMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderProductMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *OrderProductMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[orderproduct.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *OrderProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderProductMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, orderproduct.FieldPrice)
}

// SetGroups sets the "groups" field.
func (m *OrderProductMutation) SetGroups(dmg domain.SetMealGroups) {
	m.groups = &dmg
	m.appendgroups = nil
}

// Groups returns the value of the "groups" field in the mutation.
func (m *OrderProductMutation) Groups() (r domain.SetMealGroups, exists bool) {
	v := m.groups
	if v == nil {
		return
	}
	return *v, true
}

// OldGroups returns the old "groups" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldGroups(ctx context.Context) (v domain.SetMealGroups, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroups: %w", err)
	}
	return oldValue.Groups, nil
}

// AppendGroups adds dmg to the "groups" field.
func (m *OrderProductMutation) AppendGroups(dmg domain.SetMealGroups) {
	m.appendgroups = append(m.appendgroups, dmg...)
}

// AppendedGroups returns the list of values that were appended to the "groups" field in this mutation.
func (m *OrderProductMutation) AppendedGroups() (domain.SetMealGroups, bool) {
	if len(m.appendgroups) == 0 {
		return nil, false
	}
	return m.appendgroups, true
}

// ClearGroups clears the value of the "groups" field.
func (m *OrderProductMutation) ClearGroups() {
	m.groups = nil
	m.appendgroups = nil
	m.clearedFields[orderproduct.FieldGroups] = struct{}{}
}

// GroupsCleared returns if the "groups" field was cleared in this mutation.
func (m *OrderProductMutation) GroupsCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldGroups]
	return ok
}

// ResetGroups resets all changes to the "groups" field.
func (m *OrderProductMutation) ResetGroups() {
	m.groups = nil
	m.appendgroups = nil
	delete(m.clearedFields, orderproduct.FieldGroups)
}

// SetSpecRelations sets the "spec_relations" field.
func (m *OrderProductMutation) SetSpecRelations(dsr domain.ProductSpecRelations) {
	m.spec_relations = &dsr
	m.appendspec_relations = nil
}

// SpecRelations returns the value of the "spec_relations" field in the mutation.
func (m *OrderProductMutation) SpecRelations() (r domain.ProductSpecRelations, exists bool) {
	v := m.spec_relations
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecRelations returns the old "spec_relations" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldSpecRelations(ctx context.Context) (v domain.ProductSpecRelations, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecRelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecRelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecRelations: %w", err)
	}
	return oldValue.SpecRelations, nil
}

// AppendSpecRelations adds dsr to the "spec_relations" field.
func (m *OrderProductMutation) AppendSpecRelations(dsr domain.ProductSpecRelations) {
	m.appendspec_relations = append(m.appendspec_relations, dsr...)
}

// AppendedSpecRelations returns the list of values that were appended to the "spec_relations" field in this mutation.
func (m *OrderProductMutation) AppendedSpecRelations() (domain.ProductSpecRelations, bool) {
	if len(m.appendspec_relations) == 0 {
		return nil, false
	}
	return m.appendspec_relations, true
}

// ClearSpecRelations clears the value of the "spec_relations" field.
func (m *OrderProductMutation) ClearSpecRelations() {
	m.spec_relations = nil
	m.appendspec_relations = nil
	m.clearedFields[orderproduct.FieldSpecRelations] = struct{}{}
}

// SpecRelationsCleared returns if the "spec_relations" field was cleared in this mutation.
func (m *OrderProductMutation) SpecRelationsCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldSpecRelations]
	return ok
}

// ResetSpecRelations resets all changes to the "spec_relations" field.
func (m *OrderProductMutation) ResetSpecRelations() {
	m.spec_relations = nil
	m.appendspec_relations = nil
	delete(m.clearedFields, orderproduct.FieldSpecRelations)
}

// SetAttrRelations sets the "attr_relations" field.
func (m *OrderProductMutation) SetAttrRelations(dar domain.ProductAttrRelations) {
	m.attr_relations = &dar
	m.appendattr_relations = nil
}

// AttrRelations returns the value of the "attr_relations" field in the mutation.
func (m *OrderProductMutation) AttrRelations() (r domain.ProductAttrRelations, exists bool) {
	v := m.attr_relations
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrRelations returns the old "attr_relations" field's value of the OrderProduct entity.
// If the OrderProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderProductMutation) OldAttrRelations(ctx context.Context) (v domain.ProductAttrRelations, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrRelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrRelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrRelations: %w", err)
	}
	return oldValue.AttrRelations, nil
}

// AppendAttrRelations adds dar to the "attr_relations" field.
func (m *OrderProductMutation) AppendAttrRelations(dar domain.ProductAttrRelations) {
	m.appendattr_relations = append(m.appendattr_relations, dar...)
}

// AppendedAttrRelations returns the list of values that were appended to the "attr_relations" field in this mutation.
func (m *OrderProductMutation) AppendedAttrRelations() (domain.ProductAttrRelations, bool) {
	if len(m.appendattr_relations) == 0 {
		return nil, false
	}
	return m.appendattr_relations, true
}

// ClearAttrRelations clears the value of the "attr_relations" field.
func (m *OrderProductMutation) ClearAttrRelations() {
	m.attr_relations = nil
	m.appendattr_relations = nil
	m.clearedFields[orderproduct.FieldAttrRelations] = struct{}{}
}

// AttrRelationsCleared returns if the "attr_relations" field was cleared in this mutation.
func (m *OrderProductMutation) AttrRelationsCleared() bool {
	_, ok := m.clearedFields[orderproduct.FieldAttrRelations]
	return ok
}

// ResetAttrRelations resets all changes to the "attr_relations" field.
func (m *OrderProductMutation) ResetAttrRelations() {
	m.attr_relations = nil
	m.appendattr_relations = nil
	delete(m.clearedFields, orderproduct.FieldAttrRelations)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderProductMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderproduct.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderProductMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderProductMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderProductMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderProductMutation builder.
func (m *OrderProductMutation) Where(ps ...predicate.OrderProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderProduct).
func (m *OrderProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderProductMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.created_at != nil {
		fields = append(fields, orderproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderproduct.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderproduct.FieldDeletedAt)
	}
	if m._order != nil {
		fields = append(fields, orderproduct.FieldOrderID)
	}
	if m.order_item_id != nil {
		fields = append(fields, orderproduct.FieldOrderItemID)
	}
	if m.index != nil {
		fields = append(fields, orderproduct.FieldIndex)
	}
	if m.product_id != nil {
		fields = append(fields, orderproduct.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, orderproduct.FieldProductName)
	}
	if m.product_type != nil {
		fields = append(fields, orderproduct.FieldProductType)
	}
	if m.category_id != nil {
		fields = append(fields, orderproduct.FieldCategoryID)
	}
	if m.unit_id != nil {
		fields = append(fields, orderproduct.FieldUnitID)
	}
	if m.main_image != nil {
		fields = append(fields, orderproduct.FieldMainImage)
	}
	if m.description != nil {
		fields = append(fields, orderproduct.FieldDescription)
	}
	if m.is_gift != nil {
		fields = append(fields, orderproduct.FieldIsGift)
	}
	if m.qty != nil {
		fields = append(fields, orderproduct.FieldQty)
	}
	if m.gift_qty != nil {
		fields = append(fields, orderproduct.FieldGiftQty)
	}
	if m.subtotal != nil {
		fields = append(fields, orderproduct.FieldSubtotal)
	}
	if m.discount_amount != nil {
		fields = append(fields, orderproduct.FieldDiscountAmount)
	}
	if m.amount_before_tax != nil {
		fields = append(fields, orderproduct.FieldAmountBeforeTax)
	}
	if m.tax_rate != nil {
		fields = append(fields, orderproduct.FieldTaxRate)
	}
	if m.tax != nil {
		fields = append(fields, orderproduct.FieldTax)
	}
	if m.amount_after_tax != nil {
		fields = append(fields, orderproduct.FieldAmountAfterTax)
	}
	if m.total != nil {
		fields = append(fields, orderproduct.FieldTotal)
	}
	if m.promotion_discount != nil {
		fields = append(fields, orderproduct.FieldPromotionDiscount)
	}
	if m.void_qty != nil {
		fields = append(fields, orderproduct.FieldVoidQty)
	}
	if m.void_amount != nil {
		fields = append(fields, orderproduct.FieldVoidAmount)
	}
	if m.refund_reason != nil {
		fields = append(fields, orderproduct.FieldRefundReason)
	}
	if m.refunded_by != nil {
		fields = append(fields, orderproduct.FieldRefundedBy)
	}
	if m.refunded_at != nil {
		fields = append(fields, orderproduct.FieldRefundedAt)
	}
	if m.note != nil {
		fields = append(fields, orderproduct.FieldNote)
	}
	if m.price != nil {
		fields = append(fields, orderproduct.FieldPrice)
	}
	if m.groups != nil {
		fields = append(fields, orderproduct.FieldGroups)
	}
	if m.spec_relations != nil {
		fields = append(fields, orderproduct.FieldSpecRelations)
	}
	if m.attr_relations != nil {
		fields = append(fields, orderproduct.FieldAttrRelations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderproduct.FieldCreatedAt:
		return m.CreatedAt()
	case orderproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderproduct.FieldDeletedAt:
		return m.DeletedAt()
	case orderproduct.FieldOrderID:
		return m.OrderID()
	case orderproduct.FieldOrderItemID:
		return m.OrderItemID()
	case orderproduct.FieldIndex:
		return m.Index()
	case orderproduct.FieldProductID:
		return m.ProductID()
	case orderproduct.FieldProductName:
		return m.ProductName()
	case orderproduct.FieldProductType:
		return m.ProductType()
	case orderproduct.FieldCategoryID:
		return m.CategoryID()
	case orderproduct.FieldUnitID:
		return m.UnitID()
	case orderproduct.FieldMainImage:
		return m.MainImage()
	case orderproduct.FieldDescription:
		return m.Description()
	case orderproduct.FieldIsGift:
		return m.IsGift()
	case orderproduct.FieldQty:
		return m.Qty()
	case orderproduct.FieldGiftQty:
		return m.GiftQty()
	case orderproduct.FieldSubtotal:
		return m.Subtotal()
	case orderproduct.FieldDiscountAmount:
		return m.DiscountAmount()
	case orderproduct.FieldAmountBeforeTax:
		return m.AmountBeforeTax()
	case orderproduct.FieldTaxRate:
		return m.TaxRate()
	case orderproduct.FieldTax:
		return m.Tax()
	case orderproduct.FieldAmountAfterTax:
		return m.AmountAfterTax()
	case orderproduct.FieldTotal:
		return m.Total()
	case orderproduct.FieldPromotionDiscount:
		return m.PromotionDiscount()
	case orderproduct.FieldVoidQty:
		return m.VoidQty()
	case orderproduct.FieldVoidAmount:
		return m.VoidAmount()
	case orderproduct.FieldRefundReason:
		return m.RefundReason()
	case orderproduct.FieldRefundedBy:
		return m.RefundedBy()
	case orderproduct.FieldRefundedAt:
		return m.RefundedAt()
	case orderproduct.FieldNote:
		return m.Note()
	case orderproduct.FieldPrice:
		return m.Price()
	case orderproduct.FieldGroups:
		return m.Groups()
	case orderproduct.FieldSpecRelations:
		return m.SpecRelations()
	case orderproduct.FieldAttrRelations:
		return m.AttrRelations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderproduct.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderproduct.FieldOrderItemID:
		return m.OldOrderItemID(ctx)
	case orderproduct.FieldIndex:
		return m.OldIndex(ctx)
	case orderproduct.FieldProductID:
		return m.OldProductID(ctx)
	case orderproduct.FieldProductName:
		return m.OldProductName(ctx)
	case orderproduct.FieldProductType:
		return m.OldProductType(ctx)
	case orderproduct.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case orderproduct.FieldUnitID:
		return m.OldUnitID(ctx)
	case orderproduct.FieldMainImage:
		return m.OldMainImage(ctx)
	case orderproduct.FieldDescription:
		return m.OldDescription(ctx)
	case orderproduct.FieldIsGift:
		return m.OldIsGift(ctx)
	case orderproduct.FieldQty:
		return m.OldQty(ctx)
	case orderproduct.FieldGiftQty:
		return m.OldGiftQty(ctx)
	case orderproduct.FieldSubtotal:
		return m.OldSubtotal(ctx)
	case orderproduct.FieldDiscountAmount:
		return m.OldDiscountAmount(ctx)
	case orderproduct.FieldAmountBeforeTax:
		return m.OldAmountBeforeTax(ctx)
	case orderproduct.FieldTaxRate:
		return m.OldTaxRate(ctx)
	case orderproduct.FieldTax:
		return m.OldTax(ctx)
	case orderproduct.FieldAmountAfterTax:
		return m.OldAmountAfterTax(ctx)
	case orderproduct.FieldTotal:
		return m.OldTotal(ctx)
	case orderproduct.FieldPromotionDiscount:
		return m.OldPromotionDiscount(ctx)
	case orderproduct.FieldVoidQty:
		return m.OldVoidQty(ctx)
	case orderproduct.FieldVoidAmount:
		return m.OldVoidAmount(ctx)
	case orderproduct.FieldRefundReason:
		return m.OldRefundReason(ctx)
	case orderproduct.FieldRefundedBy:
		return m.OldRefundedBy(ctx)
	case orderproduct.FieldRefundedAt:
		return m.OldRefundedAt(ctx)
	case orderproduct.FieldNote:
		return m.OldNote(ctx)
	case orderproduct.FieldPrice:
		return m.OldPrice(ctx)
	case orderproduct.FieldGroups:
		return m.OldGroups(ctx)
	case orderproduct.FieldSpecRelations:
		return m.OldSpecRelations(ctx)
	case orderproduct.FieldAttrRelations:
		return m.OldAttrRelations(ctx)
	}
	return nil, fmt.Errorf("unknown OrderProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderproduct.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderproduct.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderproduct.FieldOrderItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemID(v)
		return nil
	case orderproduct.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case orderproduct.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderproduct.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case orderproduct.FieldProductType:
		v, ok := value.(domain.ProductType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductType(v)
		return nil
	case orderproduct.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case orderproduct.FieldUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case orderproduct.FieldMainImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainImage(v)
		return nil
	case orderproduct.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case orderproduct.FieldIsGift:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGift(v)
		return nil
	case orderproduct.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case orderproduct.FieldGiftQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftQty(v)
		return nil
	case orderproduct.FieldSubtotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtotal(v)
		return nil
	case orderproduct.FieldDiscountAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountAmount(v)
		return nil
	case orderproduct.FieldAmountBeforeTax:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountBeforeTax(v)
		return nil
	case orderproduct.FieldTaxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRate(v)
		return nil
	case orderproduct.FieldTax:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTax(v)
		return nil
	case orderproduct.FieldAmountAfterTax:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountAfterTax(v)
		return nil
	case orderproduct.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case orderproduct.FieldPromotionDiscount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionDiscount(v)
		return nil
	case orderproduct.FieldVoidQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidQty(v)
		return nil
	case orderproduct.FieldVoidAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidAmount(v)
		return nil
	case orderproduct.FieldRefundReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundReason(v)
		return nil
	case orderproduct.FieldRefundedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundedBy(v)
		return nil
	case orderproduct.FieldRefundedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundedAt(v)
		return nil
	case orderproduct.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case orderproduct.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case orderproduct.FieldGroups:
		v, ok := value.(domain.SetMealGroups)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroups(v)
		return nil
	case orderproduct.FieldSpecRelations:
		v, ok := value.(domain.ProductSpecRelations)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecRelations(v)
		return nil
	case orderproduct.FieldAttrRelations:
		v, ok := value.(domain.ProductAttrRelations)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrRelations(v)
		return nil
	}
	return fmt.Errorf("unknown OrderProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderProductMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, orderproduct.FieldDeletedAt)
	}
	if m.addindex != nil {
		fields = append(fields, orderproduct.FieldIndex)
	}
	if m.addqty != nil {
		fields = append(fields, orderproduct.FieldQty)
	}
	if m.addgift_qty != nil {
		fields = append(fields, orderproduct.FieldGiftQty)
	}
	if m.addvoid_qty != nil {
		fields = append(fields, orderproduct.FieldVoidQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderproduct.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderproduct.FieldIndex:
		return m.AddedIndex()
	case orderproduct.FieldQty:
		return m.AddedQty()
	case orderproduct.FieldGiftQty:
		return m.AddedGiftQty()
	case orderproduct.FieldVoidQty:
		return m.AddedVoidQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderproduct.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderproduct.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case orderproduct.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case orderproduct.FieldGiftQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGiftQty(v)
		return nil
	case orderproduct.FieldVoidQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoidQty(v)
		return nil
	}
	return fmt.Errorf("unknown OrderProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderproduct.FieldCategoryID) {
		fields = append(fields, orderproduct.FieldCategoryID)
	}
	if m.FieldCleared(orderproduct.FieldUnitID) {
		fields = append(fields, orderproduct.FieldUnitID)
	}
	if m.FieldCleared(orderproduct.FieldSubtotal) {
		fields = append(fields, orderproduct.FieldSubtotal)
	}
	if m.FieldCleared(orderproduct.FieldDiscountAmount) {
		fields = append(fields, orderproduct.FieldDiscountAmount)
	}
	if m.FieldCleared(orderproduct.FieldAmountBeforeTax) {
		fields = append(fields, orderproduct.FieldAmountBeforeTax)
	}
	if m.FieldCleared(orderproduct.FieldTaxRate) {
		fields = append(fields, orderproduct.FieldTaxRate)
	}
	if m.FieldCleared(orderproduct.FieldTax) {
		fields = append(fields, orderproduct.FieldTax)
	}
	if m.FieldCleared(orderproduct.FieldAmountAfterTax) {
		fields = append(fields, orderproduct.FieldAmountAfterTax)
	}
	if m.FieldCleared(orderproduct.FieldTotal) {
		fields = append(fields, orderproduct.FieldTotal)
	}
	if m.FieldCleared(orderproduct.FieldPromotionDiscount) {
		fields = append(fields, orderproduct.FieldPromotionDiscount)
	}
	if m.FieldCleared(orderproduct.FieldVoidAmount) {
		fields = append(fields, orderproduct.FieldVoidAmount)
	}
	if m.FieldCleared(orderproduct.FieldRefundReason) {
		fields = append(fields, orderproduct.FieldRefundReason)
	}
	if m.FieldCleared(orderproduct.FieldRefundedBy) {
		fields = append(fields, orderproduct.FieldRefundedBy)
	}
	if m.FieldCleared(orderproduct.FieldRefundedAt) {
		fields = append(fields, orderproduct.FieldRefundedAt)
	}
	if m.FieldCleared(orderproduct.FieldNote) {
		fields = append(fields, orderproduct.FieldNote)
	}
	if m.FieldCleared(orderproduct.FieldPrice) {
		fields = append(fields, orderproduct.FieldPrice)
	}
	if m.FieldCleared(orderproduct.FieldGroups) {
		fields = append(fields, orderproduct.FieldGroups)
	}
	if m.FieldCleared(orderproduct.FieldSpecRelations) {
		fields = append(fields, orderproduct.FieldSpecRelations)
	}
	if m.FieldCleared(orderproduct.FieldAttrRelations) {
		fields = append(fields, orderproduct.FieldAttrRelations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderProductMutation) ClearField(name string) error {
	switch name {
	case orderproduct.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case orderproduct.FieldUnitID:
		m.ClearUnitID()
		return nil
	case orderproduct.FieldSubtotal:
		m.ClearSubtotal()
		return nil
	case orderproduct.FieldDiscountAmount:
		m.ClearDiscountAmount()
		return nil
	case orderproduct.FieldAmountBeforeTax:
		m.ClearAmountBeforeTax()
		return nil
	case orderproduct.FieldTaxRate:
		m.ClearTaxRate()
		return nil
	case orderproduct.FieldTax:
		m.ClearTax()
		return nil
	case orderproduct.FieldAmountAfterTax:
		m.ClearAmountAfterTax()
		return nil
	case orderproduct.FieldTotal:
		m.ClearTotal()
		return nil
	case orderproduct.FieldPromotionDiscount:
		m.ClearPromotionDiscount()
		return nil
	case orderproduct.FieldVoidAmount:
		m.ClearVoidAmount()
		return nil
	case orderproduct.FieldRefundReason:
		m.ClearRefundReason()
		return nil
	case orderproduct.FieldRefundedBy:
		m.ClearRefundedBy()
		return nil
	case orderproduct.FieldRefundedAt:
		m.ClearRefundedAt()
		return nil
	case orderproduct.FieldNote:
		m.ClearNote()
		return nil
	case orderproduct.FieldPrice:
		m.ClearPrice()
		return nil
	case orderproduct.FieldGroups:
		m.ClearGroups()
		return nil
	case orderproduct.FieldSpecRelations:
		m.ClearSpecRelations()
		return nil
	case orderproduct.FieldAttrRelations:
		m.ClearAttrRelations()
		return nil
	}
	return fmt.Errorf("unknown OrderProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderProductMutation) ResetField(name string) error {
	switch name {
	case orderproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderproduct.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderproduct.FieldOrderItemID:
		m.ResetOrderItemID()
		return nil
	case orderproduct.FieldIndex:
		m.ResetIndex()
		return nil
	case orderproduct.FieldProductID:
		m.ResetProductID()
		return nil
	case orderproduct.FieldProductName:
		m.ResetProductName()
		return nil
	case orderproduct.FieldProductType:
		m.ResetProductType()
		return nil
	case orderproduct.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case orderproduct.FieldUnitID:
		m.ResetUnitID()
		return nil
	case orderproduct.FieldMainImage:
		m.ResetMainImage()
		return nil
	case orderproduct.FieldDescription:
		m.ResetDescription()
		return nil
	case orderproduct.FieldIsGift:
		m.ResetIsGift()
		return nil
	case orderproduct.FieldQty:
		m.ResetQty()
		return nil
	case orderproduct.FieldGiftQty:
		m.ResetGiftQty()
		return nil
	case orderproduct.FieldSubtotal:
		m.ResetSubtotal()
		return nil
	case orderproduct.FieldDiscountAmount:
		m.ResetDiscountAmount()
		return nil
	case orderproduct.FieldAmountBeforeTax:
		m.ResetAmountBeforeTax()
		return nil
	case orderproduct.FieldTaxRate:
		m.ResetTaxRate()
		return nil
	case orderproduct.FieldTax:
		m.ResetTax()
		return nil
	case orderproduct.FieldAmountAfterTax:
		m.ResetAmountAfterTax()
		return nil
	case orderproduct.FieldTotal:
		m.ResetTotal()
		return nil
	case orderproduct.FieldPromotionDiscount:
		m.ResetPromotionDiscount()
		return nil
	case orderproduct.FieldVoidQty:
		m.ResetVoidQty()
		return nil
	case orderproduct.FieldVoidAmount:
		m.ResetVoidAmount()
		return nil
	case orderproduct.FieldRefundReason:
		m.ResetRefundReason()
		return nil
	case orderproduct.FieldRefundedBy:
		m.ResetRefundedBy()
		return nil
	case orderproduct.FieldRefundedAt:
		m.ResetRefundedAt()
		return nil
	case orderproduct.FieldNote:
		m.ResetNote()
		return nil
	case orderproduct.FieldPrice:
		m.ResetPrice()
		return nil
	case orderproduct.FieldGroups:
		m.ResetGroups()
		return nil
	case orderproduct.FieldSpecRelations:
		m.ResetSpecRelations()
		return nil
	case orderproduct.FieldAttrRelations:
		m.ResetAttrRelations()
		return nil
	}
	return fmt.Errorf("unknown OrderProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderproduct.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderproduct.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderproduct.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderProductMutation) EdgeCleared(name string) bool {
	switch name {
	case orderproduct.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderProductMutation) ClearEdge(name string) error {
	switch name {
	case orderproduct.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderProductMutation) ResetEdge(name string) error {
	switch name {
	case orderproduct.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderProduct edge %s", name)
}

// PaymentMethodMutation represents an operation that mutates the PaymentMethod nodes in the graph.
type PaymentMethodMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *int64
	adddeleted_at            *int64
	source_payment_method_id *uuid.UUID
	merchant_id              *uuid.UUID
	store_id                 *uuid.UUID
	name                     *string
	accounting_rule          *domain.PaymentMethodAccountingRule
	payment_type             *domain.PaymentMethodPayType
	fee_rate                 *decimal.Decimal
	invoice_rule             *domain.PaymentMethodInvoiceRule
	cash_drawer_status       *bool
	display_channels         *[]domain.PaymentMethodDisplayChannel
	appenddisplay_channels   []domain.PaymentMethodDisplayChannel
	source                   *domain.PaymentMethodSource
	status                   *bool
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*PaymentMethod, error)
	predicates               []predicate.PaymentMethod
}

var _ ent.Mutation = (*PaymentMethodMutation)(nil)

// paymentmethodOption allows management of the mutation configuration using functional options.
type paymentmethodOption func(*PaymentMethodMutation)

// newPaymentMethodMutation creates new mutation for the PaymentMethod entity.
func newPaymentMethodMutation(c config, op Op, opts ...paymentmethodOption) *PaymentMethodMutation {
	m := &PaymentMethodMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentMethod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentMethodID sets the ID field of the mutation.
func withPaymentMethodID(id uuid.UUID) paymentmethodOption {
	return func(m *PaymentMethodMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentMethod
		)
		m.oldValue = func(ctx context.Context) (*PaymentMethod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentMethod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentMethod sets the old PaymentMethod of the mutation.
func withPaymentMethod(node *PaymentMethod) paymentmethodOption {
	return func(m *PaymentMethodMutation) {
		m.oldValue = func(context.Context) (*PaymentMethod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMethodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMethodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentMethod entities.
func (m *PaymentMethodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMethodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMethodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentMethod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMethodMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMethodMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMethodMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMethodMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMethodMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMethodMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PaymentMethodMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PaymentMethodMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PaymentMethodMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PaymentMethodMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PaymentMethodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetSourcePaymentMethodID sets the "source_payment_method_id" field.
func (m *PaymentMethodMutation) SetSourcePaymentMethodID(u uuid.UUID) {
	m.source_payment_method_id = &u
}

// SourcePaymentMethodID returns the value of the "source_payment_method_id" field in the mutation.
func (m *PaymentMethodMutation) SourcePaymentMethodID() (r uuid.UUID, exists bool) {
	v := m.source_payment_method_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourcePaymentMethodID returns the old "source_payment_method_id" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldSourcePaymentMethodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourcePaymentMethodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourcePaymentMethodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourcePaymentMethodID: %w", err)
	}
	return oldValue.SourcePaymentMethodID, nil
}

// ClearSourcePaymentMethodID clears the value of the "source_payment_method_id" field.
func (m *PaymentMethodMutation) ClearSourcePaymentMethodID() {
	m.source_payment_method_id = nil
	m.clearedFields[paymentmethod.FieldSourcePaymentMethodID] = struct{}{}
}

// SourcePaymentMethodIDCleared returns if the "source_payment_method_id" field was cleared in this mutation.
func (m *PaymentMethodMutation) SourcePaymentMethodIDCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldSourcePaymentMethodID]
	return ok
}

// ResetSourcePaymentMethodID resets all changes to the "source_payment_method_id" field.
func (m *PaymentMethodMutation) ResetSourcePaymentMethodID() {
	m.source_payment_method_id = nil
	delete(m.clearedFields, paymentmethod.FieldSourcePaymentMethodID)
}

// SetMerchantID sets the "merchant_id" field.
func (m *PaymentMethodMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *PaymentMethodMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *PaymentMethodMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *PaymentMethodMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *PaymentMethodMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *PaymentMethodMutation) ClearStoreID() {
	m.store_id = nil
	m.clearedFields[paymentmethod.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *PaymentMethodMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *PaymentMethodMutation) ResetStoreID() {
	m.store_id = nil
	delete(m.clearedFields, paymentmethod.FieldStoreID)
}

// SetName sets the "name" field.
func (m *PaymentMethodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PaymentMethodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PaymentMethodMutation) ResetName() {
	m.name = nil
}

// SetAccountingRule sets the "accounting_rule" field.
func (m *PaymentMethodMutation) SetAccountingRule(dmar domain.PaymentMethodAccountingRule) {
	m.accounting_rule = &dmar
}

// AccountingRule returns the value of the "accounting_rule" field in the mutation.
func (m *PaymentMethodMutation) AccountingRule() (r domain.PaymentMethodAccountingRule, exists bool) {
	v := m.accounting_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingRule returns the old "accounting_rule" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldAccountingRule(ctx context.Context) (v domain.PaymentMethodAccountingRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountingRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountingRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingRule: %w", err)
	}
	return oldValue.AccountingRule, nil
}

// ResetAccountingRule resets all changes to the "accounting_rule" field.
func (m *PaymentMethodMutation) ResetAccountingRule() {
	m.accounting_rule = nil
}

// SetPaymentType sets the "payment_type" field.
func (m *PaymentMethodMutation) SetPaymentType(dmpt domain.PaymentMethodPayType) {
	m.payment_type = &dmpt
}

// PaymentType returns the value of the "payment_type" field in the mutation.
func (m *PaymentMethodMutation) PaymentType() (r domain.PaymentMethodPayType, exists bool) {
	v := m.payment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentType returns the old "payment_type" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldPaymentType(ctx context.Context) (v domain.PaymentMethodPayType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentType: %w", err)
	}
	return oldValue.PaymentType, nil
}

// ResetPaymentType resets all changes to the "payment_type" field.
func (m *PaymentMethodMutation) ResetPaymentType() {
	m.payment_type = nil
}

// SetFeeRate sets the "fee_rate" field.
func (m *PaymentMethodMutation) SetFeeRate(d decimal.Decimal) {
	m.fee_rate = &d
}

// FeeRate returns the value of the "fee_rate" field in the mutation.
func (m *PaymentMethodMutation) FeeRate() (r decimal.Decimal, exists bool) {
	v := m.fee_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeRate returns the old "fee_rate" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldFeeRate(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeRate: %w", err)
	}
	return oldValue.FeeRate, nil
}

// ClearFeeRate clears the value of the "fee_rate" field.
func (m *PaymentMethodMutation) ClearFeeRate() {
	m.fee_rate = nil
	m.clearedFields[paymentmethod.FieldFeeRate] = struct{}{}
}

// FeeRateCleared returns if the "fee_rate" field was cleared in this mutation.
func (m *PaymentMethodMutation) FeeRateCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldFeeRate]
	return ok
}

// ResetFeeRate resets all changes to the "fee_rate" field.
func (m *PaymentMethodMutation) ResetFeeRate() {
	m.fee_rate = nil
	delete(m.clearedFields, paymentmethod.FieldFeeRate)
}

// SetInvoiceRule sets the "invoice_rule" field.
func (m *PaymentMethodMutation) SetInvoiceRule(dmir domain.PaymentMethodInvoiceRule) {
	m.invoice_rule = &dmir
}

// InvoiceRule returns the value of the "invoice_rule" field in the mutation.
func (m *PaymentMethodMutation) InvoiceRule() (r domain.PaymentMethodInvoiceRule, exists bool) {
	v := m.invoice_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceRule returns the old "invoice_rule" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldInvoiceRule(ctx context.Context) (v domain.PaymentMethodInvoiceRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceRule: %w", err)
	}
	return oldValue.InvoiceRule, nil
}

// ClearInvoiceRule clears the value of the "invoice_rule" field.
func (m *PaymentMethodMutation) ClearInvoiceRule() {
	m.invoice_rule = nil
	m.clearedFields[paymentmethod.FieldInvoiceRule] = struct{}{}
}

// InvoiceRuleCleared returns if the "invoice_rule" field was cleared in this mutation.
func (m *PaymentMethodMutation) InvoiceRuleCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldInvoiceRule]
	return ok
}

// ResetInvoiceRule resets all changes to the "invoice_rule" field.
func (m *PaymentMethodMutation) ResetInvoiceRule() {
	m.invoice_rule = nil
	delete(m.clearedFields, paymentmethod.FieldInvoiceRule)
}

// SetCashDrawerStatus sets the "cash_drawer_status" field.
func (m *PaymentMethodMutation) SetCashDrawerStatus(b bool) {
	m.cash_drawer_status = &b
}

// CashDrawerStatus returns the value of the "cash_drawer_status" field in the mutation.
func (m *PaymentMethodMutation) CashDrawerStatus() (r bool, exists bool) {
	v := m.cash_drawer_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCashDrawerStatus returns the old "cash_drawer_status" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldCashDrawerStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashDrawerStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashDrawerStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashDrawerStatus: %w", err)
	}
	return oldValue.CashDrawerStatus, nil
}

// ResetCashDrawerStatus resets all changes to the "cash_drawer_status" field.
func (m *PaymentMethodMutation) ResetCashDrawerStatus() {
	m.cash_drawer_status = nil
}

// SetDisplayChannels sets the "display_channels" field.
func (m *PaymentMethodMutation) SetDisplayChannels(dmdc []domain.PaymentMethodDisplayChannel) {
	m.display_channels = &dmdc
	m.appenddisplay_channels = nil
}

// DisplayChannels returns the value of the "display_channels" field in the mutation.
func (m *PaymentMethodMutation) DisplayChannels() (r []domain.PaymentMethodDisplayChannel, exists bool) {
	v := m.display_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayChannels returns the old "display_channels" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldDisplayChannels(ctx context.Context) (v []domain.PaymentMethodDisplayChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayChannels: %w", err)
	}
	return oldValue.DisplayChannels, nil
}

// AppendDisplayChannels adds dmdc to the "display_channels" field.
func (m *PaymentMethodMutation) AppendDisplayChannels(dmdc []domain.PaymentMethodDisplayChannel) {
	m.appenddisplay_channels = append(m.appenddisplay_channels, dmdc...)
}

// AppendedDisplayChannels returns the list of values that were appended to the "display_channels" field in this mutation.
func (m *PaymentMethodMutation) AppendedDisplayChannels() ([]domain.PaymentMethodDisplayChannel, bool) {
	if len(m.appenddisplay_channels) == 0 {
		return nil, false
	}
	return m.appenddisplay_channels, true
}

// ClearDisplayChannels clears the value of the "display_channels" field.
func (m *PaymentMethodMutation) ClearDisplayChannels() {
	m.display_channels = nil
	m.appenddisplay_channels = nil
	m.clearedFields[paymentmethod.FieldDisplayChannels] = struct{}{}
}

// DisplayChannelsCleared returns if the "display_channels" field was cleared in this mutation.
func (m *PaymentMethodMutation) DisplayChannelsCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldDisplayChannels]
	return ok
}

// ResetDisplayChannels resets all changes to the "display_channels" field.
func (m *PaymentMethodMutation) ResetDisplayChannels() {
	m.display_channels = nil
	m.appenddisplay_channels = nil
	delete(m.clearedFields, paymentmethod.FieldDisplayChannels)
}

// SetSource sets the "source" field.
func (m *PaymentMethodMutation) SetSource(dms domain.PaymentMethodSource) {
	m.source = &dms
}

// Source returns the value of the "source" field in the mutation.
func (m *PaymentMethodMutation) Source() (r domain.PaymentMethodSource, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldSource(ctx context.Context) (v domain.PaymentMethodSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *PaymentMethodMutation) ClearSource() {
	m.source = nil
	m.clearedFields[paymentmethod.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *PaymentMethodMutation) SourceCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *PaymentMethodMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, paymentmethod.FieldSource)
}

// SetStatus sets the "status" field.
func (m *PaymentMethodMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentMethodMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentMethodMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the PaymentMethodMutation builder.
func (m *PaymentMethodMutation) Where(ps ...predicate.PaymentMethod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMethodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMethodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentMethod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMethodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMethodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentMethod).
func (m *PaymentMethodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMethodMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, paymentmethod.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentmethod.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, paymentmethod.FieldDeletedAt)
	}
	if m.source_payment_method_id != nil {
		fields = append(fields, paymentmethod.FieldSourcePaymentMethodID)
	}
	if m.merchant_id != nil {
		fields = append(fields, paymentmethod.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, paymentmethod.FieldStoreID)
	}
	if m.name != nil {
		fields = append(fields, paymentmethod.FieldName)
	}
	if m.accounting_rule != nil {
		fields = append(fields, paymentmethod.FieldAccountingRule)
	}
	if m.payment_type != nil {
		fields = append(fields, paymentmethod.FieldPaymentType)
	}
	if m.fee_rate != nil {
		fields = append(fields, paymentmethod.FieldFeeRate)
	}
	if m.invoice_rule != nil {
		fields = append(fields, paymentmethod.FieldInvoiceRule)
	}
	if m.cash_drawer_status != nil {
		fields = append(fields, paymentmethod.FieldCashDrawerStatus)
	}
	if m.display_channels != nil {
		fields = append(fields, paymentmethod.FieldDisplayChannels)
	}
	if m.source != nil {
		fields = append(fields, paymentmethod.FieldSource)
	}
	if m.status != nil {
		fields = append(fields, paymentmethod.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMethodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentmethod.FieldCreatedAt:
		return m.CreatedAt()
	case paymentmethod.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentmethod.FieldDeletedAt:
		return m.DeletedAt()
	case paymentmethod.FieldSourcePaymentMethodID:
		return m.SourcePaymentMethodID()
	case paymentmethod.FieldMerchantID:
		return m.MerchantID()
	case paymentmethod.FieldStoreID:
		return m.StoreID()
	case paymentmethod.FieldName:
		return m.Name()
	case paymentmethod.FieldAccountingRule:
		return m.AccountingRule()
	case paymentmethod.FieldPaymentType:
		return m.PaymentType()
	case paymentmethod.FieldFeeRate:
		return m.FeeRate()
	case paymentmethod.FieldInvoiceRule:
		return m.InvoiceRule()
	case paymentmethod.FieldCashDrawerStatus:
		return m.CashDrawerStatus()
	case paymentmethod.FieldDisplayChannels:
		return m.DisplayChannels()
	case paymentmethod.FieldSource:
		return m.Source()
	case paymentmethod.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMethodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentmethod.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentmethod.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentmethod.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case paymentmethod.FieldSourcePaymentMethodID:
		return m.OldSourcePaymentMethodID(ctx)
	case paymentmethod.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case paymentmethod.FieldStoreID:
		return m.OldStoreID(ctx)
	case paymentmethod.FieldName:
		return m.OldName(ctx)
	case paymentmethod.FieldAccountingRule:
		return m.OldAccountingRule(ctx)
	case paymentmethod.FieldPaymentType:
		return m.OldPaymentType(ctx)
	case paymentmethod.FieldFeeRate:
		return m.OldFeeRate(ctx)
	case paymentmethod.FieldInvoiceRule:
		return m.OldInvoiceRule(ctx)
	case paymentmethod.FieldCashDrawerStatus:
		return m.OldCashDrawerStatus(ctx)
	case paymentmethod.FieldDisplayChannels:
		return m.OldDisplayChannels(ctx)
	case paymentmethod.FieldSource:
		return m.OldSource(ctx)
	case paymentmethod.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentMethod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMethodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentmethod.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentmethod.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentmethod.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case paymentmethod.FieldSourcePaymentMethodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourcePaymentMethodID(v)
		return nil
	case paymentmethod.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case paymentmethod.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case paymentmethod.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case paymentmethod.FieldAccountingRule:
		v, ok := value.(domain.PaymentMethodAccountingRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingRule(v)
		return nil
	case paymentmethod.FieldPaymentType:
		v, ok := value.(domain.PaymentMethodPayType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentType(v)
		return nil
	case paymentmethod.FieldFeeRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeRate(v)
		return nil
	case paymentmethod.FieldInvoiceRule:
		v, ok := value.(domain.PaymentMethodInvoiceRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceRule(v)
		return nil
	case paymentmethod.FieldCashDrawerStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashDrawerStatus(v)
		return nil
	case paymentmethod.FieldDisplayChannels:
		v, ok := value.([]domain.PaymentMethodDisplayChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayChannels(v)
		return nil
	case paymentmethod.FieldSource:
		v, ok := value.(domain.PaymentMethodSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case paymentmethod.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMethodMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, paymentmethod.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMethodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentmethod.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMethodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentmethod.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMethodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentmethod.FieldSourcePaymentMethodID) {
		fields = append(fields, paymentmethod.FieldSourcePaymentMethodID)
	}
	if m.FieldCleared(paymentmethod.FieldStoreID) {
		fields = append(fields, paymentmethod.FieldStoreID)
	}
	if m.FieldCleared(paymentmethod.FieldFeeRate) {
		fields = append(fields, paymentmethod.FieldFeeRate)
	}
	if m.FieldCleared(paymentmethod.FieldInvoiceRule) {
		fields = append(fields, paymentmethod.FieldInvoiceRule)
	}
	if m.FieldCleared(paymentmethod.FieldDisplayChannels) {
		fields = append(fields, paymentmethod.FieldDisplayChannels)
	}
	if m.FieldCleared(paymentmethod.FieldSource) {
		fields = append(fields, paymentmethod.FieldSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMethodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMethodMutation) ClearField(name string) error {
	switch name {
	case paymentmethod.FieldSourcePaymentMethodID:
		m.ClearSourcePaymentMethodID()
		return nil
	case paymentmethod.FieldStoreID:
		m.ClearStoreID()
		return nil
	case paymentmethod.FieldFeeRate:
		m.ClearFeeRate()
		return nil
	case paymentmethod.FieldInvoiceRule:
		m.ClearInvoiceRule()
		return nil
	case paymentmethod.FieldDisplayChannels:
		m.ClearDisplayChannels()
		return nil
	case paymentmethod.FieldSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMethodMutation) ResetField(name string) error {
	switch name {
	case paymentmethod.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentmethod.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentmethod.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case paymentmethod.FieldSourcePaymentMethodID:
		m.ResetSourcePaymentMethodID()
		return nil
	case paymentmethod.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case paymentmethod.FieldStoreID:
		m.ResetStoreID()
		return nil
	case paymentmethod.FieldName:
		m.ResetName()
		return nil
	case paymentmethod.FieldAccountingRule:
		m.ResetAccountingRule()
		return nil
	case paymentmethod.FieldPaymentType:
		m.ResetPaymentType()
		return nil
	case paymentmethod.FieldFeeRate:
		m.ResetFeeRate()
		return nil
	case paymentmethod.FieldInvoiceRule:
		m.ResetInvoiceRule()
		return nil
	case paymentmethod.FieldCashDrawerStatus:
		m.ResetCashDrawerStatus()
		return nil
	case paymentmethod.FieldDisplayChannels:
		m.ResetDisplayChannels()
		return nil
	case paymentmethod.FieldSource:
		m.ResetSource()
		return nil
	case paymentmethod.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMethodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMethodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMethodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMethodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMethodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMethodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMethodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentMethod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMethodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentMethod edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *int64
	adddeleted_at           *int64
	_type                   *domain.ProductType
	name                    *string
	menu_id                 *uuid.UUID
	mnemonic                *string
	shelf_life              *int
	addshelf_life           *int
	support_types           *[]domain.ProductSupportType
	appendsupport_types     []domain.ProductSupportType
	sale_status             *domain.ProductSaleStatus
	sale_channels           *[]domain.SaleChannel
	appendsale_channels     []domain.SaleChannel
	effective_date_type     *domain.EffectiveDateType
	effective_start_time    *time.Time
	effective_end_time      *time.Time
	min_sale_quantity       *int
	addmin_sale_quantity    *int
	add_sale_quantity       *int
	addadd_sale_quantity    *int
	inherit_tax_rate        *bool
	tax_rate_id             *uuid.UUID
	inherit_stall           *bool
	stall_id                *uuid.UUID
	main_image              *string
	detail_images           *[]string
	appenddetail_images     []string
	description             *string
	estimated_cost_price    *decimal.Decimal
	delivery_cost_price     *decimal.Decimal
	merchant_id             *uuid.UUID
	store_id                *uuid.UUID
	clearedFields           map[string]struct{}
	category                *uuid.UUID
	clearedcategory         bool
	unit                    *uuid.UUID
	clearedunit             bool
	tags                    map[uuid.UUID]struct{}
	removedtags             map[uuid.UUID]struct{}
	clearedtags             bool
	product_specs           map[uuid.UUID]struct{}
	removedproduct_specs    map[uuid.UUID]struct{}
	clearedproduct_specs    bool
	product_attrs           map[uuid.UUID]struct{}
	removedproduct_attrs    map[uuid.UUID]struct{}
	clearedproduct_attrs    bool
	set_meal_groups         map[uuid.UUID]struct{}
	removedset_meal_groups  map[uuid.UUID]struct{}
	clearedset_meal_groups  bool
	set_meal_details        map[uuid.UUID]struct{}
	removedset_meal_details map[uuid.UUID]struct{}
	clearedset_meal_details bool
	menu_items              map[uuid.UUID]struct{}
	removedmenu_items       map[uuid.UUID]struct{}
	clearedmenu_items       bool
	done                    bool
	oldValue                func(context.Context) (*Product, error)
	predicates              []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *ProductMutation) SetType(dt domain.ProductType) {
	m._type = &dt
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductMutation) GetType() (r domain.ProductType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldType(ctx context.Context) (v domain.ProductType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProductMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetCategoryID sets the "category_id" field.
func (m *ProductMutation) SetCategoryID(u uuid.UUID) {
	m.category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ProductMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ProductMutation) ResetCategoryID() {
	m.category = nil
}

// SetMenuID sets the "menu_id" field.
func (m *ProductMutation) SetMenuID(u uuid.UUID) {
	m.menu_id = &u
}

// MenuID returns the value of the "menu_id" field in the mutation.
func (m *ProductMutation) MenuID() (r uuid.UUID, exists bool) {
	v := m.menu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old "menu_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMenuID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// ClearMenuID clears the value of the "menu_id" field.
func (m *ProductMutation) ClearMenuID() {
	m.menu_id = nil
	m.clearedFields[product.FieldMenuID] = struct{}{}
}

// MenuIDCleared returns if the "menu_id" field was cleared in this mutation.
func (m *ProductMutation) MenuIDCleared() bool {
	_, ok := m.clearedFields[product.FieldMenuID]
	return ok
}

// ResetMenuID resets all changes to the "menu_id" field.
func (m *ProductMutation) ResetMenuID() {
	m.menu_id = nil
	delete(m.clearedFields, product.FieldMenuID)
}

// SetMnemonic sets the "mnemonic" field.
func (m *ProductMutation) SetMnemonic(s string) {
	m.mnemonic = &s
}

// Mnemonic returns the value of the "mnemonic" field in the mutation.
func (m *ProductMutation) Mnemonic() (r string, exists bool) {
	v := m.mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldMnemonic returns the old "mnemonic" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMnemonic: %w", err)
	}
	return oldValue.Mnemonic, nil
}

// ResetMnemonic resets all changes to the "mnemonic" field.
func (m *ProductMutation) ResetMnemonic() {
	m.mnemonic = nil
}

// SetShelfLife sets the "shelf_life" field.
func (m *ProductMutation) SetShelfLife(i int) {
	m.shelf_life = &i
	m.addshelf_life = nil
}

// ShelfLife returns the value of the "shelf_life" field in the mutation.
func (m *ProductMutation) ShelfLife() (r int, exists bool) {
	v := m.shelf_life
	if v == nil {
		return
	}
	return *v, true
}

// OldShelfLife returns the old "shelf_life" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShelfLife(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShelfLife is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShelfLife requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShelfLife: %w", err)
	}
	return oldValue.ShelfLife, nil
}

// AddShelfLife adds i to the "shelf_life" field.
func (m *ProductMutation) AddShelfLife(i int) {
	if m.addshelf_life != nil {
		*m.addshelf_life += i
	} else {
		m.addshelf_life = &i
	}
}

// AddedShelfLife returns the value that was added to the "shelf_life" field in this mutation.
func (m *ProductMutation) AddedShelfLife() (r int, exists bool) {
	v := m.addshelf_life
	if v == nil {
		return
	}
	return *v, true
}

// ResetShelfLife resets all changes to the "shelf_life" field.
func (m *ProductMutation) ResetShelfLife() {
	m.shelf_life = nil
	m.addshelf_life = nil
}

// SetSupportTypes sets the "support_types" field.
func (m *ProductMutation) SetSupportTypes(dst []domain.ProductSupportType) {
	m.support_types = &dst
	m.appendsupport_types = nil
}

// SupportTypes returns the value of the "support_types" field in the mutation.
func (m *ProductMutation) SupportTypes() (r []domain.ProductSupportType, exists bool) {
	v := m.support_types
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportTypes returns the old "support_types" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSupportTypes(ctx context.Context) (v []domain.ProductSupportType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportTypes: %w", err)
	}
	return oldValue.SupportTypes, nil
}

// AppendSupportTypes adds dst to the "support_types" field.
func (m *ProductMutation) AppendSupportTypes(dst []domain.ProductSupportType) {
	m.appendsupport_types = append(m.appendsupport_types, dst...)
}

// AppendedSupportTypes returns the list of values that were appended to the "support_types" field in this mutation.
func (m *ProductMutation) AppendedSupportTypes() ([]domain.ProductSupportType, bool) {
	if len(m.appendsupport_types) == 0 {
		return nil, false
	}
	return m.appendsupport_types, true
}

// ResetSupportTypes resets all changes to the "support_types" field.
func (m *ProductMutation) ResetSupportTypes() {
	m.support_types = nil
	m.appendsupport_types = nil
}

// SetUnitID sets the "unit_id" field.
func (m *ProductMutation) SetUnitID(u uuid.UUID) {
	m.unit = &u
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *ProductMutation) UnitID() (r uuid.UUID, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *ProductMutation) ResetUnitID() {
	m.unit = nil
}

// SetSaleStatus sets the "sale_status" field.
func (m *ProductMutation) SetSaleStatus(dss domain.ProductSaleStatus) {
	m.sale_status = &dss
}

// SaleStatus returns the value of the "sale_status" field in the mutation.
func (m *ProductMutation) SaleStatus() (r domain.ProductSaleStatus, exists bool) {
	v := m.sale_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStatus returns the old "sale_status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSaleStatus(ctx context.Context) (v domain.ProductSaleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStatus: %w", err)
	}
	return oldValue.SaleStatus, nil
}

// ResetSaleStatus resets all changes to the "sale_status" field.
func (m *ProductMutation) ResetSaleStatus() {
	m.sale_status = nil
}

// SetSaleChannels sets the "sale_channels" field.
func (m *ProductMutation) SetSaleChannels(dc []domain.SaleChannel) {
	m.sale_channels = &dc
	m.appendsale_channels = nil
}

// SaleChannels returns the value of the "sale_channels" field in the mutation.
func (m *ProductMutation) SaleChannels() (r []domain.SaleChannel, exists bool) {
	v := m.sale_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleChannels returns the old "sale_channels" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSaleChannels(ctx context.Context) (v []domain.SaleChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleChannels: %w", err)
	}
	return oldValue.SaleChannels, nil
}

// AppendSaleChannels adds dc to the "sale_channels" field.
func (m *ProductMutation) AppendSaleChannels(dc []domain.SaleChannel) {
	m.appendsale_channels = append(m.appendsale_channels, dc...)
}

// AppendedSaleChannels returns the list of values that were appended to the "sale_channels" field in this mutation.
func (m *ProductMutation) AppendedSaleChannels() ([]domain.SaleChannel, bool) {
	if len(m.appendsale_channels) == 0 {
		return nil, false
	}
	return m.appendsale_channels, true
}

// ResetSaleChannels resets all changes to the "sale_channels" field.
func (m *ProductMutation) ResetSaleChannels() {
	m.sale_channels = nil
	m.appendsale_channels = nil
}

// SetEffectiveDateType sets the "effective_date_type" field.
func (m *ProductMutation) SetEffectiveDateType(ddt domain.EffectiveDateType) {
	m.effective_date_type = &ddt
}

// EffectiveDateType returns the value of the "effective_date_type" field in the mutation.
func (m *ProductMutation) EffectiveDateType() (r domain.EffectiveDateType, exists bool) {
	v := m.effective_date_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDateType returns the old "effective_date_type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldEffectiveDateType(ctx context.Context) (v domain.EffectiveDateType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDateType: %w", err)
	}
	return oldValue.EffectiveDateType, nil
}

// ClearEffectiveDateType clears the value of the "effective_date_type" field.
func (m *ProductMutation) ClearEffectiveDateType() {
	m.effective_date_type = nil
	m.clearedFields[product.FieldEffectiveDateType] = struct{}{}
}

// EffectiveDateTypeCleared returns if the "effective_date_type" field was cleared in this mutation.
func (m *ProductMutation) EffectiveDateTypeCleared() bool {
	_, ok := m.clearedFields[product.FieldEffectiveDateType]
	return ok
}

// ResetEffectiveDateType resets all changes to the "effective_date_type" field.
func (m *ProductMutation) ResetEffectiveDateType() {
	m.effective_date_type = nil
	delete(m.clearedFields, product.FieldEffectiveDateType)
}

// SetEffectiveStartTime sets the "effective_start_time" field.
func (m *ProductMutation) SetEffectiveStartTime(t time.Time) {
	m.effective_start_time = &t
}

// EffectiveStartTime returns the value of the "effective_start_time" field in the mutation.
func (m *ProductMutation) EffectiveStartTime() (r time.Time, exists bool) {
	v := m.effective_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveStartTime returns the old "effective_start_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldEffectiveStartTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveStartTime: %w", err)
	}
	return oldValue.EffectiveStartTime, nil
}

// ClearEffectiveStartTime clears the value of the "effective_start_time" field.
func (m *ProductMutation) ClearEffectiveStartTime() {
	m.effective_start_time = nil
	m.clearedFields[product.FieldEffectiveStartTime] = struct{}{}
}

// EffectiveStartTimeCleared returns if the "effective_start_time" field was cleared in this mutation.
func (m *ProductMutation) EffectiveStartTimeCleared() bool {
	_, ok := m.clearedFields[product.FieldEffectiveStartTime]
	return ok
}

// ResetEffectiveStartTime resets all changes to the "effective_start_time" field.
func (m *ProductMutation) ResetEffectiveStartTime() {
	m.effective_start_time = nil
	delete(m.clearedFields, product.FieldEffectiveStartTime)
}

// SetEffectiveEndTime sets the "effective_end_time" field.
func (m *ProductMutation) SetEffectiveEndTime(t time.Time) {
	m.effective_end_time = &t
}

// EffectiveEndTime returns the value of the "effective_end_time" field in the mutation.
func (m *ProductMutation) EffectiveEndTime() (r time.Time, exists bool) {
	v := m.effective_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveEndTime returns the old "effective_end_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldEffectiveEndTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveEndTime: %w", err)
	}
	return oldValue.EffectiveEndTime, nil
}

// ClearEffectiveEndTime clears the value of the "effective_end_time" field.
func (m *ProductMutation) ClearEffectiveEndTime() {
	m.effective_end_time = nil
	m.clearedFields[product.FieldEffectiveEndTime] = struct{}{}
}

// EffectiveEndTimeCleared returns if the "effective_end_time" field was cleared in this mutation.
func (m *ProductMutation) EffectiveEndTimeCleared() bool {
	_, ok := m.clearedFields[product.FieldEffectiveEndTime]
	return ok
}

// ResetEffectiveEndTime resets all changes to the "effective_end_time" field.
func (m *ProductMutation) ResetEffectiveEndTime() {
	m.effective_end_time = nil
	delete(m.clearedFields, product.FieldEffectiveEndTime)
}

// SetMinSaleQuantity sets the "min_sale_quantity" field.
func (m *ProductMutation) SetMinSaleQuantity(i int) {
	m.min_sale_quantity = &i
	m.addmin_sale_quantity = nil
}

// MinSaleQuantity returns the value of the "min_sale_quantity" field in the mutation.
func (m *ProductMutation) MinSaleQuantity() (r int, exists bool) {
	v := m.min_sale_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldMinSaleQuantity returns the old "min_sale_quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMinSaleQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinSaleQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinSaleQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinSaleQuantity: %w", err)
	}
	return oldValue.MinSaleQuantity, nil
}

// AddMinSaleQuantity adds i to the "min_sale_quantity" field.
func (m *ProductMutation) AddMinSaleQuantity(i int) {
	if m.addmin_sale_quantity != nil {
		*m.addmin_sale_quantity += i
	} else {
		m.addmin_sale_quantity = &i
	}
}

// AddedMinSaleQuantity returns the value that was added to the "min_sale_quantity" field in this mutation.
func (m *ProductMutation) AddedMinSaleQuantity() (r int, exists bool) {
	v := m.addmin_sale_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinSaleQuantity clears the value of the "min_sale_quantity" field.
func (m *ProductMutation) ClearMinSaleQuantity() {
	m.min_sale_quantity = nil
	m.addmin_sale_quantity = nil
	m.clearedFields[product.FieldMinSaleQuantity] = struct{}{}
}

// MinSaleQuantityCleared returns if the "min_sale_quantity" field was cleared in this mutation.
func (m *ProductMutation) MinSaleQuantityCleared() bool {
	_, ok := m.clearedFields[product.FieldMinSaleQuantity]
	return ok
}

// ResetMinSaleQuantity resets all changes to the "min_sale_quantity" field.
func (m *ProductMutation) ResetMinSaleQuantity() {
	m.min_sale_quantity = nil
	m.addmin_sale_quantity = nil
	delete(m.clearedFields, product.FieldMinSaleQuantity)
}

// SetAddSaleQuantity sets the "add_sale_quantity" field.
func (m *ProductMutation) SetAddSaleQuantity(i int) {
	m.add_sale_quantity = &i
	m.addadd_sale_quantity = nil
}

// AddSaleQuantity returns the value of the "add_sale_quantity" field in the mutation.
func (m *ProductMutation) AddSaleQuantity() (r int, exists bool) {
	v := m.add_sale_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldAddSaleQuantity returns the old "add_sale_quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAddSaleQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddSaleQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddSaleQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddSaleQuantity: %w", err)
	}
	return oldValue.AddSaleQuantity, nil
}

// AddAddSaleQuantity adds i to the "add_sale_quantity" field.
func (m *ProductMutation) AddAddSaleQuantity(i int) {
	if m.addadd_sale_quantity != nil {
		*m.addadd_sale_quantity += i
	} else {
		m.addadd_sale_quantity = &i
	}
}

// AddedAddSaleQuantity returns the value that was added to the "add_sale_quantity" field in this mutation.
func (m *ProductMutation) AddedAddSaleQuantity() (r int, exists bool) {
	v := m.addadd_sale_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearAddSaleQuantity clears the value of the "add_sale_quantity" field.
func (m *ProductMutation) ClearAddSaleQuantity() {
	m.add_sale_quantity = nil
	m.addadd_sale_quantity = nil
	m.clearedFields[product.FieldAddSaleQuantity] = struct{}{}
}

// AddSaleQuantityCleared returns if the "add_sale_quantity" field was cleared in this mutation.
func (m *ProductMutation) AddSaleQuantityCleared() bool {
	_, ok := m.clearedFields[product.FieldAddSaleQuantity]
	return ok
}

// ResetAddSaleQuantity resets all changes to the "add_sale_quantity" field.
func (m *ProductMutation) ResetAddSaleQuantity() {
	m.add_sale_quantity = nil
	m.addadd_sale_quantity = nil
	delete(m.clearedFields, product.FieldAddSaleQuantity)
}

// SetInheritTaxRate sets the "inherit_tax_rate" field.
func (m *ProductMutation) SetInheritTaxRate(b bool) {
	m.inherit_tax_rate = &b
}

// InheritTaxRate returns the value of the "inherit_tax_rate" field in the mutation.
func (m *ProductMutation) InheritTaxRate() (r bool, exists bool) {
	v := m.inherit_tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritTaxRate returns the old "inherit_tax_rate" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldInheritTaxRate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritTaxRate: %w", err)
	}
	return oldValue.InheritTaxRate, nil
}

// ResetInheritTaxRate resets all changes to the "inherit_tax_rate" field.
func (m *ProductMutation) ResetInheritTaxRate() {
	m.inherit_tax_rate = nil
}

// SetTaxRateID sets the "tax_rate_id" field.
func (m *ProductMutation) SetTaxRateID(u uuid.UUID) {
	m.tax_rate_id = &u
}

// TaxRateID returns the value of the "tax_rate_id" field in the mutation.
func (m *ProductMutation) TaxRateID() (r uuid.UUID, exists bool) {
	v := m.tax_rate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRateID returns the old "tax_rate_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTaxRateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRateID: %w", err)
	}
	return oldValue.TaxRateID, nil
}

// ClearTaxRateID clears the value of the "tax_rate_id" field.
func (m *ProductMutation) ClearTaxRateID() {
	m.tax_rate_id = nil
	m.clearedFields[product.FieldTaxRateID] = struct{}{}
}

// TaxRateIDCleared returns if the "tax_rate_id" field was cleared in this mutation.
func (m *ProductMutation) TaxRateIDCleared() bool {
	_, ok := m.clearedFields[product.FieldTaxRateID]
	return ok
}

// ResetTaxRateID resets all changes to the "tax_rate_id" field.
func (m *ProductMutation) ResetTaxRateID() {
	m.tax_rate_id = nil
	delete(m.clearedFields, product.FieldTaxRateID)
}

// SetInheritStall sets the "inherit_stall" field.
func (m *ProductMutation) SetInheritStall(b bool) {
	m.inherit_stall = &b
}

// InheritStall returns the value of the "inherit_stall" field in the mutation.
func (m *ProductMutation) InheritStall() (r bool, exists bool) {
	v := m.inherit_stall
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritStall returns the old "inherit_stall" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldInheritStall(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritStall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritStall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritStall: %w", err)
	}
	return oldValue.InheritStall, nil
}

// ResetInheritStall resets all changes to the "inherit_stall" field.
func (m *ProductMutation) ResetInheritStall() {
	m.inherit_stall = nil
}

// SetStallID sets the "stall_id" field.
func (m *ProductMutation) SetStallID(u uuid.UUID) {
	m.stall_id = &u
}

// StallID returns the value of the "stall_id" field in the mutation.
func (m *ProductMutation) StallID() (r uuid.UUID, exists bool) {
	v := m.stall_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStallID returns the old "stall_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStallID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStallID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStallID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStallID: %w", err)
	}
	return oldValue.StallID, nil
}

// ClearStallID clears the value of the "stall_id" field.
func (m *ProductMutation) ClearStallID() {
	m.stall_id = nil
	m.clearedFields[product.FieldStallID] = struct{}{}
}

// StallIDCleared returns if the "stall_id" field was cleared in this mutation.
func (m *ProductMutation) StallIDCleared() bool {
	_, ok := m.clearedFields[product.FieldStallID]
	return ok
}

// ResetStallID resets all changes to the "stall_id" field.
func (m *ProductMutation) ResetStallID() {
	m.stall_id = nil
	delete(m.clearedFields, product.FieldStallID)
}

// SetMainImage sets the "main_image" field.
func (m *ProductMutation) SetMainImage(s string) {
	m.main_image = &s
}

// MainImage returns the value of the "main_image" field in the mutation.
func (m *ProductMutation) MainImage() (r string, exists bool) {
	v := m.main_image
	if v == nil {
		return
	}
	return *v, true
}

// OldMainImage returns the old "main_image" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMainImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainImage: %w", err)
	}
	return oldValue.MainImage, nil
}

// ResetMainImage resets all changes to the "main_image" field.
func (m *ProductMutation) ResetMainImage() {
	m.main_image = nil
}

// SetDetailImages sets the "detail_images" field.
func (m *ProductMutation) SetDetailImages(s []string) {
	m.detail_images = &s
	m.appenddetail_images = nil
}

// DetailImages returns the value of the "detail_images" field in the mutation.
func (m *ProductMutation) DetailImages() (r []string, exists bool) {
	v := m.detail_images
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailImages returns the old "detail_images" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDetailImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailImages: %w", err)
	}
	return oldValue.DetailImages, nil
}

// AppendDetailImages adds s to the "detail_images" field.
func (m *ProductMutation) AppendDetailImages(s []string) {
	m.appenddetail_images = append(m.appenddetail_images, s...)
}

// AppendedDetailImages returns the list of values that were appended to the "detail_images" field in this mutation.
func (m *ProductMutation) AppendedDetailImages() ([]string, bool) {
	if len(m.appenddetail_images) == 0 {
		return nil, false
	}
	return m.appenddetail_images, true
}

// ClearDetailImages clears the value of the "detail_images" field.
func (m *ProductMutation) ClearDetailImages() {
	m.detail_images = nil
	m.appenddetail_images = nil
	m.clearedFields[product.FieldDetailImages] = struct{}{}
}

// DetailImagesCleared returns if the "detail_images" field was cleared in this mutation.
func (m *ProductMutation) DetailImagesCleared() bool {
	_, ok := m.clearedFields[product.FieldDetailImages]
	return ok
}

// ResetDetailImages resets all changes to the "detail_images" field.
func (m *ProductMutation) ResetDetailImages() {
	m.detail_images = nil
	m.appenddetail_images = nil
	delete(m.clearedFields, product.FieldDetailImages)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetEstimatedCostPrice sets the "estimated_cost_price" field.
func (m *ProductMutation) SetEstimatedCostPrice(d decimal.Decimal) {
	m.estimated_cost_price = &d
}

// EstimatedCostPrice returns the value of the "estimated_cost_price" field in the mutation.
func (m *ProductMutation) EstimatedCostPrice() (r decimal.Decimal, exists bool) {
	v := m.estimated_cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCostPrice returns the old "estimated_cost_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldEstimatedCostPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCostPrice: %w", err)
	}
	return oldValue.EstimatedCostPrice, nil
}

// ClearEstimatedCostPrice clears the value of the "estimated_cost_price" field.
func (m *ProductMutation) ClearEstimatedCostPrice() {
	m.estimated_cost_price = nil
	m.clearedFields[product.FieldEstimatedCostPrice] = struct{}{}
}

// EstimatedCostPriceCleared returns if the "estimated_cost_price" field was cleared in this mutation.
func (m *ProductMutation) EstimatedCostPriceCleared() bool {
	_, ok := m.clearedFields[product.FieldEstimatedCostPrice]
	return ok
}

// ResetEstimatedCostPrice resets all changes to the "estimated_cost_price" field.
func (m *ProductMutation) ResetEstimatedCostPrice() {
	m.estimated_cost_price = nil
	delete(m.clearedFields, product.FieldEstimatedCostPrice)
}

// SetDeliveryCostPrice sets the "delivery_cost_price" field.
func (m *ProductMutation) SetDeliveryCostPrice(d decimal.Decimal) {
	m.delivery_cost_price = &d
}

// DeliveryCostPrice returns the value of the "delivery_cost_price" field in the mutation.
func (m *ProductMutation) DeliveryCostPrice() (r decimal.Decimal, exists bool) {
	v := m.delivery_cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryCostPrice returns the old "delivery_cost_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeliveryCostPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryCostPrice: %w", err)
	}
	return oldValue.DeliveryCostPrice, nil
}

// ClearDeliveryCostPrice clears the value of the "delivery_cost_price" field.
func (m *ProductMutation) ClearDeliveryCostPrice() {
	m.delivery_cost_price = nil
	m.clearedFields[product.FieldDeliveryCostPrice] = struct{}{}
}

// DeliveryCostPriceCleared returns if the "delivery_cost_price" field was cleared in this mutation.
func (m *ProductMutation) DeliveryCostPriceCleared() bool {
	_, ok := m.clearedFields[product.FieldDeliveryCostPrice]
	return ok
}

// ResetDeliveryCostPrice resets all changes to the "delivery_cost_price" field.
func (m *ProductMutation) ResetDeliveryCostPrice() {
	m.delivery_cost_price = nil
	delete(m.clearedFields, product.FieldDeliveryCostPrice)
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductMutation) ResetStoreID() {
	m.store_id = nil
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ProductMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[product.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ProductMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CategoryIDs() (ids []uuid.UUID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// ClearUnit clears the "unit" edge to the ProductUnit entity.
func (m *ProductMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[product.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the ProductUnit entity was cleared.
func (m *ProductMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) UnitIDs() (ids []uuid.UUID) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *ProductMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// AddTagIDs adds the "tags" edge to the ProductTag entity by ids.
func (m *ProductMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the ProductTag entity.
func (m *ProductMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the ProductTag entity was cleared.
func (m *ProductMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the ProductTag entity by IDs.
func (m *ProductMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the ProductTag entity.
func (m *ProductMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProductMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProductMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddProductSpecIDs adds the "product_specs" edge to the ProductSpecRelation entity by ids.
func (m *ProductMutation) AddProductSpecIDs(ids ...uuid.UUID) {
	if m.product_specs == nil {
		m.product_specs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.product_specs[ids[i]] = struct{}{}
	}
}

// ClearProductSpecs clears the "product_specs" edge to the ProductSpecRelation entity.
func (m *ProductMutation) ClearProductSpecs() {
	m.clearedproduct_specs = true
}

// ProductSpecsCleared reports if the "product_specs" edge to the ProductSpecRelation entity was cleared.
func (m *ProductMutation) ProductSpecsCleared() bool {
	return m.clearedproduct_specs
}

// RemoveProductSpecIDs removes the "product_specs" edge to the ProductSpecRelation entity by IDs.
func (m *ProductMutation) RemoveProductSpecIDs(ids ...uuid.UUID) {
	if m.removedproduct_specs == nil {
		m.removedproduct_specs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.product_specs, ids[i])
		m.removedproduct_specs[ids[i]] = struct{}{}
	}
}

// RemovedProductSpecs returns the removed IDs of the "product_specs" edge to the ProductSpecRelation entity.
func (m *ProductMutation) RemovedProductSpecsIDs() (ids []uuid.UUID) {
	for id := range m.removedproduct_specs {
		ids = append(ids, id)
	}
	return
}

// ProductSpecsIDs returns the "product_specs" edge IDs in the mutation.
func (m *ProductMutation) ProductSpecsIDs() (ids []uuid.UUID) {
	for id := range m.product_specs {
		ids = append(ids, id)
	}
	return
}

// ResetProductSpecs resets all changes to the "product_specs" edge.
func (m *ProductMutation) ResetProductSpecs() {
	m.product_specs = nil
	m.clearedproduct_specs = false
	m.removedproduct_specs = nil
}

// AddProductAttrIDs adds the "product_attrs" edge to the ProductAttrRelation entity by ids.
func (m *ProductMutation) AddProductAttrIDs(ids ...uuid.UUID) {
	if m.product_attrs == nil {
		m.product_attrs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.product_attrs[ids[i]] = struct{}{}
	}
}

// ClearProductAttrs clears the "product_attrs" edge to the ProductAttrRelation entity.
func (m *ProductMutation) ClearProductAttrs() {
	m.clearedproduct_attrs = true
}

// ProductAttrsCleared reports if the "product_attrs" edge to the ProductAttrRelation entity was cleared.
func (m *ProductMutation) ProductAttrsCleared() bool {
	return m.clearedproduct_attrs
}

// RemoveProductAttrIDs removes the "product_attrs" edge to the ProductAttrRelation entity by IDs.
func (m *ProductMutation) RemoveProductAttrIDs(ids ...uuid.UUID) {
	if m.removedproduct_attrs == nil {
		m.removedproduct_attrs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.product_attrs, ids[i])
		m.removedproduct_attrs[ids[i]] = struct{}{}
	}
}

// RemovedProductAttrs returns the removed IDs of the "product_attrs" edge to the ProductAttrRelation entity.
func (m *ProductMutation) RemovedProductAttrsIDs() (ids []uuid.UUID) {
	for id := range m.removedproduct_attrs {
		ids = append(ids, id)
	}
	return
}

// ProductAttrsIDs returns the "product_attrs" edge IDs in the mutation.
func (m *ProductMutation) ProductAttrsIDs() (ids []uuid.UUID) {
	for id := range m.product_attrs {
		ids = append(ids, id)
	}
	return
}

// ResetProductAttrs resets all changes to the "product_attrs" edge.
func (m *ProductMutation) ResetProductAttrs() {
	m.product_attrs = nil
	m.clearedproduct_attrs = false
	m.removedproduct_attrs = nil
}

// AddSetMealGroupIDs adds the "set_meal_groups" edge to the SetMealGroup entity by ids.
func (m *ProductMutation) AddSetMealGroupIDs(ids ...uuid.UUID) {
	if m.set_meal_groups == nil {
		m.set_meal_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.set_meal_groups[ids[i]] = struct{}{}
	}
}

// ClearSetMealGroups clears the "set_meal_groups" edge to the SetMealGroup entity.
func (m *ProductMutation) ClearSetMealGroups() {
	m.clearedset_meal_groups = true
}

// SetMealGroupsCleared reports if the "set_meal_groups" edge to the SetMealGroup entity was cleared.
func (m *ProductMutation) SetMealGroupsCleared() bool {
	return m.clearedset_meal_groups
}

// RemoveSetMealGroupIDs removes the "set_meal_groups" edge to the SetMealGroup entity by IDs.
func (m *ProductMutation) RemoveSetMealGroupIDs(ids ...uuid.UUID) {
	if m.removedset_meal_groups == nil {
		m.removedset_meal_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.set_meal_groups, ids[i])
		m.removedset_meal_groups[ids[i]] = struct{}{}
	}
}

// RemovedSetMealGroups returns the removed IDs of the "set_meal_groups" edge to the SetMealGroup entity.
func (m *ProductMutation) RemovedSetMealGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedset_meal_groups {
		ids = append(ids, id)
	}
	return
}

// SetMealGroupsIDs returns the "set_meal_groups" edge IDs in the mutation.
func (m *ProductMutation) SetMealGroupsIDs() (ids []uuid.UUID) {
	for id := range m.set_meal_groups {
		ids = append(ids, id)
	}
	return
}

// ResetSetMealGroups resets all changes to the "set_meal_groups" edge.
func (m *ProductMutation) ResetSetMealGroups() {
	m.set_meal_groups = nil
	m.clearedset_meal_groups = false
	m.removedset_meal_groups = nil
}

// AddSetMealDetailIDs adds the "set_meal_details" edge to the SetMealDetail entity by ids.
func (m *ProductMutation) AddSetMealDetailIDs(ids ...uuid.UUID) {
	if m.set_meal_details == nil {
		m.set_meal_details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.set_meal_details[ids[i]] = struct{}{}
	}
}

// ClearSetMealDetails clears the "set_meal_details" edge to the SetMealDetail entity.
func (m *ProductMutation) ClearSetMealDetails() {
	m.clearedset_meal_details = true
}

// SetMealDetailsCleared reports if the "set_meal_details" edge to the SetMealDetail entity was cleared.
func (m *ProductMutation) SetMealDetailsCleared() bool {
	return m.clearedset_meal_details
}

// RemoveSetMealDetailIDs removes the "set_meal_details" edge to the SetMealDetail entity by IDs.
func (m *ProductMutation) RemoveSetMealDetailIDs(ids ...uuid.UUID) {
	if m.removedset_meal_details == nil {
		m.removedset_meal_details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.set_meal_details, ids[i])
		m.removedset_meal_details[ids[i]] = struct{}{}
	}
}

// RemovedSetMealDetails returns the removed IDs of the "set_meal_details" edge to the SetMealDetail entity.
func (m *ProductMutation) RemovedSetMealDetailsIDs() (ids []uuid.UUID) {
	for id := range m.removedset_meal_details {
		ids = append(ids, id)
	}
	return
}

// SetMealDetailsIDs returns the "set_meal_details" edge IDs in the mutation.
func (m *ProductMutation) SetMealDetailsIDs() (ids []uuid.UUID) {
	for id := range m.set_meal_details {
		ids = append(ids, id)
	}
	return
}

// ResetSetMealDetails resets all changes to the "set_meal_details" edge.
func (m *ProductMutation) ResetSetMealDetails() {
	m.set_meal_details = nil
	m.clearedset_meal_details = false
	m.removedset_meal_details = nil
}

// AddMenuItemIDs adds the "menu_items" edge to the MenuItem entity by ids.
func (m *ProductMutation) AddMenuItemIDs(ids ...uuid.UUID) {
	if m.menu_items == nil {
		m.menu_items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.menu_items[ids[i]] = struct{}{}
	}
}

// ClearMenuItems clears the "menu_items" edge to the MenuItem entity.
func (m *ProductMutation) ClearMenuItems() {
	m.clearedmenu_items = true
}

// MenuItemsCleared reports if the "menu_items" edge to the MenuItem entity was cleared.
func (m *ProductMutation) MenuItemsCleared() bool {
	return m.clearedmenu_items
}

// RemoveMenuItemIDs removes the "menu_items" edge to the MenuItem entity by IDs.
func (m *ProductMutation) RemoveMenuItemIDs(ids ...uuid.UUID) {
	if m.removedmenu_items == nil {
		m.removedmenu_items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.menu_items, ids[i])
		m.removedmenu_items[ids[i]] = struct{}{}
	}
}

// RemovedMenuItems returns the removed IDs of the "menu_items" edge to the MenuItem entity.
func (m *ProductMutation) RemovedMenuItemsIDs() (ids []uuid.UUID) {
	for id := range m.removedmenu_items {
		ids = append(ids, id)
	}
	return
}

// MenuItemsIDs returns the "menu_items" edge IDs in the mutation.
func (m *ProductMutation) MenuItemsIDs() (ids []uuid.UUID) {
	for id := range m.menu_items {
		ids = append(ids, id)
	}
	return
}

// ResetMenuItems resets all changes to the "menu_items" edge.
func (m *ProductMutation) ResetMenuItems() {
	m.menu_items = nil
	m.clearedmenu_items = false
	m.removedmenu_items = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, product.FieldType)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.category != nil {
		fields = append(fields, product.FieldCategoryID)
	}
	if m.menu_id != nil {
		fields = append(fields, product.FieldMenuID)
	}
	if m.mnemonic != nil {
		fields = append(fields, product.FieldMnemonic)
	}
	if m.shelf_life != nil {
		fields = append(fields, product.FieldShelfLife)
	}
	if m.support_types != nil {
		fields = append(fields, product.FieldSupportTypes)
	}
	if m.unit != nil {
		fields = append(fields, product.FieldUnitID)
	}
	if m.sale_status != nil {
		fields = append(fields, product.FieldSaleStatus)
	}
	if m.sale_channels != nil {
		fields = append(fields, product.FieldSaleChannels)
	}
	if m.effective_date_type != nil {
		fields = append(fields, product.FieldEffectiveDateType)
	}
	if m.effective_start_time != nil {
		fields = append(fields, product.FieldEffectiveStartTime)
	}
	if m.effective_end_time != nil {
		fields = append(fields, product.FieldEffectiveEndTime)
	}
	if m.min_sale_quantity != nil {
		fields = append(fields, product.FieldMinSaleQuantity)
	}
	if m.add_sale_quantity != nil {
		fields = append(fields, product.FieldAddSaleQuantity)
	}
	if m.inherit_tax_rate != nil {
		fields = append(fields, product.FieldInheritTaxRate)
	}
	if m.tax_rate_id != nil {
		fields = append(fields, product.FieldTaxRateID)
	}
	if m.inherit_stall != nil {
		fields = append(fields, product.FieldInheritStall)
	}
	if m.stall_id != nil {
		fields = append(fields, product.FieldStallID)
	}
	if m.main_image != nil {
		fields = append(fields, product.FieldMainImage)
	}
	if m.detail_images != nil {
		fields = append(fields, product.FieldDetailImages)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.estimated_cost_price != nil {
		fields = append(fields, product.FieldEstimatedCostPrice)
	}
	if m.delivery_cost_price != nil {
		fields = append(fields, product.FieldDeliveryCostPrice)
	}
	if m.merchant_id != nil {
		fields = append(fields, product.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, product.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldType:
		return m.GetType()
	case product.FieldName:
		return m.Name()
	case product.FieldCategoryID:
		return m.CategoryID()
	case product.FieldMenuID:
		return m.MenuID()
	case product.FieldMnemonic:
		return m.Mnemonic()
	case product.FieldShelfLife:
		return m.ShelfLife()
	case product.FieldSupportTypes:
		return m.SupportTypes()
	case product.FieldUnitID:
		return m.UnitID()
	case product.FieldSaleStatus:
		return m.SaleStatus()
	case product.FieldSaleChannels:
		return m.SaleChannels()
	case product.FieldEffectiveDateType:
		return m.EffectiveDateType()
	case product.FieldEffectiveStartTime:
		return m.EffectiveStartTime()
	case product.FieldEffectiveEndTime:
		return m.EffectiveEndTime()
	case product.FieldMinSaleQuantity:
		return m.MinSaleQuantity()
	case product.FieldAddSaleQuantity:
		return m.AddSaleQuantity()
	case product.FieldInheritTaxRate:
		return m.InheritTaxRate()
	case product.FieldTaxRateID:
		return m.TaxRateID()
	case product.FieldInheritStall:
		return m.InheritStall()
	case product.FieldStallID:
		return m.StallID()
	case product.FieldMainImage:
		return m.MainImage()
	case product.FieldDetailImages:
		return m.DetailImages()
	case product.FieldDescription:
		return m.Description()
	case product.FieldEstimatedCostPrice:
		return m.EstimatedCostPrice()
	case product.FieldDeliveryCostPrice:
		return m.DeliveryCostPrice()
	case product.FieldMerchantID:
		return m.MerchantID()
	case product.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldType:
		return m.OldType(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case product.FieldMenuID:
		return m.OldMenuID(ctx)
	case product.FieldMnemonic:
		return m.OldMnemonic(ctx)
	case product.FieldShelfLife:
		return m.OldShelfLife(ctx)
	case product.FieldSupportTypes:
		return m.OldSupportTypes(ctx)
	case product.FieldUnitID:
		return m.OldUnitID(ctx)
	case product.FieldSaleStatus:
		return m.OldSaleStatus(ctx)
	case product.FieldSaleChannels:
		return m.OldSaleChannels(ctx)
	case product.FieldEffectiveDateType:
		return m.OldEffectiveDateType(ctx)
	case product.FieldEffectiveStartTime:
		return m.OldEffectiveStartTime(ctx)
	case product.FieldEffectiveEndTime:
		return m.OldEffectiveEndTime(ctx)
	case product.FieldMinSaleQuantity:
		return m.OldMinSaleQuantity(ctx)
	case product.FieldAddSaleQuantity:
		return m.OldAddSaleQuantity(ctx)
	case product.FieldInheritTaxRate:
		return m.OldInheritTaxRate(ctx)
	case product.FieldTaxRateID:
		return m.OldTaxRateID(ctx)
	case product.FieldInheritStall:
		return m.OldInheritStall(ctx)
	case product.FieldStallID:
		return m.OldStallID(ctx)
	case product.FieldMainImage:
		return m.OldMainImage(ctx)
	case product.FieldDetailImages:
		return m.OldDetailImages(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldEstimatedCostPrice:
		return m.OldEstimatedCostPrice(ctx)
	case product.FieldDeliveryCostPrice:
		return m.OldDeliveryCostPrice(ctx)
	case product.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case product.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldType:
		v, ok := value.(domain.ProductType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case product.FieldMenuID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	case product.FieldMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMnemonic(v)
		return nil
	case product.FieldShelfLife:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShelfLife(v)
		return nil
	case product.FieldSupportTypes:
		v, ok := value.([]domain.ProductSupportType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportTypes(v)
		return nil
	case product.FieldUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case product.FieldSaleStatus:
		v, ok := value.(domain.ProductSaleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStatus(v)
		return nil
	case product.FieldSaleChannels:
		v, ok := value.([]domain.SaleChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleChannels(v)
		return nil
	case product.FieldEffectiveDateType:
		v, ok := value.(domain.EffectiveDateType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDateType(v)
		return nil
	case product.FieldEffectiveStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveStartTime(v)
		return nil
	case product.FieldEffectiveEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveEndTime(v)
		return nil
	case product.FieldMinSaleQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinSaleQuantity(v)
		return nil
	case product.FieldAddSaleQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddSaleQuantity(v)
		return nil
	case product.FieldInheritTaxRate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritTaxRate(v)
		return nil
	case product.FieldTaxRateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRateID(v)
		return nil
	case product.FieldInheritStall:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritStall(v)
		return nil
	case product.FieldStallID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStallID(v)
		return nil
	case product.FieldMainImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainImage(v)
		return nil
	case product.FieldDetailImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailImages(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldEstimatedCostPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCostPrice(v)
		return nil
	case product.FieldDeliveryCostPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryCostPrice(v)
		return nil
	case product.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case product.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.addshelf_life != nil {
		fields = append(fields, product.FieldShelfLife)
	}
	if m.addmin_sale_quantity != nil {
		fields = append(fields, product.FieldMinSaleQuantity)
	}
	if m.addadd_sale_quantity != nil {
		fields = append(fields, product.FieldAddSaleQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldDeletedAt:
		return m.AddedDeletedAt()
	case product.FieldShelfLife:
		return m.AddedShelfLife()
	case product.FieldMinSaleQuantity:
		return m.AddedMinSaleQuantity()
	case product.FieldAddSaleQuantity:
		return m.AddedAddSaleQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case product.FieldShelfLife:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShelfLife(v)
		return nil
	case product.FieldMinSaleQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinSaleQuantity(v)
		return nil
	case product.FieldAddSaleQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAddSaleQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldMenuID) {
		fields = append(fields, product.FieldMenuID)
	}
	if m.FieldCleared(product.FieldEffectiveDateType) {
		fields = append(fields, product.FieldEffectiveDateType)
	}
	if m.FieldCleared(product.FieldEffectiveStartTime) {
		fields = append(fields, product.FieldEffectiveStartTime)
	}
	if m.FieldCleared(product.FieldEffectiveEndTime) {
		fields = append(fields, product.FieldEffectiveEndTime)
	}
	if m.FieldCleared(product.FieldMinSaleQuantity) {
		fields = append(fields, product.FieldMinSaleQuantity)
	}
	if m.FieldCleared(product.FieldAddSaleQuantity) {
		fields = append(fields, product.FieldAddSaleQuantity)
	}
	if m.FieldCleared(product.FieldTaxRateID) {
		fields = append(fields, product.FieldTaxRateID)
	}
	if m.FieldCleared(product.FieldStallID) {
		fields = append(fields, product.FieldStallID)
	}
	if m.FieldCleared(product.FieldDetailImages) {
		fields = append(fields, product.FieldDetailImages)
	}
	if m.FieldCleared(product.FieldEstimatedCostPrice) {
		fields = append(fields, product.FieldEstimatedCostPrice)
	}
	if m.FieldCleared(product.FieldDeliveryCostPrice) {
		fields = append(fields, product.FieldDeliveryCostPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldMenuID:
		m.ClearMenuID()
		return nil
	case product.FieldEffectiveDateType:
		m.ClearEffectiveDateType()
		return nil
	case product.FieldEffectiveStartTime:
		m.ClearEffectiveStartTime()
		return nil
	case product.FieldEffectiveEndTime:
		m.ClearEffectiveEndTime()
		return nil
	case product.FieldMinSaleQuantity:
		m.ClearMinSaleQuantity()
		return nil
	case product.FieldAddSaleQuantity:
		m.ClearAddSaleQuantity()
		return nil
	case product.FieldTaxRateID:
		m.ClearTaxRateID()
		return nil
	case product.FieldStallID:
		m.ClearStallID()
		return nil
	case product.FieldDetailImages:
		m.ClearDetailImages()
		return nil
	case product.FieldEstimatedCostPrice:
		m.ClearEstimatedCostPrice()
		return nil
	case product.FieldDeliveryCostPrice:
		m.ClearDeliveryCostPrice()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldType:
		m.ResetType()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case product.FieldMenuID:
		m.ResetMenuID()
		return nil
	case product.FieldMnemonic:
		m.ResetMnemonic()
		return nil
	case product.FieldShelfLife:
		m.ResetShelfLife()
		return nil
	case product.FieldSupportTypes:
		m.ResetSupportTypes()
		return nil
	case product.FieldUnitID:
		m.ResetUnitID()
		return nil
	case product.FieldSaleStatus:
		m.ResetSaleStatus()
		return nil
	case product.FieldSaleChannels:
		m.ResetSaleChannels()
		return nil
	case product.FieldEffectiveDateType:
		m.ResetEffectiveDateType()
		return nil
	case product.FieldEffectiveStartTime:
		m.ResetEffectiveStartTime()
		return nil
	case product.FieldEffectiveEndTime:
		m.ResetEffectiveEndTime()
		return nil
	case product.FieldMinSaleQuantity:
		m.ResetMinSaleQuantity()
		return nil
	case product.FieldAddSaleQuantity:
		m.ResetAddSaleQuantity()
		return nil
	case product.FieldInheritTaxRate:
		m.ResetInheritTaxRate()
		return nil
	case product.FieldTaxRateID:
		m.ResetTaxRateID()
		return nil
	case product.FieldInheritStall:
		m.ResetInheritStall()
		return nil
	case product.FieldStallID:
		m.ResetStallID()
		return nil
	case product.FieldMainImage:
		m.ResetMainImage()
		return nil
	case product.FieldDetailImages:
		m.ResetDetailImages()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldEstimatedCostPrice:
		m.ResetEstimatedCostPrice()
		return nil
	case product.FieldDeliveryCostPrice:
		m.ResetDeliveryCostPrice()
		return nil
	case product.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case product.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.category != nil {
		edges = append(edges, product.EdgeCategory)
	}
	if m.unit != nil {
		edges = append(edges, product.EdgeUnit)
	}
	if m.tags != nil {
		edges = append(edges, product.EdgeTags)
	}
	if m.product_specs != nil {
		edges = append(edges, product.EdgeProductSpecs)
	}
	if m.product_attrs != nil {
		edges = append(edges, product.EdgeProductAttrs)
	}
	if m.set_meal_groups != nil {
		edges = append(edges, product.EdgeSetMealGroups)
	}
	if m.set_meal_details != nil {
		edges = append(edges, product.EdgeSetMealDetails)
	}
	if m.menu_items != nil {
		edges = append(edges, product.EdgeMenuItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.product_specs))
		for id := range m.product_specs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductAttrs:
		ids := make([]ent.Value, 0, len(m.product_attrs))
		for id := range m.product_attrs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeSetMealGroups:
		ids := make([]ent.Value, 0, len(m.set_meal_groups))
		for id := range m.set_meal_groups {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.set_meal_details))
		for id := range m.set_meal_details {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.menu_items))
		for id := range m.menu_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedtags != nil {
		edges = append(edges, product.EdgeTags)
	}
	if m.removedproduct_specs != nil {
		edges = append(edges, product.EdgeProductSpecs)
	}
	if m.removedproduct_attrs != nil {
		edges = append(edges, product.EdgeProductAttrs)
	}
	if m.removedset_meal_groups != nil {
		edges = append(edges, product.EdgeSetMealGroups)
	}
	if m.removedset_meal_details != nil {
		edges = append(edges, product.EdgeSetMealDetails)
	}
	if m.removedmenu_items != nil {
		edges = append(edges, product.EdgeMenuItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.removedproduct_specs))
		for id := range m.removedproduct_specs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductAttrs:
		ids := make([]ent.Value, 0, len(m.removedproduct_attrs))
		for id := range m.removedproduct_attrs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeSetMealGroups:
		ids := make([]ent.Value, 0, len(m.removedset_meal_groups))
		for id := range m.removedset_meal_groups {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeSetMealDetails:
		ids := make([]ent.Value, 0, len(m.removedset_meal_details))
		for id := range m.removedset_meal_details {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.removedmenu_items))
		for id := range m.removedmenu_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcategory {
		edges = append(edges, product.EdgeCategory)
	}
	if m.clearedunit {
		edges = append(edges, product.EdgeUnit)
	}
	if m.clearedtags {
		edges = append(edges, product.EdgeTags)
	}
	if m.clearedproduct_specs {
		edges = append(edges, product.EdgeProductSpecs)
	}
	if m.clearedproduct_attrs {
		edges = append(edges, product.EdgeProductAttrs)
	}
	if m.clearedset_meal_groups {
		edges = append(edges, product.EdgeSetMealGroups)
	}
	if m.clearedset_meal_details {
		edges = append(edges, product.EdgeSetMealDetails)
	}
	if m.clearedmenu_items {
		edges = append(edges, product.EdgeMenuItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCategory:
		return m.clearedcategory
	case product.EdgeUnit:
		return m.clearedunit
	case product.EdgeTags:
		return m.clearedtags
	case product.EdgeProductSpecs:
		return m.clearedproduct_specs
	case product.EdgeProductAttrs:
		return m.clearedproduct_attrs
	case product.EdgeSetMealGroups:
		return m.clearedset_meal_groups
	case product.EdgeSetMealDetails:
		return m.clearedset_meal_details
	case product.EdgeMenuItems:
		return m.clearedmenu_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCategory:
		m.ClearCategory()
		return nil
	case product.EdgeUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCategory:
		m.ResetCategory()
		return nil
	case product.EdgeUnit:
		m.ResetUnit()
		return nil
	case product.EdgeTags:
		m.ResetTags()
		return nil
	case product.EdgeProductSpecs:
		m.ResetProductSpecs()
		return nil
	case product.EdgeProductAttrs:
		m.ResetProductAttrs()
		return nil
	case product.EdgeSetMealGroups:
		m.ResetSetMealGroups()
		return nil
	case product.EdgeSetMealDetails:
		m.ResetSetMealDetails()
		return nil
	case product.EdgeMenuItems:
		m.ResetMenuItems()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductAttrMutation represents an operation that mutates the ProductAttr nodes in the graph.
type ProductAttrMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int64
	adddeleted_at        *int64
	name                 *string
	channels             *[]domain.SaleChannel
	appendchannels       []domain.SaleChannel
	merchant_id          *uuid.UUID
	store_id             *uuid.UUID
	product_count        *int
	addproduct_count     *int
	clearedFields        map[string]struct{}
	items                map[uuid.UUID]struct{}
	removeditems         map[uuid.UUID]struct{}
	cleareditems         bool
	product_attrs        map[uuid.UUID]struct{}
	removedproduct_attrs map[uuid.UUID]struct{}
	clearedproduct_attrs bool
	done                 bool
	oldValue             func(context.Context) (*ProductAttr, error)
	predicates           []predicate.ProductAttr
}

var _ ent.Mutation = (*ProductAttrMutation)(nil)

// productattrOption allows management of the mutation configuration using functional options.
type productattrOption func(*ProductAttrMutation)

// newProductAttrMutation creates new mutation for the ProductAttr entity.
func newProductAttrMutation(c config, op Op, opts ...productattrOption) *ProductAttrMutation {
	m := &ProductAttrMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttrID sets the ID field of the mutation.
func withProductAttrID(id uuid.UUID) productattrOption {
	return func(m *ProductAttrMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttr
		)
		m.oldValue = func(ctx context.Context) (*ProductAttr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttr sets the old ProductAttr of the mutation.
func withProductAttr(node *ProductAttr) productattrOption {
	return func(m *ProductAttrMutation) {
		m.oldValue = func(context.Context) (*ProductAttr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductAttr entities.
func (m *ProductAttrMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAttrMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductAttrMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductAttr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductAttrMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductAttrMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductAttrMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductAttrMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductAttrMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductAttrMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductAttrMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductAttrMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductAttrMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductAttrMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductAttrMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductAttrMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductAttrMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductAttrMutation) ResetName() {
	m.name = nil
}

// SetChannels sets the "channels" field.
func (m *ProductAttrMutation) SetChannels(dc []domain.SaleChannel) {
	m.channels = &dc
	m.appendchannels = nil
}

// Channels returns the value of the "channels" field in the mutation.
func (m *ProductAttrMutation) Channels() (r []domain.SaleChannel, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannels returns the old "channels" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldChannels(ctx context.Context) (v []domain.SaleChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannels: %w", err)
	}
	return oldValue.Channels, nil
}

// AppendChannels adds dc to the "channels" field.
func (m *ProductAttrMutation) AppendChannels(dc []domain.SaleChannel) {
	m.appendchannels = append(m.appendchannels, dc...)
}

// AppendedChannels returns the list of values that were appended to the "channels" field in this mutation.
func (m *ProductAttrMutation) AppendedChannels() ([]domain.SaleChannel, bool) {
	if len(m.appendchannels) == 0 {
		return nil, false
	}
	return m.appendchannels, true
}

// ResetChannels resets all changes to the "channels" field.
func (m *ProductAttrMutation) ResetChannels() {
	m.channels = nil
	m.appendchannels = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductAttrMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductAttrMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductAttrMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductAttrMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductAttrMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductAttrMutation) ResetStoreID() {
	m.store_id = nil
}

// SetProductCount sets the "product_count" field.
func (m *ProductAttrMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductAttrMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductAttr entity.
// If the ProductAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductAttrMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductAttrMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductAttrMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// AddItemIDs adds the "items" edge to the ProductAttrItem entity by ids.
func (m *ProductAttrMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ProductAttrItem entity.
func (m *ProductAttrMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ProductAttrItem entity was cleared.
func (m *ProductAttrMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ProductAttrItem entity by IDs.
func (m *ProductAttrMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ProductAttrItem entity.
func (m *ProductAttrMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ProductAttrMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ProductAttrMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddProductAttrIDs adds the "product_attrs" edge to the ProductAttrRelation entity by ids.
func (m *ProductAttrMutation) AddProductAttrIDs(ids ...uuid.UUID) {
	if m.product_attrs == nil {
		m.product_attrs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.product_attrs[ids[i]] = struct{}{}
	}
}

// ClearProductAttrs clears the "product_attrs" edge to the ProductAttrRelation entity.
func (m *ProductAttrMutation) ClearProductAttrs() {
	m.clearedproduct_attrs = true
}

// ProductAttrsCleared reports if the "product_attrs" edge to the ProductAttrRelation entity was cleared.
func (m *ProductAttrMutation) ProductAttrsCleared() bool {
	return m.clearedproduct_attrs
}

// RemoveProductAttrIDs removes the "product_attrs" edge to the ProductAttrRelation entity by IDs.
func (m *ProductAttrMutation) RemoveProductAttrIDs(ids ...uuid.UUID) {
	if m.removedproduct_attrs == nil {
		m.removedproduct_attrs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.product_attrs, ids[i])
		m.removedproduct_attrs[ids[i]] = struct{}{}
	}
}

// RemovedProductAttrs returns the removed IDs of the "product_attrs" edge to the ProductAttrRelation entity.
func (m *ProductAttrMutation) RemovedProductAttrsIDs() (ids []uuid.UUID) {
	for id := range m.removedproduct_attrs {
		ids = append(ids, id)
	}
	return
}

// ProductAttrsIDs returns the "product_attrs" edge IDs in the mutation.
func (m *ProductAttrMutation) ProductAttrsIDs() (ids []uuid.UUID) {
	for id := range m.product_attrs {
		ids = append(ids, id)
	}
	return
}

// ResetProductAttrs resets all changes to the "product_attrs" edge.
func (m *ProductAttrMutation) ResetProductAttrs() {
	m.product_attrs = nil
	m.clearedproduct_attrs = false
	m.removedproduct_attrs = nil
}

// Where appends a list predicates to the ProductAttrMutation builder.
func (m *ProductAttrMutation) Where(ps ...predicate.ProductAttr) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductAttrMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductAttrMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductAttr, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductAttrMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductAttrMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductAttr).
func (m *ProductAttrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttrMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, productattr.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productattr.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productattr.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, productattr.FieldName)
	}
	if m.channels != nil {
		fields = append(fields, productattr.FieldChannels)
	}
	if m.merchant_id != nil {
		fields = append(fields, productattr.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, productattr.FieldStoreID)
	}
	if m.product_count != nil {
		fields = append(fields, productattr.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattr.FieldCreatedAt:
		return m.CreatedAt()
	case productattr.FieldUpdatedAt:
		return m.UpdatedAt()
	case productattr.FieldDeletedAt:
		return m.DeletedAt()
	case productattr.FieldName:
		return m.Name()
	case productattr.FieldChannels:
		return m.Channels()
	case productattr.FieldMerchantID:
		return m.MerchantID()
	case productattr.FieldStoreID:
		return m.StoreID()
	case productattr.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattr.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productattr.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productattr.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productattr.FieldName:
		return m.OldName(ctx)
	case productattr.FieldChannels:
		return m.OldChannels(ctx)
	case productattr.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case productattr.FieldStoreID:
		return m.OldStoreID(ctx)
	case productattr.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattr.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productattr.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productattr.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productattr.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productattr.FieldChannels:
		v, ok := value.([]domain.SaleChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannels(v)
		return nil
	case productattr.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case productattr.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case productattr.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttrMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productattr.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, productattr.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattr.FieldDeletedAt:
		return m.AddedDeletedAt()
	case productattr.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattr.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case productattr.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttrMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttrMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductAttr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttrMutation) ResetField(name string) error {
	switch name {
	case productattr.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productattr.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productattr.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productattr.FieldName:
		m.ResetName()
		return nil
	case productattr.FieldChannels:
		m.ResetChannels()
		return nil
	case productattr.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case productattr.FieldStoreID:
		m.ResetStoreID()
		return nil
	case productattr.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductAttr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttrMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.items != nil {
		edges = append(edges, productattr.EdgeItems)
	}
	if m.product_attrs != nil {
		edges = append(edges, productattr.EdgeProductAttrs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttrMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productattr.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case productattr.EdgeProductAttrs:
		ids := make([]ent.Value, 0, len(m.product_attrs))
		for id := range m.product_attrs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, productattr.EdgeItems)
	}
	if m.removedproduct_attrs != nil {
		edges = append(edges, productattr.EdgeProductAttrs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttrMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productattr.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case productattr.EdgeProductAttrs:
		ids := make([]ent.Value, 0, len(m.removedproduct_attrs))
		for id := range m.removedproduct_attrs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditems {
		edges = append(edges, productattr.EdgeItems)
	}
	if m.clearedproduct_attrs {
		edges = append(edges, productattr.EdgeProductAttrs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttrMutation) EdgeCleared(name string) bool {
	switch name {
	case productattr.EdgeItems:
		return m.cleareditems
	case productattr.EdgeProductAttrs:
		return m.clearedproduct_attrs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttrMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductAttr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttrMutation) ResetEdge(name string) error {
	switch name {
	case productattr.EdgeItems:
		m.ResetItems()
		return nil
	case productattr.EdgeProductAttrs:
		m.ResetProductAttrs()
		return nil
	}
	return fmt.Errorf("unknown ProductAttr edge %s", name)
}

// ProductAttrItemMutation represents an operation that mutates the ProductAttrItem nodes in the graph.
type ProductAttrItemMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int64
	adddeleted_at        *int64
	name                 *string
	image                *string
	base_price           *decimal.Decimal
	product_count        *int
	addproduct_count     *int
	clearedFields        map[string]struct{}
	attr                 *uuid.UUID
	clearedattr          bool
	product_attrs        map[uuid.UUID]struct{}
	removedproduct_attrs map[uuid.UUID]struct{}
	clearedproduct_attrs bool
	done                 bool
	oldValue             func(context.Context) (*ProductAttrItem, error)
	predicates           []predicate.ProductAttrItem
}

var _ ent.Mutation = (*ProductAttrItemMutation)(nil)

// productattritemOption allows management of the mutation configuration using functional options.
type productattritemOption func(*ProductAttrItemMutation)

// newProductAttrItemMutation creates new mutation for the ProductAttrItem entity.
func newProductAttrItemMutation(c config, op Op, opts ...productattritemOption) *ProductAttrItemMutation {
	m := &ProductAttrItemMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttrItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttrItemID sets the ID field of the mutation.
func withProductAttrItemID(id uuid.UUID) productattritemOption {
	return func(m *ProductAttrItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttrItem
		)
		m.oldValue = func(ctx context.Context) (*ProductAttrItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttrItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttrItem sets the old ProductAttrItem of the mutation.
func withProductAttrItem(node *ProductAttrItem) productattritemOption {
	return func(m *ProductAttrItemMutation) {
		m.oldValue = func(context.Context) (*ProductAttrItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttrItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttrItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductAttrItem entities.
func (m *ProductAttrItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAttrItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductAttrItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductAttrItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductAttrItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductAttrItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductAttrItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductAttrItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductAttrItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductAttrItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductAttrItemMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductAttrItemMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductAttrItemMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductAttrItemMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductAttrItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAttrID sets the "attr_id" field.
func (m *ProductAttrItemMutation) SetAttrID(u uuid.UUID) {
	m.attr = &u
}

// AttrID returns the value of the "attr_id" field in the mutation.
func (m *ProductAttrItemMutation) AttrID() (r uuid.UUID, exists bool) {
	v := m.attr
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrID returns the old "attr_id" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldAttrID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrID: %w", err)
	}
	return oldValue.AttrID, nil
}

// ResetAttrID resets all changes to the "attr_id" field.
func (m *ProductAttrItemMutation) ResetAttrID() {
	m.attr = nil
}

// SetName sets the "name" field.
func (m *ProductAttrItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductAttrItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductAttrItemMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *ProductAttrItemMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ProductAttrItemMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ProductAttrItemMutation) ResetImage() {
	m.image = nil
}

// SetBasePrice sets the "base_price" field.
func (m *ProductAttrItemMutation) SetBasePrice(d decimal.Decimal) {
	m.base_price = &d
}

// BasePrice returns the value of the "base_price" field in the mutation.
func (m *ProductAttrItemMutation) BasePrice() (r decimal.Decimal, exists bool) {
	v := m.base_price
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePrice returns the old "base_price" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldBasePrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePrice: %w", err)
	}
	return oldValue.BasePrice, nil
}

// ResetBasePrice resets all changes to the "base_price" field.
func (m *ProductAttrItemMutation) ResetBasePrice() {
	m.base_price = nil
}

// SetProductCount sets the "product_count" field.
func (m *ProductAttrItemMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductAttrItemMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductAttrItem entity.
// If the ProductAttrItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrItemMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductAttrItemMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductAttrItemMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductAttrItemMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// ClearAttr clears the "attr" edge to the ProductAttr entity.
func (m *ProductAttrItemMutation) ClearAttr() {
	m.clearedattr = true
	m.clearedFields[productattritem.FieldAttrID] = struct{}{}
}

// AttrCleared reports if the "attr" edge to the ProductAttr entity was cleared.
func (m *ProductAttrItemMutation) AttrCleared() bool {
	return m.clearedattr
}

// AttrIDs returns the "attr" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttrID instead. It exists only for internal usage by the builders.
func (m *ProductAttrItemMutation) AttrIDs() (ids []uuid.UUID) {
	if id := m.attr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttr resets all changes to the "attr" edge.
func (m *ProductAttrItemMutation) ResetAttr() {
	m.attr = nil
	m.clearedattr = false
}

// AddProductAttrIDs adds the "product_attrs" edge to the ProductAttrRelation entity by ids.
func (m *ProductAttrItemMutation) AddProductAttrIDs(ids ...uuid.UUID) {
	if m.product_attrs == nil {
		m.product_attrs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.product_attrs[ids[i]] = struct{}{}
	}
}

// ClearProductAttrs clears the "product_attrs" edge to the ProductAttrRelation entity.
func (m *ProductAttrItemMutation) ClearProductAttrs() {
	m.clearedproduct_attrs = true
}

// ProductAttrsCleared reports if the "product_attrs" edge to the ProductAttrRelation entity was cleared.
func (m *ProductAttrItemMutation) ProductAttrsCleared() bool {
	return m.clearedproduct_attrs
}

// RemoveProductAttrIDs removes the "product_attrs" edge to the ProductAttrRelation entity by IDs.
func (m *ProductAttrItemMutation) RemoveProductAttrIDs(ids ...uuid.UUID) {
	if m.removedproduct_attrs == nil {
		m.removedproduct_attrs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.product_attrs, ids[i])
		m.removedproduct_attrs[ids[i]] = struct{}{}
	}
}

// RemovedProductAttrs returns the removed IDs of the "product_attrs" edge to the ProductAttrRelation entity.
func (m *ProductAttrItemMutation) RemovedProductAttrsIDs() (ids []uuid.UUID) {
	for id := range m.removedproduct_attrs {
		ids = append(ids, id)
	}
	return
}

// ProductAttrsIDs returns the "product_attrs" edge IDs in the mutation.
func (m *ProductAttrItemMutation) ProductAttrsIDs() (ids []uuid.UUID) {
	for id := range m.product_attrs {
		ids = append(ids, id)
	}
	return
}

// ResetProductAttrs resets all changes to the "product_attrs" edge.
func (m *ProductAttrItemMutation) ResetProductAttrs() {
	m.product_attrs = nil
	m.clearedproduct_attrs = false
	m.removedproduct_attrs = nil
}

// Where appends a list predicates to the ProductAttrItemMutation builder.
func (m *ProductAttrItemMutation) Where(ps ...predicate.ProductAttrItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductAttrItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductAttrItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductAttrItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductAttrItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductAttrItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductAttrItem).
func (m *ProductAttrItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttrItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, productattritem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productattritem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productattritem.FieldDeletedAt)
	}
	if m.attr != nil {
		fields = append(fields, productattritem.FieldAttrID)
	}
	if m.name != nil {
		fields = append(fields, productattritem.FieldName)
	}
	if m.image != nil {
		fields = append(fields, productattritem.FieldImage)
	}
	if m.base_price != nil {
		fields = append(fields, productattritem.FieldBasePrice)
	}
	if m.product_count != nil {
		fields = append(fields, productattritem.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttrItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattritem.FieldCreatedAt:
		return m.CreatedAt()
	case productattritem.FieldUpdatedAt:
		return m.UpdatedAt()
	case productattritem.FieldDeletedAt:
		return m.DeletedAt()
	case productattritem.FieldAttrID:
		return m.AttrID()
	case productattritem.FieldName:
		return m.Name()
	case productattritem.FieldImage:
		return m.Image()
	case productattritem.FieldBasePrice:
		return m.BasePrice()
	case productattritem.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttrItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattritem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productattritem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productattritem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productattritem.FieldAttrID:
		return m.OldAttrID(ctx)
	case productattritem.FieldName:
		return m.OldName(ctx)
	case productattritem.FieldImage:
		return m.OldImage(ctx)
	case productattritem.FieldBasePrice:
		return m.OldBasePrice(ctx)
	case productattritem.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttrItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattritem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productattritem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productattritem.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productattritem.FieldAttrID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrID(v)
		return nil
	case productattritem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productattritem.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case productattritem.FieldBasePrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePrice(v)
		return nil
	case productattritem.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttrItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttrItemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productattritem.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, productattritem.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttrItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattritem.FieldDeletedAt:
		return m.AddedDeletedAt()
	case productattritem.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattritem.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case productattritem.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttrItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttrItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttrItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttrItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductAttrItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttrItemMutation) ResetField(name string) error {
	switch name {
	case productattritem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productattritem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productattritem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productattritem.FieldAttrID:
		m.ResetAttrID()
		return nil
	case productattritem.FieldName:
		m.ResetName()
		return nil
	case productattritem.FieldImage:
		m.ResetImage()
		return nil
	case productattritem.FieldBasePrice:
		m.ResetBasePrice()
		return nil
	case productattritem.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttrItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attr != nil {
		edges = append(edges, productattritem.EdgeAttr)
	}
	if m.product_attrs != nil {
		edges = append(edges, productattritem.EdgeProductAttrs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttrItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productattritem.EdgeAttr:
		if id := m.attr; id != nil {
			return []ent.Value{*id}
		}
	case productattritem.EdgeProductAttrs:
		ids := make([]ent.Value, 0, len(m.product_attrs))
		for id := range m.product_attrs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttrItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct_attrs != nil {
		edges = append(edges, productattritem.EdgeProductAttrs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttrItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productattritem.EdgeProductAttrs:
		ids := make([]ent.Value, 0, len(m.removedproduct_attrs))
		for id := range m.removedproduct_attrs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttrItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattr {
		edges = append(edges, productattritem.EdgeAttr)
	}
	if m.clearedproduct_attrs {
		edges = append(edges, productattritem.EdgeProductAttrs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttrItemMutation) EdgeCleared(name string) bool {
	switch name {
	case productattritem.EdgeAttr:
		return m.clearedattr
	case productattritem.EdgeProductAttrs:
		return m.clearedproduct_attrs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttrItemMutation) ClearEdge(name string) error {
	switch name {
	case productattritem.EdgeAttr:
		m.ClearAttr()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttrItemMutation) ResetEdge(name string) error {
	switch name {
	case productattritem.EdgeAttr:
		m.ResetAttr()
		return nil
	case productattritem.EdgeProductAttrs:
		m.ResetProductAttrs()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrItem edge %s", name)
}

// ProductAttrRelationMutation represents an operation that mutates the ProductAttrRelation nodes in the graph.
type ProductAttrRelationMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	is_default       *bool
	clearedFields    map[string]struct{}
	product          *uuid.UUID
	clearedproduct   bool
	attr             *uuid.UUID
	clearedattr      bool
	attr_item        *uuid.UUID
	clearedattr_item bool
	done             bool
	oldValue         func(context.Context) (*ProductAttrRelation, error)
	predicates       []predicate.ProductAttrRelation
}

var _ ent.Mutation = (*ProductAttrRelationMutation)(nil)

// productattrrelationOption allows management of the mutation configuration using functional options.
type productattrrelationOption func(*ProductAttrRelationMutation)

// newProductAttrRelationMutation creates new mutation for the ProductAttrRelation entity.
func newProductAttrRelationMutation(c config, op Op, opts ...productattrrelationOption) *ProductAttrRelationMutation {
	m := &ProductAttrRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAttrRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAttrRelationID sets the ID field of the mutation.
func withProductAttrRelationID(id uuid.UUID) productattrrelationOption {
	return func(m *ProductAttrRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAttrRelation
		)
		m.oldValue = func(ctx context.Context) (*ProductAttrRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAttrRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAttrRelation sets the old ProductAttrRelation of the mutation.
func withProductAttrRelation(node *ProductAttrRelation) productattrrelationOption {
	return func(m *ProductAttrRelationMutation) {
		m.oldValue = func(context.Context) (*ProductAttrRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAttrRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAttrRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductAttrRelation entities.
func (m *ProductAttrRelationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAttrRelationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductAttrRelationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductAttrRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductAttrRelationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductAttrRelationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductAttrRelationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductAttrRelationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductAttrRelationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductAttrRelationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductAttrRelationMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductAttrRelationMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductAttrRelationMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductAttrRelationMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductAttrRelationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductAttrRelationMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductAttrRelationMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductAttrRelationMutation) ResetProductID() {
	m.product = nil
}

// SetAttrID sets the "attr_id" field.
func (m *ProductAttrRelationMutation) SetAttrID(u uuid.UUID) {
	m.attr = &u
}

// AttrID returns the value of the "attr_id" field in the mutation.
func (m *ProductAttrRelationMutation) AttrID() (r uuid.UUID, exists bool) {
	v := m.attr
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrID returns the old "attr_id" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldAttrID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrID: %w", err)
	}
	return oldValue.AttrID, nil
}

// ResetAttrID resets all changes to the "attr_id" field.
func (m *ProductAttrRelationMutation) ResetAttrID() {
	m.attr = nil
}

// SetAttrItemID sets the "attr_item_id" field.
func (m *ProductAttrRelationMutation) SetAttrItemID(u uuid.UUID) {
	m.attr_item = &u
}

// AttrItemID returns the value of the "attr_item_id" field in the mutation.
func (m *ProductAttrRelationMutation) AttrItemID() (r uuid.UUID, exists bool) {
	v := m.attr_item
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrItemID returns the old "attr_item_id" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldAttrItemID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrItemID: %w", err)
	}
	return oldValue.AttrItemID, nil
}

// ResetAttrItemID resets all changes to the "attr_item_id" field.
func (m *ProductAttrRelationMutation) ResetAttrItemID() {
	m.attr_item = nil
}

// SetIsDefault sets the "is_default" field.
func (m *ProductAttrRelationMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *ProductAttrRelationMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the ProductAttrRelation entity.
// If the ProductAttrRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAttrRelationMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *ProductAttrRelationMutation) ResetIsDefault() {
	m.is_default = nil
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductAttrRelationMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productattrrelation.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductAttrRelationMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductAttrRelationMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductAttrRelationMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearAttr clears the "attr" edge to the ProductAttr entity.
func (m *ProductAttrRelationMutation) ClearAttr() {
	m.clearedattr = true
	m.clearedFields[productattrrelation.FieldAttrID] = struct{}{}
}

// AttrCleared reports if the "attr" edge to the ProductAttr entity was cleared.
func (m *ProductAttrRelationMutation) AttrCleared() bool {
	return m.clearedattr
}

// AttrIDs returns the "attr" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttrID instead. It exists only for internal usage by the builders.
func (m *ProductAttrRelationMutation) AttrIDs() (ids []uuid.UUID) {
	if id := m.attr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttr resets all changes to the "attr" edge.
func (m *ProductAttrRelationMutation) ResetAttr() {
	m.attr = nil
	m.clearedattr = false
}

// ClearAttrItem clears the "attr_item" edge to the ProductAttrItem entity.
func (m *ProductAttrRelationMutation) ClearAttrItem() {
	m.clearedattr_item = true
	m.clearedFields[productattrrelation.FieldAttrItemID] = struct{}{}
}

// AttrItemCleared reports if the "attr_item" edge to the ProductAttrItem entity was cleared.
func (m *ProductAttrRelationMutation) AttrItemCleared() bool {
	return m.clearedattr_item
}

// AttrItemIDs returns the "attr_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttrItemID instead. It exists only for internal usage by the builders.
func (m *ProductAttrRelationMutation) AttrItemIDs() (ids []uuid.UUID) {
	if id := m.attr_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttrItem resets all changes to the "attr_item" edge.
func (m *ProductAttrRelationMutation) ResetAttrItem() {
	m.attr_item = nil
	m.clearedattr_item = false
}

// Where appends a list predicates to the ProductAttrRelationMutation builder.
func (m *ProductAttrRelationMutation) Where(ps ...predicate.ProductAttrRelation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductAttrRelationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductAttrRelationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductAttrRelation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductAttrRelationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductAttrRelationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductAttrRelation).
func (m *ProductAttrRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAttrRelationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, productattrrelation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productattrrelation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productattrrelation.FieldDeletedAt)
	}
	if m.product != nil {
		fields = append(fields, productattrrelation.FieldProductID)
	}
	if m.attr != nil {
		fields = append(fields, productattrrelation.FieldAttrID)
	}
	if m.attr_item != nil {
		fields = append(fields, productattrrelation.FieldAttrItemID)
	}
	if m.is_default != nil {
		fields = append(fields, productattrrelation.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAttrRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productattrrelation.FieldCreatedAt:
		return m.CreatedAt()
	case productattrrelation.FieldUpdatedAt:
		return m.UpdatedAt()
	case productattrrelation.FieldDeletedAt:
		return m.DeletedAt()
	case productattrrelation.FieldProductID:
		return m.ProductID()
	case productattrrelation.FieldAttrID:
		return m.AttrID()
	case productattrrelation.FieldAttrItemID:
		return m.AttrItemID()
	case productattrrelation.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAttrRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productattrrelation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productattrrelation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productattrrelation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productattrrelation.FieldProductID:
		return m.OldProductID(ctx)
	case productattrrelation.FieldAttrID:
		return m.OldAttrID(ctx)
	case productattrrelation.FieldAttrItemID:
		return m.OldAttrItemID(ctx)
	case productattrrelation.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAttrRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productattrrelation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productattrrelation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productattrrelation.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productattrrelation.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productattrrelation.FieldAttrID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrID(v)
		return nil
	case productattrrelation.FieldAttrItemID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrItemID(v)
		return nil
	case productattrrelation.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttrRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAttrRelationMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productattrrelation.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAttrRelationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productattrrelation.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAttrRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productattrrelation.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAttrRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAttrRelationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAttrRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAttrRelationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductAttrRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAttrRelationMutation) ResetField(name string) error {
	switch name {
	case productattrrelation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productattrrelation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productattrrelation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productattrrelation.FieldProductID:
		m.ResetProductID()
		return nil
	case productattrrelation.FieldAttrID:
		m.ResetAttrID()
		return nil
	case productattrrelation.FieldAttrItemID:
		m.ResetAttrItemID()
		return nil
	case productattrrelation.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAttrRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.product != nil {
		edges = append(edges, productattrrelation.EdgeProduct)
	}
	if m.attr != nil {
		edges = append(edges, productattrrelation.EdgeAttr)
	}
	if m.attr_item != nil {
		edges = append(edges, productattrrelation.EdgeAttrItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAttrRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productattrrelation.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productattrrelation.EdgeAttr:
		if id := m.attr; id != nil {
			return []ent.Value{*id}
		}
	case productattrrelation.EdgeAttrItem:
		if id := m.attr_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAttrRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAttrRelationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAttrRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproduct {
		edges = append(edges, productattrrelation.EdgeProduct)
	}
	if m.clearedattr {
		edges = append(edges, productattrrelation.EdgeAttr)
	}
	if m.clearedattr_item {
		edges = append(edges, productattrrelation.EdgeAttrItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAttrRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case productattrrelation.EdgeProduct:
		return m.clearedproduct
	case productattrrelation.EdgeAttr:
		return m.clearedattr
	case productattrrelation.EdgeAttrItem:
		return m.clearedattr_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAttrRelationMutation) ClearEdge(name string) error {
	switch name {
	case productattrrelation.EdgeProduct:
		m.ClearProduct()
		return nil
	case productattrrelation.EdgeAttr:
		m.ClearAttr()
		return nil
	case productattrrelation.EdgeAttrItem:
		m.ClearAttrItem()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAttrRelationMutation) ResetEdge(name string) error {
	switch name {
	case productattrrelation.EdgeProduct:
		m.ResetProduct()
		return nil
	case productattrrelation.EdgeAttr:
		m.ResetAttr()
		return nil
	case productattrrelation.EdgeAttrItem:
		m.ResetAttrItem()
		return nil
	}
	return fmt.Errorf("unknown ProductAttrRelation edge %s", name)
}

// ProductSpecMutation represents an operation that mutates the ProductSpec nodes in the graph.
type ProductSpecMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int64
	adddeleted_at        *int64
	name                 *string
	merchant_id          *uuid.UUID
	store_id             *uuid.UUID
	product_count        *int
	addproduct_count     *int
	clearedFields        map[string]struct{}
	product_specs        map[uuid.UUID]struct{}
	removedproduct_specs map[uuid.UUID]struct{}
	clearedproduct_specs bool
	done                 bool
	oldValue             func(context.Context) (*ProductSpec, error)
	predicates           []predicate.ProductSpec
}

var _ ent.Mutation = (*ProductSpecMutation)(nil)

// productspecOption allows management of the mutation configuration using functional options.
type productspecOption func(*ProductSpecMutation)

// newProductSpecMutation creates new mutation for the ProductSpec entity.
func newProductSpecMutation(c config, op Op, opts ...productspecOption) *ProductSpecMutation {
	m := &ProductSpecMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpecID sets the ID field of the mutation.
func withProductSpecID(id uuid.UUID) productspecOption {
	return func(m *ProductSpecMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpec
		)
		m.oldValue = func(ctx context.Context) (*ProductSpec, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpec sets the old ProductSpec of the mutation.
func withProductSpec(node *ProductSpec) productspecOption {
	return func(m *ProductSpecMutation) {
		m.oldValue = func(context.Context) (*ProductSpec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductSpec entities.
func (m *ProductSpecMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductSpecMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductSpecMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductSpec.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductSpecMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductSpecMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductSpecMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductSpecMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductSpecMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductSpecMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductSpecMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductSpecMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductSpecMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductSpecMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductSpecMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductSpecMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductSpecMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductSpecMutation) ResetName() {
	m.name = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductSpecMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductSpecMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductSpecMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductSpecMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductSpecMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductSpecMutation) ResetStoreID() {
	m.store_id = nil
}

// SetProductCount sets the "product_count" field.
func (m *ProductSpecMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductSpecMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductSpec entity.
// If the ProductSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductSpecMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductSpecMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductSpecMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// AddProductSpecIDs adds the "product_specs" edge to the ProductSpecRelation entity by ids.
func (m *ProductSpecMutation) AddProductSpecIDs(ids ...uuid.UUID) {
	if m.product_specs == nil {
		m.product_specs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.product_specs[ids[i]] = struct{}{}
	}
}

// ClearProductSpecs clears the "product_specs" edge to the ProductSpecRelation entity.
func (m *ProductSpecMutation) ClearProductSpecs() {
	m.clearedproduct_specs = true
}

// ProductSpecsCleared reports if the "product_specs" edge to the ProductSpecRelation entity was cleared.
func (m *ProductSpecMutation) ProductSpecsCleared() bool {
	return m.clearedproduct_specs
}

// RemoveProductSpecIDs removes the "product_specs" edge to the ProductSpecRelation entity by IDs.
func (m *ProductSpecMutation) RemoveProductSpecIDs(ids ...uuid.UUID) {
	if m.removedproduct_specs == nil {
		m.removedproduct_specs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.product_specs, ids[i])
		m.removedproduct_specs[ids[i]] = struct{}{}
	}
}

// RemovedProductSpecs returns the removed IDs of the "product_specs" edge to the ProductSpecRelation entity.
func (m *ProductSpecMutation) RemovedProductSpecsIDs() (ids []uuid.UUID) {
	for id := range m.removedproduct_specs {
		ids = append(ids, id)
	}
	return
}

// ProductSpecsIDs returns the "product_specs" edge IDs in the mutation.
func (m *ProductSpecMutation) ProductSpecsIDs() (ids []uuid.UUID) {
	for id := range m.product_specs {
		ids = append(ids, id)
	}
	return
}

// ResetProductSpecs resets all changes to the "product_specs" edge.
func (m *ProductSpecMutation) ResetProductSpecs() {
	m.product_specs = nil
	m.clearedproduct_specs = false
	m.removedproduct_specs = nil
}

// Where appends a list predicates to the ProductSpecMutation builder.
func (m *ProductSpecMutation) Where(ps ...predicate.ProductSpec) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductSpecMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductSpecMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductSpec, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductSpecMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductSpecMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductSpec).
func (m *ProductSpecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpecMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, productspec.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productspec.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productspec.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, productspec.FieldName)
	}
	if m.merchant_id != nil {
		fields = append(fields, productspec.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, productspec.FieldStoreID)
	}
	if m.product_count != nil {
		fields = append(fields, productspec.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspec.FieldCreatedAt:
		return m.CreatedAt()
	case productspec.FieldUpdatedAt:
		return m.UpdatedAt()
	case productspec.FieldDeletedAt:
		return m.DeletedAt()
	case productspec.FieldName:
		return m.Name()
	case productspec.FieldMerchantID:
		return m.MerchantID()
	case productspec.FieldStoreID:
		return m.StoreID()
	case productspec.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspec.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productspec.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productspec.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productspec.FieldName:
		return m.OldName(ctx)
	case productspec.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case productspec.FieldStoreID:
		return m.OldStoreID(ctx)
	case productspec.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspec.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productspec.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productspec.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productspec.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productspec.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case productspec.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case productspec.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpecMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productspec.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, productspec.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspec.FieldDeletedAt:
		return m.AddedDeletedAt()
	case productspec.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspec.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case productspec.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpecMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpecMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductSpec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpecMutation) ResetField(name string) error {
	switch name {
	case productspec.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productspec.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productspec.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productspec.FieldName:
		m.ResetName()
		return nil
	case productspec.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case productspec.FieldStoreID:
		m.ResetStoreID()
		return nil
	case productspec.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpecMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_specs != nil {
		edges = append(edges, productspec.EdgeProductSpecs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpecMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productspec.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.product_specs))
		for id := range m.product_specs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct_specs != nil {
		edges = append(edges, productspec.EdgeProductSpecs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpecMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productspec.EdgeProductSpecs:
		ids := make([]ent.Value, 0, len(m.removedproduct_specs))
		for id := range m.removedproduct_specs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_specs {
		edges = append(edges, productspec.EdgeProductSpecs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpecMutation) EdgeCleared(name string) bool {
	switch name {
	case productspec.EdgeProductSpecs:
		return m.clearedproduct_specs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpecMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductSpec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpecMutation) ResetEdge(name string) error {
	switch name {
	case productspec.EdgeProductSpecs:
		m.ResetProductSpecs()
		return nil
	}
	return fmt.Errorf("unknown ProductSpec edge %s", name)
}

// ProductSpecRelationMutation represents an operation that mutates the ProductSpecRelation nodes in the graph.
type ProductSpecRelationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int64
	adddeleted_at        *int64
	base_price           *decimal.Decimal
	member_price         *decimal.Decimal
	packing_fee_id       *uuid.UUID
	estimated_cost_price *decimal.Decimal
	other_price1         *decimal.Decimal
	other_price2         *decimal.Decimal
	other_price3         *decimal.Decimal
	barcode              *string
	is_default           *bool
	clearedFields        map[string]struct{}
	product              *uuid.UUID
	clearedproduct       bool
	spec                 *uuid.UUID
	clearedspec          bool
	done                 bool
	oldValue             func(context.Context) (*ProductSpecRelation, error)
	predicates           []predicate.ProductSpecRelation
}

var _ ent.Mutation = (*ProductSpecRelationMutation)(nil)

// productspecrelationOption allows management of the mutation configuration using functional options.
type productspecrelationOption func(*ProductSpecRelationMutation)

// newProductSpecRelationMutation creates new mutation for the ProductSpecRelation entity.
func newProductSpecRelationMutation(c config, op Op, opts ...productspecrelationOption) *ProductSpecRelationMutation {
	m := &ProductSpecRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeProductSpecRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductSpecRelationID sets the ID field of the mutation.
func withProductSpecRelationID(id uuid.UUID) productspecrelationOption {
	return func(m *ProductSpecRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductSpecRelation
		)
		m.oldValue = func(ctx context.Context) (*ProductSpecRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductSpecRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductSpecRelation sets the old ProductSpecRelation of the mutation.
func withProductSpecRelation(node *ProductSpecRelation) productspecrelationOption {
	return func(m *ProductSpecRelationMutation) {
		m.oldValue = func(context.Context) (*ProductSpecRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductSpecRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductSpecRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductSpecRelation entities.
func (m *ProductSpecRelationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductSpecRelationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductSpecRelationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductSpecRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductSpecRelationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductSpecRelationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductSpecRelationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductSpecRelationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductSpecRelationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductSpecRelationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductSpecRelationMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductSpecRelationMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductSpecRelationMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductSpecRelationMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductSpecRelationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductSpecRelationMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductSpecRelationMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductSpecRelationMutation) ResetProductID() {
	m.product = nil
}

// SetSpecID sets the "spec_id" field.
func (m *ProductSpecRelationMutation) SetSpecID(u uuid.UUID) {
	m.spec = &u
}

// SpecID returns the value of the "spec_id" field in the mutation.
func (m *ProductSpecRelationMutation) SpecID() (r uuid.UUID, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecID returns the old "spec_id" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldSpecID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecID: %w", err)
	}
	return oldValue.SpecID, nil
}

// ResetSpecID resets all changes to the "spec_id" field.
func (m *ProductSpecRelationMutation) ResetSpecID() {
	m.spec = nil
}

// SetBasePrice sets the "base_price" field.
func (m *ProductSpecRelationMutation) SetBasePrice(d decimal.Decimal) {
	m.base_price = &d
}

// BasePrice returns the value of the "base_price" field in the mutation.
func (m *ProductSpecRelationMutation) BasePrice() (r decimal.Decimal, exists bool) {
	v := m.base_price
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePrice returns the old "base_price" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldBasePrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePrice: %w", err)
	}
	return oldValue.BasePrice, nil
}

// ResetBasePrice resets all changes to the "base_price" field.
func (m *ProductSpecRelationMutation) ResetBasePrice() {
	m.base_price = nil
}

// SetMemberPrice sets the "member_price" field.
func (m *ProductSpecRelationMutation) SetMemberPrice(d decimal.Decimal) {
	m.member_price = &d
}

// MemberPrice returns the value of the "member_price" field in the mutation.
func (m *ProductSpecRelationMutation) MemberPrice() (r decimal.Decimal, exists bool) {
	v := m.member_price
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPrice returns the old "member_price" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldMemberPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPrice: %w", err)
	}
	return oldValue.MemberPrice, nil
}

// ClearMemberPrice clears the value of the "member_price" field.
func (m *ProductSpecRelationMutation) ClearMemberPrice() {
	m.member_price = nil
	m.clearedFields[productspecrelation.FieldMemberPrice] = struct{}{}
}

// MemberPriceCleared returns if the "member_price" field was cleared in this mutation.
func (m *ProductSpecRelationMutation) MemberPriceCleared() bool {
	_, ok := m.clearedFields[productspecrelation.FieldMemberPrice]
	return ok
}

// ResetMemberPrice resets all changes to the "member_price" field.
func (m *ProductSpecRelationMutation) ResetMemberPrice() {
	m.member_price = nil
	delete(m.clearedFields, productspecrelation.FieldMemberPrice)
}

// SetPackingFeeID sets the "packing_fee_id" field.
func (m *ProductSpecRelationMutation) SetPackingFeeID(u uuid.UUID) {
	m.packing_fee_id = &u
}

// PackingFeeID returns the value of the "packing_fee_id" field in the mutation.
func (m *ProductSpecRelationMutation) PackingFeeID() (r uuid.UUID, exists bool) {
	v := m.packing_fee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackingFeeID returns the old "packing_fee_id" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldPackingFeeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackingFeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackingFeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackingFeeID: %w", err)
	}
	return oldValue.PackingFeeID, nil
}

// ResetPackingFeeID resets all changes to the "packing_fee_id" field.
func (m *ProductSpecRelationMutation) ResetPackingFeeID() {
	m.packing_fee_id = nil
}

// SetEstimatedCostPrice sets the "estimated_cost_price" field.
func (m *ProductSpecRelationMutation) SetEstimatedCostPrice(d decimal.Decimal) {
	m.estimated_cost_price = &d
}

// EstimatedCostPrice returns the value of the "estimated_cost_price" field in the mutation.
func (m *ProductSpecRelationMutation) EstimatedCostPrice() (r decimal.Decimal, exists bool) {
	v := m.estimated_cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCostPrice returns the old "estimated_cost_price" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldEstimatedCostPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCostPrice: %w", err)
	}
	return oldValue.EstimatedCostPrice, nil
}

// ClearEstimatedCostPrice clears the value of the "estimated_cost_price" field.
func (m *ProductSpecRelationMutation) ClearEstimatedCostPrice() {
	m.estimated_cost_price = nil
	m.clearedFields[productspecrelation.FieldEstimatedCostPrice] = struct{}{}
}

// EstimatedCostPriceCleared returns if the "estimated_cost_price" field was cleared in this mutation.
func (m *ProductSpecRelationMutation) EstimatedCostPriceCleared() bool {
	_, ok := m.clearedFields[productspecrelation.FieldEstimatedCostPrice]
	return ok
}

// ResetEstimatedCostPrice resets all changes to the "estimated_cost_price" field.
func (m *ProductSpecRelationMutation) ResetEstimatedCostPrice() {
	m.estimated_cost_price = nil
	delete(m.clearedFields, productspecrelation.FieldEstimatedCostPrice)
}

// SetOtherPrice1 sets the "other_price1" field.
func (m *ProductSpecRelationMutation) SetOtherPrice1(d decimal.Decimal) {
	m.other_price1 = &d
}

// OtherPrice1 returns the value of the "other_price1" field in the mutation.
func (m *ProductSpecRelationMutation) OtherPrice1() (r decimal.Decimal, exists bool) {
	v := m.other_price1
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPrice1 returns the old "other_price1" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldOtherPrice1(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPrice1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPrice1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPrice1: %w", err)
	}
	return oldValue.OtherPrice1, nil
}

// ClearOtherPrice1 clears the value of the "other_price1" field.
func (m *ProductSpecRelationMutation) ClearOtherPrice1() {
	m.other_price1 = nil
	m.clearedFields[productspecrelation.FieldOtherPrice1] = struct{}{}
}

// OtherPrice1Cleared returns if the "other_price1" field was cleared in this mutation.
func (m *ProductSpecRelationMutation) OtherPrice1Cleared() bool {
	_, ok := m.clearedFields[productspecrelation.FieldOtherPrice1]
	return ok
}

// ResetOtherPrice1 resets all changes to the "other_price1" field.
func (m *ProductSpecRelationMutation) ResetOtherPrice1() {
	m.other_price1 = nil
	delete(m.clearedFields, productspecrelation.FieldOtherPrice1)
}

// SetOtherPrice2 sets the "other_price2" field.
func (m *ProductSpecRelationMutation) SetOtherPrice2(d decimal.Decimal) {
	m.other_price2 = &d
}

// OtherPrice2 returns the value of the "other_price2" field in the mutation.
func (m *ProductSpecRelationMutation) OtherPrice2() (r decimal.Decimal, exists bool) {
	v := m.other_price2
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPrice2 returns the old "other_price2" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldOtherPrice2(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPrice2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPrice2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPrice2: %w", err)
	}
	return oldValue.OtherPrice2, nil
}

// ClearOtherPrice2 clears the value of the "other_price2" field.
func (m *ProductSpecRelationMutation) ClearOtherPrice2() {
	m.other_price2 = nil
	m.clearedFields[productspecrelation.FieldOtherPrice2] = struct{}{}
}

// OtherPrice2Cleared returns if the "other_price2" field was cleared in this mutation.
func (m *ProductSpecRelationMutation) OtherPrice2Cleared() bool {
	_, ok := m.clearedFields[productspecrelation.FieldOtherPrice2]
	return ok
}

// ResetOtherPrice2 resets all changes to the "other_price2" field.
func (m *ProductSpecRelationMutation) ResetOtherPrice2() {
	m.other_price2 = nil
	delete(m.clearedFields, productspecrelation.FieldOtherPrice2)
}

// SetOtherPrice3 sets the "other_price3" field.
func (m *ProductSpecRelationMutation) SetOtherPrice3(d decimal.Decimal) {
	m.other_price3 = &d
}

// OtherPrice3 returns the value of the "other_price3" field in the mutation.
func (m *ProductSpecRelationMutation) OtherPrice3() (r decimal.Decimal, exists bool) {
	v := m.other_price3
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPrice3 returns the old "other_price3" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldOtherPrice3(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPrice3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPrice3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPrice3: %w", err)
	}
	return oldValue.OtherPrice3, nil
}

// ClearOtherPrice3 clears the value of the "other_price3" field.
func (m *ProductSpecRelationMutation) ClearOtherPrice3() {
	m.other_price3 = nil
	m.clearedFields[productspecrelation.FieldOtherPrice3] = struct{}{}
}

// OtherPrice3Cleared returns if the "other_price3" field was cleared in this mutation.
func (m *ProductSpecRelationMutation) OtherPrice3Cleared() bool {
	_, ok := m.clearedFields[productspecrelation.FieldOtherPrice3]
	return ok
}

// ResetOtherPrice3 resets all changes to the "other_price3" field.
func (m *ProductSpecRelationMutation) ResetOtherPrice3() {
	m.other_price3 = nil
	delete(m.clearedFields, productspecrelation.FieldOtherPrice3)
}

// SetBarcode sets the "barcode" field.
func (m *ProductSpecRelationMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *ProductSpecRelationMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *ProductSpecRelationMutation) ResetBarcode() {
	m.barcode = nil
}

// SetIsDefault sets the "is_default" field.
func (m *ProductSpecRelationMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *ProductSpecRelationMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the ProductSpecRelation entity.
// If the ProductSpecRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductSpecRelationMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *ProductSpecRelationMutation) ResetIsDefault() {
	m.is_default = nil
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductSpecRelationMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productspecrelation.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductSpecRelationMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductSpecRelationMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductSpecRelationMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearSpec clears the "spec" edge to the ProductSpec entity.
func (m *ProductSpecRelationMutation) ClearSpec() {
	m.clearedspec = true
	m.clearedFields[productspecrelation.FieldSpecID] = struct{}{}
}

// SpecCleared reports if the "spec" edge to the ProductSpec entity was cleared.
func (m *ProductSpecRelationMutation) SpecCleared() bool {
	return m.clearedspec
}

// SpecIDs returns the "spec" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpecID instead. It exists only for internal usage by the builders.
func (m *ProductSpecRelationMutation) SpecIDs() (ids []uuid.UUID) {
	if id := m.spec; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpec resets all changes to the "spec" edge.
func (m *ProductSpecRelationMutation) ResetSpec() {
	m.spec = nil
	m.clearedspec = false
}

// Where appends a list predicates to the ProductSpecRelationMutation builder.
func (m *ProductSpecRelationMutation) Where(ps ...predicate.ProductSpecRelation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductSpecRelationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductSpecRelationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductSpecRelation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductSpecRelationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductSpecRelationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductSpecRelation).
func (m *ProductSpecRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductSpecRelationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, productspecrelation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productspecrelation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productspecrelation.FieldDeletedAt)
	}
	if m.product != nil {
		fields = append(fields, productspecrelation.FieldProductID)
	}
	if m.spec != nil {
		fields = append(fields, productspecrelation.FieldSpecID)
	}
	if m.base_price != nil {
		fields = append(fields, productspecrelation.FieldBasePrice)
	}
	if m.member_price != nil {
		fields = append(fields, productspecrelation.FieldMemberPrice)
	}
	if m.packing_fee_id != nil {
		fields = append(fields, productspecrelation.FieldPackingFeeID)
	}
	if m.estimated_cost_price != nil {
		fields = append(fields, productspecrelation.FieldEstimatedCostPrice)
	}
	if m.other_price1 != nil {
		fields = append(fields, productspecrelation.FieldOtherPrice1)
	}
	if m.other_price2 != nil {
		fields = append(fields, productspecrelation.FieldOtherPrice2)
	}
	if m.other_price3 != nil {
		fields = append(fields, productspecrelation.FieldOtherPrice3)
	}
	if m.barcode != nil {
		fields = append(fields, productspecrelation.FieldBarcode)
	}
	if m.is_default != nil {
		fields = append(fields, productspecrelation.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductSpecRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productspecrelation.FieldCreatedAt:
		return m.CreatedAt()
	case productspecrelation.FieldUpdatedAt:
		return m.UpdatedAt()
	case productspecrelation.FieldDeletedAt:
		return m.DeletedAt()
	case productspecrelation.FieldProductID:
		return m.ProductID()
	case productspecrelation.FieldSpecID:
		return m.SpecID()
	case productspecrelation.FieldBasePrice:
		return m.BasePrice()
	case productspecrelation.FieldMemberPrice:
		return m.MemberPrice()
	case productspecrelation.FieldPackingFeeID:
		return m.PackingFeeID()
	case productspecrelation.FieldEstimatedCostPrice:
		return m.EstimatedCostPrice()
	case productspecrelation.FieldOtherPrice1:
		return m.OtherPrice1()
	case productspecrelation.FieldOtherPrice2:
		return m.OtherPrice2()
	case productspecrelation.FieldOtherPrice3:
		return m.OtherPrice3()
	case productspecrelation.FieldBarcode:
		return m.Barcode()
	case productspecrelation.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductSpecRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productspecrelation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productspecrelation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productspecrelation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productspecrelation.FieldProductID:
		return m.OldProductID(ctx)
	case productspecrelation.FieldSpecID:
		return m.OldSpecID(ctx)
	case productspecrelation.FieldBasePrice:
		return m.OldBasePrice(ctx)
	case productspecrelation.FieldMemberPrice:
		return m.OldMemberPrice(ctx)
	case productspecrelation.FieldPackingFeeID:
		return m.OldPackingFeeID(ctx)
	case productspecrelation.FieldEstimatedCostPrice:
		return m.OldEstimatedCostPrice(ctx)
	case productspecrelation.FieldOtherPrice1:
		return m.OldOtherPrice1(ctx)
	case productspecrelation.FieldOtherPrice2:
		return m.OldOtherPrice2(ctx)
	case productspecrelation.FieldOtherPrice3:
		return m.OldOtherPrice3(ctx)
	case productspecrelation.FieldBarcode:
		return m.OldBarcode(ctx)
	case productspecrelation.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown ProductSpecRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productspecrelation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productspecrelation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productspecrelation.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productspecrelation.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productspecrelation.FieldSpecID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecID(v)
		return nil
	case productspecrelation.FieldBasePrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePrice(v)
		return nil
	case productspecrelation.FieldMemberPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPrice(v)
		return nil
	case productspecrelation.FieldPackingFeeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackingFeeID(v)
		return nil
	case productspecrelation.FieldEstimatedCostPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCostPrice(v)
		return nil
	case productspecrelation.FieldOtherPrice1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPrice1(v)
		return nil
	case productspecrelation.FieldOtherPrice2:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPrice2(v)
		return nil
	case productspecrelation.FieldOtherPrice3:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPrice3(v)
		return nil
	case productspecrelation.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case productspecrelation.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpecRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductSpecRelationMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productspecrelation.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductSpecRelationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productspecrelation.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductSpecRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productspecrelation.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductSpecRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductSpecRelationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productspecrelation.FieldMemberPrice) {
		fields = append(fields, productspecrelation.FieldMemberPrice)
	}
	if m.FieldCleared(productspecrelation.FieldEstimatedCostPrice) {
		fields = append(fields, productspecrelation.FieldEstimatedCostPrice)
	}
	if m.FieldCleared(productspecrelation.FieldOtherPrice1) {
		fields = append(fields, productspecrelation.FieldOtherPrice1)
	}
	if m.FieldCleared(productspecrelation.FieldOtherPrice2) {
		fields = append(fields, productspecrelation.FieldOtherPrice2)
	}
	if m.FieldCleared(productspecrelation.FieldOtherPrice3) {
		fields = append(fields, productspecrelation.FieldOtherPrice3)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductSpecRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductSpecRelationMutation) ClearField(name string) error {
	switch name {
	case productspecrelation.FieldMemberPrice:
		m.ClearMemberPrice()
		return nil
	case productspecrelation.FieldEstimatedCostPrice:
		m.ClearEstimatedCostPrice()
		return nil
	case productspecrelation.FieldOtherPrice1:
		m.ClearOtherPrice1()
		return nil
	case productspecrelation.FieldOtherPrice2:
		m.ClearOtherPrice2()
		return nil
	case productspecrelation.FieldOtherPrice3:
		m.ClearOtherPrice3()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductSpecRelationMutation) ResetField(name string) error {
	switch name {
	case productspecrelation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productspecrelation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productspecrelation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productspecrelation.FieldProductID:
		m.ResetProductID()
		return nil
	case productspecrelation.FieldSpecID:
		m.ResetSpecID()
		return nil
	case productspecrelation.FieldBasePrice:
		m.ResetBasePrice()
		return nil
	case productspecrelation.FieldMemberPrice:
		m.ResetMemberPrice()
		return nil
	case productspecrelation.FieldPackingFeeID:
		m.ResetPackingFeeID()
		return nil
	case productspecrelation.FieldEstimatedCostPrice:
		m.ResetEstimatedCostPrice()
		return nil
	case productspecrelation.FieldOtherPrice1:
		m.ResetOtherPrice1()
		return nil
	case productspecrelation.FieldOtherPrice2:
		m.ResetOtherPrice2()
		return nil
	case productspecrelation.FieldOtherPrice3:
		m.ResetOtherPrice3()
		return nil
	case productspecrelation.FieldBarcode:
		m.ResetBarcode()
		return nil
	case productspecrelation.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductSpecRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, productspecrelation.EdgeProduct)
	}
	if m.spec != nil {
		edges = append(edges, productspecrelation.EdgeSpec)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductSpecRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productspecrelation.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productspecrelation.EdgeSpec:
		if id := m.spec; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductSpecRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductSpecRelationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductSpecRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, productspecrelation.EdgeProduct)
	}
	if m.clearedspec {
		edges = append(edges, productspecrelation.EdgeSpec)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductSpecRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case productspecrelation.EdgeProduct:
		return m.clearedproduct
	case productspecrelation.EdgeSpec:
		return m.clearedspec
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductSpecRelationMutation) ClearEdge(name string) error {
	switch name {
	case productspecrelation.EdgeProduct:
		m.ClearProduct()
		return nil
	case productspecrelation.EdgeSpec:
		m.ClearSpec()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductSpecRelationMutation) ResetEdge(name string) error {
	switch name {
	case productspecrelation.EdgeProduct:
		m.ResetProduct()
		return nil
	case productspecrelation.EdgeSpec:
		m.ResetSpec()
		return nil
	}
	return fmt.Errorf("unknown ProductSpecRelation edge %s", name)
}

// ProductTagMutation represents an operation that mutates the ProductTag nodes in the graph.
type ProductTagMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	merchant_id      *uuid.UUID
	store_id         *uuid.UUID
	product_count    *int
	addproduct_count *int
	clearedFields    map[string]struct{}
	products         map[uuid.UUID]struct{}
	removedproducts  map[uuid.UUID]struct{}
	clearedproducts  bool
	done             bool
	oldValue         func(context.Context) (*ProductTag, error)
	predicates       []predicate.ProductTag
}

var _ ent.Mutation = (*ProductTagMutation)(nil)

// producttagOption allows management of the mutation configuration using functional options.
type producttagOption func(*ProductTagMutation)

// newProductTagMutation creates new mutation for the ProductTag entity.
func newProductTagMutation(c config, op Op, opts ...producttagOption) *ProductTagMutation {
	m := &ProductTagMutation{
		config:        c,
		op:            op,
		typ:           TypeProductTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductTagID sets the ID field of the mutation.
func withProductTagID(id uuid.UUID) producttagOption {
	return func(m *ProductTagMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductTag
		)
		m.oldValue = func(ctx context.Context) (*ProductTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductTag sets the old ProductTag of the mutation.
func withProductTag(node *ProductTag) producttagOption {
	return func(m *ProductTagMutation) {
		m.oldValue = func(context.Context) (*ProductTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductTag entities.
func (m *ProductTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductTagMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductTagMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductTagMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductTagMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductTagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductTagMutation) ResetName() {
	m.name = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductTagMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductTagMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductTagMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductTagMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductTagMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductTagMutation) ResetStoreID() {
	m.store_id = nil
}

// SetProductCount sets the "product_count" field.
func (m *ProductTagMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductTagMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductTagMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductTagMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductTagMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductTagMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductTagMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductTagMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductTagMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductTagMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductTagMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductTagMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductTagMutation builder.
func (m *ProductTagMutation) Where(ps ...predicate.ProductTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductTag).
func (m *ProductTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductTagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, producttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, producttag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, producttag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, producttag.FieldName)
	}
	if m.merchant_id != nil {
		fields = append(fields, producttag.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, producttag.FieldStoreID)
	}
	if m.product_count != nil {
		fields = append(fields, producttag.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producttag.FieldCreatedAt:
		return m.CreatedAt()
	case producttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case producttag.FieldDeletedAt:
		return m.DeletedAt()
	case producttag.FieldName:
		return m.Name()
	case producttag.FieldMerchantID:
		return m.MerchantID()
	case producttag.FieldStoreID:
		return m.StoreID()
	case producttag.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case producttag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case producttag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case producttag.FieldName:
		return m.OldName(ctx)
	case producttag.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case producttag.FieldStoreID:
		return m.OldStoreID(ctx)
	case producttag.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case producttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case producttag.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case producttag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case producttag.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case producttag.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case producttag.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductTagMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, producttag.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, producttag.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case producttag.FieldDeletedAt:
		return m.AddedDeletedAt()
	case producttag.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case producttag.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case producttag.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductTagMutation) ResetField(name string) error {
	switch name {
	case producttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case producttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case producttag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case producttag.FieldName:
		m.ResetName()
		return nil
	case producttag.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case producttag.FieldStoreID:
		m.ResetStoreID()
		return nil
	case producttag.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, producttag.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producttag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, producttag.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case producttag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, producttag.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductTagMutation) EdgeCleared(name string) bool {
	switch name {
	case producttag.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductTagMutation) ResetEdge(name string) error {
	switch name {
	case producttag.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductTag edge %s", name)
}

// ProductUnitMutation represents an operation that mutates the ProductUnit nodes in the graph.
type ProductUnitMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	_type            *domain.ProductUnitType
	merchant_id      *uuid.UUID
	store_id         *uuid.UUID
	product_count    *int
	addproduct_count *int
	clearedFields    map[string]struct{}
	products         map[uuid.UUID]struct{}
	removedproducts  map[uuid.UUID]struct{}
	clearedproducts  bool
	done             bool
	oldValue         func(context.Context) (*ProductUnit, error)
	predicates       []predicate.ProductUnit
}

var _ ent.Mutation = (*ProductUnitMutation)(nil)

// productunitOption allows management of the mutation configuration using functional options.
type productunitOption func(*ProductUnitMutation)

// newProductUnitMutation creates new mutation for the ProductUnit entity.
func newProductUnitMutation(c config, op Op, opts ...productunitOption) *ProductUnitMutation {
	m := &ProductUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeProductUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductUnitID sets the ID field of the mutation.
func withProductUnitID(id uuid.UUID) productunitOption {
	return func(m *ProductUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductUnit
		)
		m.oldValue = func(ctx context.Context) (*ProductUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductUnit sets the old ProductUnit of the mutation.
func withProductUnit(node *ProductUnit) productunitOption {
	return func(m *ProductUnitMutation) {
		m.oldValue = func(context.Context) (*ProductUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductUnit entities.
func (m *ProductUnitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductUnitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductUnitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductUnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductUnitMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductUnitMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProductUnitMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProductUnitMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductUnitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProductUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductUnitMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ProductUnitMutation) SetType(dut domain.ProductUnitType) {
	m._type = &dut
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductUnitMutation) GetType() (r domain.ProductUnitType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldType(ctx context.Context) (v domain.ProductUnitType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProductUnitMutation) ResetType() {
	m._type = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProductUnitMutation) SetMerchantID(u uuid.UUID) {
	m.merchant_id = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProductUnitMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProductUnitMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetStoreID sets the "store_id" field.
func (m *ProductUnitMutation) SetStoreID(u uuid.UUID) {
	m.store_id = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductUnitMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductUnitMutation) ResetStoreID() {
	m.store_id = nil
}

// SetProductCount sets the "product_count" field.
func (m *ProductUnitMutation) SetProductCount(i int) {
	m.product_count = &i
	m.addproduct_count = nil
}

// ProductCount returns the value of the "product_count" field in the mutation.
func (m *ProductUnitMutation) ProductCount() (r int, exists bool) {
	v := m.product_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCount returns the old "product_count" field's value of the ProductUnit entity.
// If the ProductUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductUnitMutation) OldProductCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCount: %w", err)
	}
	return oldValue.ProductCount, nil
}

// AddProductCount adds i to the "product_count" field.
func (m *ProductUnitMutation) AddProductCount(i int) {
	if m.addproduct_count != nil {
		*m.addproduct_count += i
	} else {
		m.addproduct_count = &i
	}
}

// AddedProductCount returns the value that was added to the "product_count" field in this mutation.
func (m *ProductUnitMutation) AddedProductCount() (r int, exists bool) {
	v := m.addproduct_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductCount resets all changes to the "product_count" field.
func (m *ProductUnitMutation) ResetProductCount() {
	m.product_count = nil
	m.addproduct_count = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductUnitMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductUnitMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductUnitMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductUnitMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductUnitMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductUnitMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductUnitMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductUnitMutation builder.
func (m *ProductUnitMutation) Where(ps ...predicate.ProductUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductUnit).
func (m *ProductUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductUnitMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, productunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productunit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productunit.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, productunit.FieldName)
	}
	if m._type != nil {
		fields = append(fields, productunit.FieldType)
	}
	if m.merchant_id != nil {
		fields = append(fields, productunit.FieldMerchantID)
	}
	if m.store_id != nil {
		fields = append(fields, productunit.FieldStoreID)
	}
	if m.product_count != nil {
		fields = append(fields, productunit.FieldProductCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productunit.FieldCreatedAt:
		return m.CreatedAt()
	case productunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case productunit.FieldDeletedAt:
		return m.DeletedAt()
	case productunit.FieldName:
		return m.Name()
	case productunit.FieldType:
		return m.GetType()
	case productunit.FieldMerchantID:
		return m.MerchantID()
	case productunit.FieldStoreID:
		return m.StoreID()
	case productunit.FieldProductCount:
		return m.ProductCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productunit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productunit.FieldName:
		return m.OldName(ctx)
	case productunit.FieldType:
		return m.OldType(ctx)
	case productunit.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case productunit.FieldStoreID:
		return m.OldStoreID(ctx)
	case productunit.FieldProductCount:
		return m.OldProductCount(ctx)
	}
	return nil, fmt.Errorf("unknown ProductUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productunit.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productunit.FieldType:
		v, ok := value.(domain.ProductUnitType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case productunit.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case productunit.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case productunit.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductUnitMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, productunit.FieldDeletedAt)
	}
	if m.addproduct_count != nil {
		fields = append(fields, productunit.FieldProductCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productunit.FieldDeletedAt:
		return m.AddedDeletedAt()
	case productunit.FieldProductCount:
		return m.AddedProductCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productunit.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case productunit.FieldProductCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCount(v)
		return nil
	}
	return fmt.Errorf("unknown ProductUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductUnitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductUnitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductUnitMutation) ResetField(name string) error {
	switch name {
	case productunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productunit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productunit.FieldName:
		m.ResetName()
		return nil
	case productunit.FieldType:
		m.ResetType()
		return nil
	case productunit.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case productunit.FieldStoreID:
		m.ResetStoreID()
		return nil
	case productunit.FieldProductCount:
		m.ResetProductCount()
		return nil
	}
	return fmt.Errorf("unknown ProductUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, productunit.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productunit.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, productunit.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productunit.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, productunit.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case productunit.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductUnitMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductUnitMutation) ResetEdge(name string) error {
	switch name {
	case productunit.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductUnit edge %s", name)
}

// ProvinceMutation represents an operation that mutates the Province nodes in the graph.
type ProvinceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *int64
	adddeleted_at    *int64
	name             *string
	sort             *int
	addsort          *int
	clearedFields    map[string]struct{}
	country          *uuid.UUID
	clearedcountry   bool
	cities           map[uuid.UUID]struct{}
	removedcities    map[uuid.UUID]struct{}
	clearedcities    bool
	districts        map[uuid.UUID]struct{}
	removeddistricts map[uuid.UUID]struct{}
	cleareddistricts bool
	merchants        map[uuid.UUID]struct{}
	removedmerchants map[uuid.UUID]struct{}
	clearedmerchants bool
	stores           map[uuid.UUID]struct{}
	removedstores    map[uuid.UUID]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*Province, error)
	predicates       []predicate.Province
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows management of the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for the Province entity.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the ID field of the mutation.
func withProvinceID(id uuid.UUID) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Province entities.
func (m *ProvinceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvinceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvinceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Province.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProvinceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProvinceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProvinceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProvinceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProvinceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProvinceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProvinceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProvinceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProvinceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProvinceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProvinceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCountryID sets the "country_id" field.
func (m *ProvinceMutation) SetCountryID(u uuid.UUID) {
	m.country = &u
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *ProvinceMutation) CountryID() (r uuid.UUID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCountryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *ProvinceMutation) ResetCountryID() {
	m.country = nil
}

// SetName sets the "name" field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *ProvinceMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ProvinceMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ProvinceMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ProvinceMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ProvinceMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ProvinceMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[province.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ProvinceMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ProvinceMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *ProvinceMutation) AddCityIDs(ids ...uuid.UUID) {
	if m.cities == nil {
		m.cities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *ProvinceMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *ProvinceMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *ProvinceMutation) RemoveCityIDs(ids ...uuid.UUID) {
	if m.removedcities == nil {
		m.removedcities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *ProvinceMutation) RemovedCitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *ProvinceMutation) CitiesIDs() (ids []uuid.UUID) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *ProvinceMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *ProvinceMutation) AddDistrictIDs(ids ...uuid.UUID) {
	if m.districts == nil {
		m.districts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *ProvinceMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *ProvinceMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *ProvinceMutation) RemoveDistrictIDs(ids ...uuid.UUID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *ProvinceMutation) RemovedDistrictsIDs() (ids []uuid.UUID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *ProvinceMutation) DistrictsIDs() (ids []uuid.UUID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *ProvinceMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// AddMerchantIDs adds the "merchants" edge to the Merchant entity by ids.
func (m *ProvinceMutation) AddMerchantIDs(ids ...uuid.UUID) {
	if m.merchants == nil {
		m.merchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.merchants[ids[i]] = struct{}{}
	}
}

// ClearMerchants clears the "merchants" edge to the Merchant entity.
func (m *ProvinceMutation) ClearMerchants() {
	m.clearedmerchants = true
}

// MerchantsCleared reports if the "merchants" edge to the Merchant entity was cleared.
func (m *ProvinceMutation) MerchantsCleared() bool {
	return m.clearedmerchants
}

// RemoveMerchantIDs removes the "merchants" edge to the Merchant entity by IDs.
func (m *ProvinceMutation) RemoveMerchantIDs(ids ...uuid.UUID) {
	if m.removedmerchants == nil {
		m.removedmerchants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.merchants, ids[i])
		m.removedmerchants[ids[i]] = struct{}{}
	}
}

// RemovedMerchants returns the removed IDs of the "merchants" edge to the Merchant entity.
func (m *ProvinceMutation) RemovedMerchantsIDs() (ids []uuid.UUID) {
	for id := range m.removedmerchants {
		ids = append(ids, id)
	}
	return
}

// MerchantsIDs returns the "merchants" edge IDs in the mutation.
func (m *ProvinceMutation) MerchantsIDs() (ids []uuid.UUID) {
	for id := range m.merchants {
		ids = append(ids, id)
	}
	return
}

// ResetMerchants resets all changes to the "merchants" edge.
func (m *ProvinceMutation) ResetMerchants() {
	m.merchants = nil
	m.clearedmerchants = false
	m.removedmerchants = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *ProvinceMutation) AddStoreIDs(ids ...uuid.UUID) {
	if m.stores == nil {
		m.stores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *ProvinceMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *ProvinceMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *ProvinceMutation) RemoveStoreIDs(ids ...uuid.UUID) {
	if m.removedstores == nil {
		m.removedstores = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *ProvinceMutation) RemovedStoresIDs() (ids []uuid.UUID) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *ProvinceMutation) StoresIDs() (ids []uuid.UUID) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *ProvinceMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the ProvinceMutation builder.
func (m *ProvinceMutation) Where(ps ...predicate.Province) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvinceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvinceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Province, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvinceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, province.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, province.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, province.FieldDeletedAt)
	}
	if m.country != nil {
		fields = append(fields, province.FieldCountryID)
	}
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, province.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldCreatedAt:
		return m.CreatedAt()
	case province.FieldUpdatedAt:
		return m.UpdatedAt()
	case province.FieldDeletedAt:
		return m.DeletedAt()
	case province.FieldCountryID:
		return m.CountryID()
	case province.FieldName:
		return m.Name()
	case province.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case province.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case province.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case province.FieldCountryID:
		return m.OldCountryID(ctx)
	case province.FieldName:
		return m.OldName(ctx)
	case province.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case province.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case province.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case province.FieldCountryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case province.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, province.FieldDeletedAt)
	}
	if m.addsort != nil {
		fields = append(fields, province.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case province.FieldDeletedAt:
		return m.AddedDeletedAt()
	case province.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case province.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case province.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case province.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case province.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case province.FieldCountryID:
		m.ResetCountryID()
		return nil
	case province.FieldName:
		m.ResetName()
		return nil
	case province.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.country != nil {
		edges = append(edges, province.EdgeCountry)
	}
	if m.cities != nil {
		edges = append(edges, province.EdgeCities)
	}
	if m.districts != nil {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.merchants != nil {
		edges = append(edges, province.EdgeMerchants)
	}
	if m.stores != nil {
		edges = append(edges, province.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.merchants))
		for id := range m.merchants {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcities != nil {
		edges = append(edges, province.EdgeCities)
	}
	if m.removeddistricts != nil {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.removedmerchants != nil {
		edges = append(edges, province.EdgeMerchants)
	}
	if m.removedstores != nil {
		edges = append(edges, province.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeMerchants:
		ids := make([]ent.Value, 0, len(m.removedmerchants))
		for id := range m.removedmerchants {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcountry {
		edges = append(edges, province.EdgeCountry)
	}
	if m.clearedcities {
		edges = append(edges, province.EdgeCities)
	}
	if m.cleareddistricts {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.clearedmerchants {
		edges = append(edges, province.EdgeMerchants)
	}
	if m.clearedstores {
		edges = append(edges, province.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgeCountry:
		return m.clearedcountry
	case province.EdgeCities:
		return m.clearedcities
	case province.EdgeDistricts:
		return m.cleareddistricts
	case province.EdgeMerchants:
		return m.clearedmerchants
	case province.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	case province.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgeCountry:
		m.ResetCountry()
		return nil
	case province.EdgeCities:
		m.ResetCities()
		return nil
	case province.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case province.EdgeMerchants:
		m.ResetMerchants()
		return nil
	case province.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// RemarkMutation represents an operation that mutates the Remark nodes in the graph.
type RemarkMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *int64
	adddeleted_at          *int64
	name                   *string
	remark_type            *domain.RemarkType
	enabled                *bool
	sort_order             *int
	addsort_order          *int
	clearedFields          map[string]struct{}
	remark_category        *uuid.UUID
	clearedremark_category bool
	merchant               *uuid.UUID
	clearedmerchant        bool
	store                  *uuid.UUID
	clearedstore           bool
	done                   bool
	oldValue               func(context.Context) (*Remark, error)
	predicates             []predicate.Remark
}

var _ ent.Mutation = (*RemarkMutation)(nil)

// remarkOption allows management of the mutation configuration using functional options.
type remarkOption func(*RemarkMutation)

// newRemarkMutation creates new mutation for the Remark entity.
func newRemarkMutation(c config, op Op, opts ...remarkOption) *RemarkMutation {
	m := &RemarkMutation{
		config:        c,
		op:            op,
		typ:           TypeRemark,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemarkID sets the ID field of the mutation.
func withRemarkID(id uuid.UUID) remarkOption {
	return func(m *RemarkMutation) {
		var (
			err   error
			once  sync.Once
			value *Remark
		)
		m.oldValue = func(ctx context.Context) (*Remark, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Remark.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemark sets the old Remark of the mutation.
func withRemark(node *Remark) remarkOption {
	return func(m *RemarkMutation) {
		m.oldValue = func(context.Context) (*Remark, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemarkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemarkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Remark entities.
func (m *RemarkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemarkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemarkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Remark.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RemarkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RemarkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RemarkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RemarkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RemarkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RemarkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RemarkMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RemarkMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RemarkMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RemarkMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RemarkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RemarkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RemarkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RemarkMutation) ResetName() {
	m.name = nil
}

// SetRemarkType sets the "remark_type" field.
func (m *RemarkMutation) SetRemarkType(dt domain.RemarkType) {
	m.remark_type = &dt
}

// RemarkType returns the value of the "remark_type" field in the mutation.
func (m *RemarkMutation) RemarkType() (r domain.RemarkType, exists bool) {
	v := m.remark_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarkType returns the old "remark_type" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldRemarkType(ctx context.Context) (v domain.RemarkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarkType: %w", err)
	}
	return oldValue.RemarkType, nil
}

// ResetRemarkType resets all changes to the "remark_type" field.
func (m *RemarkMutation) ResetRemarkType() {
	m.remark_type = nil
}

// SetEnabled sets the "enabled" field.
func (m *RemarkMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *RemarkMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *RemarkMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *RemarkMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *RemarkMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *RemarkMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *RemarkMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *RemarkMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCategoryID sets the "category_id" field.
func (m *RemarkMutation) SetCategoryID(u uuid.UUID) {
	m.remark_category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *RemarkMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.remark_category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *RemarkMutation) ResetCategoryID() {
	m.remark_category = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *RemarkMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *RemarkMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *RemarkMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[remark.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *RemarkMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[remark.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *RemarkMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, remark.FieldMerchantID)
}

// SetStoreID sets the "store_id" field.
func (m *RemarkMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *RemarkMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Remark entity.
// If the Remark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *RemarkMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[remark.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *RemarkMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[remark.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *RemarkMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, remark.FieldStoreID)
}

// SetRemarkCategoryID sets the "remark_category" edge to the RemarkCategory entity by id.
func (m *RemarkMutation) SetRemarkCategoryID(id uuid.UUID) {
	m.remark_category = &id
}

// ClearRemarkCategory clears the "remark_category" edge to the RemarkCategory entity.
func (m *RemarkMutation) ClearRemarkCategory() {
	m.clearedremark_category = true
	m.clearedFields[remark.FieldCategoryID] = struct{}{}
}

// RemarkCategoryCleared reports if the "remark_category" edge to the RemarkCategory entity was cleared.
func (m *RemarkMutation) RemarkCategoryCleared() bool {
	return m.clearedremark_category
}

// RemarkCategoryID returns the "remark_category" edge ID in the mutation.
func (m *RemarkMutation) RemarkCategoryID() (id uuid.UUID, exists bool) {
	if m.remark_category != nil {
		return *m.remark_category, true
	}
	return
}

// RemarkCategoryIDs returns the "remark_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RemarkCategoryID instead. It exists only for internal usage by the builders.
func (m *RemarkMutation) RemarkCategoryIDs() (ids []uuid.UUID) {
	if id := m.remark_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRemarkCategory resets all changes to the "remark_category" edge.
func (m *RemarkMutation) ResetRemarkCategory() {
	m.remark_category = nil
	m.clearedremark_category = false
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *RemarkMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[remark.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *RemarkMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *RemarkMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *RemarkMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *RemarkMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[remark.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *RemarkMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *RemarkMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *RemarkMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the RemarkMutation builder.
func (m *RemarkMutation) Where(ps ...predicate.Remark) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RemarkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RemarkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Remark, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RemarkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RemarkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Remark).
func (m *RemarkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemarkMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, remark.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, remark.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, remark.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, remark.FieldName)
	}
	if m.remark_type != nil {
		fields = append(fields, remark.FieldRemarkType)
	}
	if m.enabled != nil {
		fields = append(fields, remark.FieldEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, remark.FieldSortOrder)
	}
	if m.remark_category != nil {
		fields = append(fields, remark.FieldCategoryID)
	}
	if m.merchant != nil {
		fields = append(fields, remark.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, remark.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemarkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remark.FieldCreatedAt:
		return m.CreatedAt()
	case remark.FieldUpdatedAt:
		return m.UpdatedAt()
	case remark.FieldDeletedAt:
		return m.DeletedAt()
	case remark.FieldName:
		return m.Name()
	case remark.FieldRemarkType:
		return m.RemarkType()
	case remark.FieldEnabled:
		return m.Enabled()
	case remark.FieldSortOrder:
		return m.SortOrder()
	case remark.FieldCategoryID:
		return m.CategoryID()
	case remark.FieldMerchantID:
		return m.MerchantID()
	case remark.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemarkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remark.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case remark.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case remark.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case remark.FieldName:
		return m.OldName(ctx)
	case remark.FieldRemarkType:
		return m.OldRemarkType(ctx)
	case remark.FieldEnabled:
		return m.OldEnabled(ctx)
	case remark.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case remark.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case remark.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case remark.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Remark field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemarkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remark.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case remark.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case remark.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case remark.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case remark.FieldRemarkType:
		v, ok := value.(domain.RemarkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarkType(v)
		return nil
	case remark.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case remark.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case remark.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case remark.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case remark.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Remark field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemarkMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, remark.FieldDeletedAt)
	}
	if m.addsort_order != nil {
		fields = append(fields, remark.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemarkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case remark.FieldDeletedAt:
		return m.AddedDeletedAt()
	case remark.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemarkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case remark.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case remark.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Remark numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemarkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(remark.FieldMerchantID) {
		fields = append(fields, remark.FieldMerchantID)
	}
	if m.FieldCleared(remark.FieldStoreID) {
		fields = append(fields, remark.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemarkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemarkMutation) ClearField(name string) error {
	switch name {
	case remark.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case remark.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown Remark nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemarkMutation) ResetField(name string) error {
	switch name {
	case remark.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case remark.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case remark.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case remark.FieldName:
		m.ResetName()
		return nil
	case remark.FieldRemarkType:
		m.ResetRemarkType()
		return nil
	case remark.FieldEnabled:
		m.ResetEnabled()
		return nil
	case remark.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case remark.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case remark.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case remark.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Remark field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemarkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.remark_category != nil {
		edges = append(edges, remark.EdgeRemarkCategory)
	}
	if m.merchant != nil {
		edges = append(edges, remark.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, remark.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemarkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case remark.EdgeRemarkCategory:
		if id := m.remark_category; id != nil {
			return []ent.Value{*id}
		}
	case remark.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case remark.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemarkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemarkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemarkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedremark_category {
		edges = append(edges, remark.EdgeRemarkCategory)
	}
	if m.clearedmerchant {
		edges = append(edges, remark.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, remark.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemarkMutation) EdgeCleared(name string) bool {
	switch name {
	case remark.EdgeRemarkCategory:
		return m.clearedremark_category
	case remark.EdgeMerchant:
		return m.clearedmerchant
	case remark.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemarkMutation) ClearEdge(name string) error {
	switch name {
	case remark.EdgeRemarkCategory:
		m.ClearRemarkCategory()
		return nil
	case remark.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case remark.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Remark unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemarkMutation) ResetEdge(name string) error {
	switch name {
	case remark.EdgeRemarkCategory:
		m.ResetRemarkCategory()
		return nil
	case remark.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case remark.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown Remark edge %s", name)
}

// RemarkCategoryMutation represents an operation that mutates the RemarkCategory nodes in the graph.
type RemarkCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	remark_scene    *domain.RemarkScene
	description     *string
	sort_order      *int
	addsort_order   *int
	clearedFields   map[string]struct{}
	remarks         map[uuid.UUID]struct{}
	removedremarks  map[uuid.UUID]struct{}
	clearedremarks  bool
	merchant        *uuid.UUID
	clearedmerchant bool
	done            bool
	oldValue        func(context.Context) (*RemarkCategory, error)
	predicates      []predicate.RemarkCategory
}

var _ ent.Mutation = (*RemarkCategoryMutation)(nil)

// remarkcategoryOption allows management of the mutation configuration using functional options.
type remarkcategoryOption func(*RemarkCategoryMutation)

// newRemarkCategoryMutation creates new mutation for the RemarkCategory entity.
func newRemarkCategoryMutation(c config, op Op, opts ...remarkcategoryOption) *RemarkCategoryMutation {
	m := &RemarkCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRemarkCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemarkCategoryID sets the ID field of the mutation.
func withRemarkCategoryID(id uuid.UUID) remarkcategoryOption {
	return func(m *RemarkCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RemarkCategory
		)
		m.oldValue = func(ctx context.Context) (*RemarkCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RemarkCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemarkCategory sets the old RemarkCategory of the mutation.
func withRemarkCategory(node *RemarkCategory) remarkcategoryOption {
	return func(m *RemarkCategoryMutation) {
		m.oldValue = func(context.Context) (*RemarkCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemarkCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemarkCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RemarkCategory entities.
func (m *RemarkCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemarkCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemarkCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RemarkCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RemarkCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RemarkCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RemarkCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RemarkCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RemarkCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RemarkCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RemarkCategoryMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RemarkCategoryMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RemarkCategoryMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RemarkCategoryMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RemarkCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RemarkCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RemarkCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RemarkCategoryMutation) ResetName() {
	m.name = nil
}

// SetRemarkScene sets the "remark_scene" field.
func (m *RemarkCategoryMutation) SetRemarkScene(ds domain.RemarkScene) {
	m.remark_scene = &ds
}

// RemarkScene returns the value of the "remark_scene" field in the mutation.
func (m *RemarkCategoryMutation) RemarkScene() (r domain.RemarkScene, exists bool) {
	v := m.remark_scene
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarkScene returns the old "remark_scene" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldRemarkScene(ctx context.Context) (v domain.RemarkScene, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarkScene is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarkScene requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarkScene: %w", err)
	}
	return oldValue.RemarkScene, nil
}

// ResetRemarkScene resets all changes to the "remark_scene" field.
func (m *RemarkCategoryMutation) ResetRemarkScene() {
	m.remark_scene = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *RemarkCategoryMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *RemarkCategoryMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *RemarkCategoryMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[remarkcategory.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *RemarkCategoryMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[remarkcategory.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *RemarkCategoryMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, remarkcategory.FieldMerchantID)
}

// SetDescription sets the "description" field.
func (m *RemarkCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RemarkCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RemarkCategoryMutation) ResetDescription() {
	m.description = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *RemarkCategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *RemarkCategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the RemarkCategory entity.
// If the RemarkCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemarkCategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *RemarkCategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *RemarkCategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *RemarkCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddRemarkIDs adds the "remarks" edge to the Remark entity by ids.
func (m *RemarkCategoryMutation) AddRemarkIDs(ids ...uuid.UUID) {
	if m.remarks == nil {
		m.remarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.remarks[ids[i]] = struct{}{}
	}
}

// ClearRemarks clears the "remarks" edge to the Remark entity.
func (m *RemarkCategoryMutation) ClearRemarks() {
	m.clearedremarks = true
}

// RemarksCleared reports if the "remarks" edge to the Remark entity was cleared.
func (m *RemarkCategoryMutation) RemarksCleared() bool {
	return m.clearedremarks
}

// RemoveRemarkIDs removes the "remarks" edge to the Remark entity by IDs.
func (m *RemarkCategoryMutation) RemoveRemarkIDs(ids ...uuid.UUID) {
	if m.removedremarks == nil {
		m.removedremarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.remarks, ids[i])
		m.removedremarks[ids[i]] = struct{}{}
	}
}

// RemovedRemarks returns the removed IDs of the "remarks" edge to the Remark entity.
func (m *RemarkCategoryMutation) RemovedRemarksIDs() (ids []uuid.UUID) {
	for id := range m.removedremarks {
		ids = append(ids, id)
	}
	return
}

// RemarksIDs returns the "remarks" edge IDs in the mutation.
func (m *RemarkCategoryMutation) RemarksIDs() (ids []uuid.UUID) {
	for id := range m.remarks {
		ids = append(ids, id)
	}
	return
}

// ResetRemarks resets all changes to the "remarks" edge.
func (m *RemarkCategoryMutation) ResetRemarks() {
	m.remarks = nil
	m.clearedremarks = false
	m.removedremarks = nil
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *RemarkCategoryMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[remarkcategory.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *RemarkCategoryMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *RemarkCategoryMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *RemarkCategoryMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the RemarkCategoryMutation builder.
func (m *RemarkCategoryMutation) Where(ps ...predicate.RemarkCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RemarkCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RemarkCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RemarkCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RemarkCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RemarkCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RemarkCategory).
func (m *RemarkCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemarkCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, remarkcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, remarkcategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, remarkcategory.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, remarkcategory.FieldName)
	}
	if m.remark_scene != nil {
		fields = append(fields, remarkcategory.FieldRemarkScene)
	}
	if m.merchant != nil {
		fields = append(fields, remarkcategory.FieldMerchantID)
	}
	if m.description != nil {
		fields = append(fields, remarkcategory.FieldDescription)
	}
	if m.sort_order != nil {
		fields = append(fields, remarkcategory.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemarkCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remarkcategory.FieldCreatedAt:
		return m.CreatedAt()
	case remarkcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case remarkcategory.FieldDeletedAt:
		return m.DeletedAt()
	case remarkcategory.FieldName:
		return m.Name()
	case remarkcategory.FieldRemarkScene:
		return m.RemarkScene()
	case remarkcategory.FieldMerchantID:
		return m.MerchantID()
	case remarkcategory.FieldDescription:
		return m.Description()
	case remarkcategory.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemarkCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remarkcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case remarkcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case remarkcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case remarkcategory.FieldName:
		return m.OldName(ctx)
	case remarkcategory.FieldRemarkScene:
		return m.OldRemarkScene(ctx)
	case remarkcategory.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case remarkcategory.FieldDescription:
		return m.OldDescription(ctx)
	case remarkcategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown RemarkCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemarkCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remarkcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case remarkcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case remarkcategory.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case remarkcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case remarkcategory.FieldRemarkScene:
		v, ok := value.(domain.RemarkScene)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarkScene(v)
		return nil
	case remarkcategory.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case remarkcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case remarkcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown RemarkCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemarkCategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, remarkcategory.FieldDeletedAt)
	}
	if m.addsort_order != nil {
		fields = append(fields, remarkcategory.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemarkCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case remarkcategory.FieldDeletedAt:
		return m.AddedDeletedAt()
	case remarkcategory.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemarkCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case remarkcategory.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case remarkcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown RemarkCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemarkCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(remarkcategory.FieldMerchantID) {
		fields = append(fields, remarkcategory.FieldMerchantID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemarkCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemarkCategoryMutation) ClearField(name string) error {
	switch name {
	case remarkcategory.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	}
	return fmt.Errorf("unknown RemarkCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemarkCategoryMutation) ResetField(name string) error {
	switch name {
	case remarkcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case remarkcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case remarkcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case remarkcategory.FieldName:
		m.ResetName()
		return nil
	case remarkcategory.FieldRemarkScene:
		m.ResetRemarkScene()
		return nil
	case remarkcategory.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case remarkcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case remarkcategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown RemarkCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemarkCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.remarks != nil {
		edges = append(edges, remarkcategory.EdgeRemarks)
	}
	if m.merchant != nil {
		edges = append(edges, remarkcategory.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemarkCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case remarkcategory.EdgeRemarks:
		ids := make([]ent.Value, 0, len(m.remarks))
		for id := range m.remarks {
			ids = append(ids, id)
		}
		return ids
	case remarkcategory.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemarkCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedremarks != nil {
		edges = append(edges, remarkcategory.EdgeRemarks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemarkCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case remarkcategory.EdgeRemarks:
		ids := make([]ent.Value, 0, len(m.removedremarks))
		for id := range m.removedremarks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemarkCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedremarks {
		edges = append(edges, remarkcategory.EdgeRemarks)
	}
	if m.clearedmerchant {
		edges = append(edges, remarkcategory.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemarkCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case remarkcategory.EdgeRemarks:
		return m.clearedremarks
	case remarkcategory.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemarkCategoryMutation) ClearEdge(name string) error {
	switch name {
	case remarkcategory.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown RemarkCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemarkCategoryMutation) ResetEdge(name string) error {
	switch name {
	case remarkcategory.EdgeRemarks:
		m.ResetRemarks()
		return nil
	case remarkcategory.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown RemarkCategory edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	code            *string
	role_type       *domain.RoleType
	enable          *bool
	clearedFields   map[string]struct{}
	merchant        *uuid.UUID
	clearedmerchant bool
	store           *uuid.UUID
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*Role, error)
	predicates      []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RoleMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RoleMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
}

// SetRoleType sets the "role_type" field.
func (m *RoleMutation) SetRoleType(dt domain.RoleType) {
	m.role_type = &dt
}

// RoleType returns the value of the "role_type" field in the mutation.
func (m *RoleMutation) RoleType() (r domain.RoleType, exists bool) {
	v := m.role_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleType returns the old "role_type" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleType(ctx context.Context) (v domain.RoleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleType: %w", err)
	}
	return oldValue.RoleType, nil
}

// ResetRoleType resets all changes to the "role_type" field.
func (m *RoleMutation) ResetRoleType() {
	m.role_type = nil
}

// SetEnable sets the "enable" field.
func (m *RoleMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *RoleMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *RoleMutation) ResetEnable() {
	m.enable = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *RoleMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *RoleMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *RoleMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[role.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *RoleMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[role.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *RoleMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, role.FieldMerchantID)
}

// SetStoreID sets the "store_id" field.
func (m *RoleMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *RoleMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *RoleMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[role.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *RoleMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[role.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *RoleMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, role.FieldStoreID)
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *RoleMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[role.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *RoleMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *RoleMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *RoleMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[role.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *RoleMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *RoleMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	if m.role_type != nil {
		fields = append(fields, role.FieldRoleType)
	}
	if m.enable != nil {
		fields = append(fields, role.FieldEnable)
	}
	if m.merchant != nil {
		fields = append(fields, role.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, role.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldCode:
		return m.Code()
	case role.FieldRoleType:
		return m.RoleType()
	case role.FieldEnable:
		return m.Enable()
	case role.FieldMerchantID:
		return m.MerchantID()
	case role.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	case role.FieldRoleType:
		return m.OldRoleType(ctx)
	case role.FieldEnable:
		return m.OldEnable(ctx)
	case role.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case role.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case role.FieldRoleType:
		v, ok := value.(domain.RoleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleType(v)
		return nil
	case role.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case role.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case role.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldMerchantID) {
		fields = append(fields, role.FieldMerchantID)
	}
	if m.FieldCleared(role.FieldStoreID) {
		fields = append(fields, role.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case role.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	case role.FieldRoleType:
		m.ResetRoleType()
		return nil
	case role.FieldEnable:
		m.ResetEnable()
		return nil
	case role.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case role.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.merchant != nil {
		edges = append(edges, role.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, role.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmerchant {
		edges = append(edges, role.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, role.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMerchant:
		return m.clearedmerchant
	case role.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case role.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case role.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SetMealDetailMutation represents an operation that mutates the SetMealDetail nodes in the graph.
type SetMealDetailMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *int64
	adddeleted_at              *int64
	quantity                   *int
	addquantity                *int
	is_default                 *bool
	optional_product_ids       *[]uuid.UUID
	appendoptional_product_ids []uuid.UUID
	clearedFields              map[string]struct{}
	group                      *uuid.UUID
	clearedgroup               bool
	product                    *uuid.UUID
	clearedproduct             bool
	done                       bool
	oldValue                   func(context.Context) (*SetMealDetail, error)
	predicates                 []predicate.SetMealDetail
}

var _ ent.Mutation = (*SetMealDetailMutation)(nil)

// setmealdetailOption allows management of the mutation configuration using functional options.
type setmealdetailOption func(*SetMealDetailMutation)

// newSetMealDetailMutation creates new mutation for the SetMealDetail entity.
func newSetMealDetailMutation(c config, op Op, opts ...setmealdetailOption) *SetMealDetailMutation {
	m := &SetMealDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeSetMealDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetMealDetailID sets the ID field of the mutation.
func withSetMealDetailID(id uuid.UUID) setmealdetailOption {
	return func(m *SetMealDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *SetMealDetail
		)
		m.oldValue = func(ctx context.Context) (*SetMealDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SetMealDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetMealDetail sets the old SetMealDetail of the mutation.
func withSetMealDetail(node *SetMealDetail) setmealdetailOption {
	return func(m *SetMealDetailMutation) {
		m.oldValue = func(context.Context) (*SetMealDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMealDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMealDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SetMealDetail entities.
func (m *SetMealDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMealDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMealDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SetMealDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SetMealDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SetMealDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SetMealDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SetMealDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SetMealDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SetMealDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SetMealDetailMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SetMealDetailMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SetMealDetailMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SetMealDetailMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SetMealDetailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGroupID sets the "group_id" field.
func (m *SetMealDetailMutation) SetGroupID(u uuid.UUID) {
	m.group = &u
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *SetMealDetailMutation) GroupID() (r uuid.UUID, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *SetMealDetailMutation) ResetGroupID() {
	m.group = nil
}

// SetProductID sets the "product_id" field.
func (m *SetMealDetailMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *SetMealDetailMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *SetMealDetailMutation) ResetProductID() {
	m.product = nil
}

// SetQuantity sets the "quantity" field.
func (m *SetMealDetailMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *SetMealDetailMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *SetMealDetailMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *SetMealDetailMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *SetMealDetailMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetIsDefault sets the "is_default" field.
func (m *SetMealDetailMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *SetMealDetailMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *SetMealDetailMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetOptionalProductIds sets the "optional_product_ids" field.
func (m *SetMealDetailMutation) SetOptionalProductIds(u []uuid.UUID) {
	m.optional_product_ids = &u
	m.appendoptional_product_ids = nil
}

// OptionalProductIds returns the value of the "optional_product_ids" field in the mutation.
func (m *SetMealDetailMutation) OptionalProductIds() (r []uuid.UUID, exists bool) {
	v := m.optional_product_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionalProductIds returns the old "optional_product_ids" field's value of the SetMealDetail entity.
// If the SetMealDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealDetailMutation) OldOptionalProductIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionalProductIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionalProductIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionalProductIds: %w", err)
	}
	return oldValue.OptionalProductIds, nil
}

// AppendOptionalProductIds adds u to the "optional_product_ids" field.
func (m *SetMealDetailMutation) AppendOptionalProductIds(u []uuid.UUID) {
	m.appendoptional_product_ids = append(m.appendoptional_product_ids, u...)
}

// AppendedOptionalProductIds returns the list of values that were appended to the "optional_product_ids" field in this mutation.
func (m *SetMealDetailMutation) AppendedOptionalProductIds() ([]uuid.UUID, bool) {
	if len(m.appendoptional_product_ids) == 0 {
		return nil, false
	}
	return m.appendoptional_product_ids, true
}

// ClearOptionalProductIds clears the value of the "optional_product_ids" field.
func (m *SetMealDetailMutation) ClearOptionalProductIds() {
	m.optional_product_ids = nil
	m.appendoptional_product_ids = nil
	m.clearedFields[setmealdetail.FieldOptionalProductIds] = struct{}{}
}

// OptionalProductIdsCleared returns if the "optional_product_ids" field was cleared in this mutation.
func (m *SetMealDetailMutation) OptionalProductIdsCleared() bool {
	_, ok := m.clearedFields[setmealdetail.FieldOptionalProductIds]
	return ok
}

// ResetOptionalProductIds resets all changes to the "optional_product_ids" field.
func (m *SetMealDetailMutation) ResetOptionalProductIds() {
	m.optional_product_ids = nil
	m.appendoptional_product_ids = nil
	delete(m.clearedFields, setmealdetail.FieldOptionalProductIds)
}

// ClearGroup clears the "group" edge to the SetMealGroup entity.
func (m *SetMealDetailMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[setmealdetail.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the SetMealGroup entity was cleared.
func (m *SetMealDetailMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *SetMealDetailMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *SetMealDetailMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *SetMealDetailMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[setmealdetail.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *SetMealDetailMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *SetMealDetailMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *SetMealDetailMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the SetMealDetailMutation builder.
func (m *SetMealDetailMutation) Where(ps ...predicate.SetMealDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMealDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMealDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SetMealDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMealDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMealDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SetMealDetail).
func (m *SetMealDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMealDetailMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, setmealdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setmealdetail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, setmealdetail.FieldDeletedAt)
	}
	if m.group != nil {
		fields = append(fields, setmealdetail.FieldGroupID)
	}
	if m.product != nil {
		fields = append(fields, setmealdetail.FieldProductID)
	}
	if m.quantity != nil {
		fields = append(fields, setmealdetail.FieldQuantity)
	}
	if m.is_default != nil {
		fields = append(fields, setmealdetail.FieldIsDefault)
	}
	if m.optional_product_ids != nil {
		fields = append(fields, setmealdetail.FieldOptionalProductIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMealDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setmealdetail.FieldCreatedAt:
		return m.CreatedAt()
	case setmealdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case setmealdetail.FieldDeletedAt:
		return m.DeletedAt()
	case setmealdetail.FieldGroupID:
		return m.GroupID()
	case setmealdetail.FieldProductID:
		return m.ProductID()
	case setmealdetail.FieldQuantity:
		return m.Quantity()
	case setmealdetail.FieldIsDefault:
		return m.IsDefault()
	case setmealdetail.FieldOptionalProductIds:
		return m.OptionalProductIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMealDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setmealdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setmealdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setmealdetail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setmealdetail.FieldGroupID:
		return m.OldGroupID(ctx)
	case setmealdetail.FieldProductID:
		return m.OldProductID(ctx)
	case setmealdetail.FieldQuantity:
		return m.OldQuantity(ctx)
	case setmealdetail.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case setmealdetail.FieldOptionalProductIds:
		return m.OldOptionalProductIds(ctx)
	}
	return nil, fmt.Errorf("unknown SetMealDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMealDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setmealdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setmealdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setmealdetail.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setmealdetail.FieldGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case setmealdetail.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case setmealdetail.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case setmealdetail.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case setmealdetail.FieldOptionalProductIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionalProductIds(v)
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMealDetailMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, setmealdetail.FieldDeletedAt)
	}
	if m.addquantity != nil {
		fields = append(fields, setmealdetail.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMealDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case setmealdetail.FieldDeletedAt:
		return m.AddedDeletedAt()
	case setmealdetail.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMealDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case setmealdetail.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case setmealdetail.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMealDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setmealdetail.FieldOptionalProductIds) {
		fields = append(fields, setmealdetail.FieldOptionalProductIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMealDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMealDetailMutation) ClearField(name string) error {
	switch name {
	case setmealdetail.FieldOptionalProductIds:
		m.ClearOptionalProductIds()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMealDetailMutation) ResetField(name string) error {
	switch name {
	case setmealdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setmealdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setmealdetail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setmealdetail.FieldGroupID:
		m.ResetGroupID()
		return nil
	case setmealdetail.FieldProductID:
		m.ResetProductID()
		return nil
	case setmealdetail.FieldQuantity:
		m.ResetQuantity()
		return nil
	case setmealdetail.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case setmealdetail.FieldOptionalProductIds:
		m.ResetOptionalProductIds()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMealDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, setmealdetail.EdgeGroup)
	}
	if m.product != nil {
		edges = append(edges, setmealdetail.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMealDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case setmealdetail.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case setmealdetail.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMealDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMealDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMealDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, setmealdetail.EdgeGroup)
	}
	if m.clearedproduct {
		edges = append(edges, setmealdetail.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMealDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case setmealdetail.EdgeGroup:
		return m.clearedgroup
	case setmealdetail.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMealDetailMutation) ClearEdge(name string) error {
	switch name {
	case setmealdetail.EdgeGroup:
		m.ClearGroup()
		return nil
	case setmealdetail.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMealDetailMutation) ResetEdge(name string) error {
	switch name {
	case setmealdetail.EdgeGroup:
		m.ResetGroup()
		return nil
	case setmealdetail.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown SetMealDetail edge %s", name)
}

// SetMealGroupMutation represents an operation that mutates the SetMealGroup nodes in the graph.
type SetMealGroupMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int64
	adddeleted_at  *int64
	name           *string
	selection_type *domain.SetMealGroupSelectionType
	clearedFields  map[string]struct{}
	product        *uuid.UUID
	clearedproduct bool
	details        map[uuid.UUID]struct{}
	removeddetails map[uuid.UUID]struct{}
	cleareddetails bool
	done           bool
	oldValue       func(context.Context) (*SetMealGroup, error)
	predicates     []predicate.SetMealGroup
}

var _ ent.Mutation = (*SetMealGroupMutation)(nil)

// setmealgroupOption allows management of the mutation configuration using functional options.
type setmealgroupOption func(*SetMealGroupMutation)

// newSetMealGroupMutation creates new mutation for the SetMealGroup entity.
func newSetMealGroupMutation(c config, op Op, opts ...setmealgroupOption) *SetMealGroupMutation {
	m := &SetMealGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeSetMealGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetMealGroupID sets the ID field of the mutation.
func withSetMealGroupID(id uuid.UUID) setmealgroupOption {
	return func(m *SetMealGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *SetMealGroup
		)
		m.oldValue = func(ctx context.Context) (*SetMealGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SetMealGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetMealGroup sets the old SetMealGroup of the mutation.
func withSetMealGroup(node *SetMealGroup) setmealgroupOption {
	return func(m *SetMealGroupMutation) {
		m.oldValue = func(context.Context) (*SetMealGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMealGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMealGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SetMealGroup entities.
func (m *SetMealGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMealGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMealGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SetMealGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SetMealGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SetMealGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SetMealGroup entity.
// If the SetMealGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SetMealGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SetMealGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SetMealGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SetMealGroup entity.
// If the SetMealGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SetMealGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SetMealGroupMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SetMealGroupMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SetMealGroup entity.
// If the SetMealGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealGroupMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SetMealGroupMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SetMealGroupMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SetMealGroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProductID sets the "product_id" field.
func (m *SetMealGroupMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *SetMealGroupMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the SetMealGroup entity.
// If the SetMealGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealGroupMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *SetMealGroupMutation) ResetProductID() {
	m.product = nil
}

// SetName sets the "name" field.
func (m *SetMealGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SetMealGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SetMealGroup entity.
// If the SetMealGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SetMealGroupMutation) ResetName() {
	m.name = nil
}

// SetSelectionType sets the "selection_type" field.
func (m *SetMealGroupMutation) SetSelectionType(dmgst domain.SetMealGroupSelectionType) {
	m.selection_type = &dmgst
}

// SelectionType returns the value of the "selection_type" field in the mutation.
func (m *SetMealGroupMutation) SelectionType() (r domain.SetMealGroupSelectionType, exists bool) {
	v := m.selection_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectionType returns the old "selection_type" field's value of the SetMealGroup entity.
// If the SetMealGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMealGroupMutation) OldSelectionType(ctx context.Context) (v domain.SetMealGroupSelectionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectionType: %w", err)
	}
	return oldValue.SelectionType, nil
}

// ResetSelectionType resets all changes to the "selection_type" field.
func (m *SetMealGroupMutation) ResetSelectionType() {
	m.selection_type = nil
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *SetMealGroupMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[setmealgroup.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *SetMealGroupMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *SetMealGroupMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *SetMealGroupMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddDetailIDs adds the "details" edge to the SetMealDetail entity by ids.
func (m *SetMealGroupMutation) AddDetailIDs(ids ...uuid.UUID) {
	if m.details == nil {
		m.details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the SetMealDetail entity.
func (m *SetMealGroupMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the SetMealDetail entity was cleared.
func (m *SetMealGroupMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the SetMealDetail entity by IDs.
func (m *SetMealGroupMutation) RemoveDetailIDs(ids ...uuid.UUID) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the SetMealDetail entity.
func (m *SetMealGroupMutation) RemovedDetailsIDs() (ids []uuid.UUID) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *SetMealGroupMutation) DetailsIDs() (ids []uuid.UUID) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *SetMealGroupMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// Where appends a list predicates to the SetMealGroupMutation builder.
func (m *SetMealGroupMutation) Where(ps ...predicate.SetMealGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMealGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMealGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SetMealGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMealGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMealGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SetMealGroup).
func (m *SetMealGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMealGroupMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, setmealgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setmealgroup.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, setmealgroup.FieldDeletedAt)
	}
	if m.product != nil {
		fields = append(fields, setmealgroup.FieldProductID)
	}
	if m.name != nil {
		fields = append(fields, setmealgroup.FieldName)
	}
	if m.selection_type != nil {
		fields = append(fields, setmealgroup.FieldSelectionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMealGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setmealgroup.FieldCreatedAt:
		return m.CreatedAt()
	case setmealgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case setmealgroup.FieldDeletedAt:
		return m.DeletedAt()
	case setmealgroup.FieldProductID:
		return m.ProductID()
	case setmealgroup.FieldName:
		return m.Name()
	case setmealgroup.FieldSelectionType:
		return m.SelectionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMealGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setmealgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setmealgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setmealgroup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setmealgroup.FieldProductID:
		return m.OldProductID(ctx)
	case setmealgroup.FieldName:
		return m.OldName(ctx)
	case setmealgroup.FieldSelectionType:
		return m.OldSelectionType(ctx)
	}
	return nil, fmt.Errorf("unknown SetMealGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMealGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setmealgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setmealgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setmealgroup.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setmealgroup.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case setmealgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setmealgroup.FieldSelectionType:
		v, ok := value.(domain.SetMealGroupSelectionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectionType(v)
		return nil
	}
	return fmt.Errorf("unknown SetMealGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMealGroupMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, setmealgroup.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMealGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case setmealgroup.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMealGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case setmealgroup.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SetMealGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMealGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMealGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMealGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SetMealGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMealGroupMutation) ResetField(name string) error {
	switch name {
	case setmealgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setmealgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setmealgroup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setmealgroup.FieldProductID:
		m.ResetProductID()
		return nil
	case setmealgroup.FieldName:
		m.ResetName()
		return nil
	case setmealgroup.FieldSelectionType:
		m.ResetSelectionType()
		return nil
	}
	return fmt.Errorf("unknown SetMealGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMealGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, setmealgroup.EdgeProduct)
	}
	if m.details != nil {
		edges = append(edges, setmealgroup.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMealGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case setmealgroup.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case setmealgroup.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMealGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddetails != nil {
		edges = append(edges, setmealgroup.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMealGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case setmealgroup.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMealGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, setmealgroup.EdgeProduct)
	}
	if m.cleareddetails {
		edges = append(edges, setmealgroup.EdgeDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMealGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case setmealgroup.EdgeProduct:
		return m.clearedproduct
	case setmealgroup.EdgeDetails:
		return m.cleareddetails
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMealGroupMutation) ClearEdge(name string) error {
	switch name {
	case setmealgroup.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown SetMealGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMealGroupMutation) ResetEdge(name string) error {
	switch name {
	case setmealgroup.EdgeProduct:
		m.ResetProduct()
		return nil
	case setmealgroup.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown SetMealGroup edge %s", name)
}

// StallMutation represents an operation that mutates the Stall nodes in the graph.
type StallMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	stall_type      *domain.StallType
	print_type      *domain.StallPrintType
	enabled         *bool
	sort_order      *int
	addsort_order   *int
	clearedFields   map[string]struct{}
	merchant        *uuid.UUID
	clearedmerchant bool
	store           *uuid.UUID
	clearedstore    bool
	devices         map[uuid.UUID]struct{}
	removeddevices  map[uuid.UUID]struct{}
	cleareddevices  bool
	done            bool
	oldValue        func(context.Context) (*Stall, error)
	predicates      []predicate.Stall
}

var _ ent.Mutation = (*StallMutation)(nil)

// stallOption allows management of the mutation configuration using functional options.
type stallOption func(*StallMutation)

// newStallMutation creates new mutation for the Stall entity.
func newStallMutation(c config, op Op, opts ...stallOption) *StallMutation {
	m := &StallMutation{
		config:        c,
		op:            op,
		typ:           TypeStall,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStallID sets the ID field of the mutation.
func withStallID(id uuid.UUID) stallOption {
	return func(m *StallMutation) {
		var (
			err   error
			once  sync.Once
			value *Stall
		)
		m.oldValue = func(ctx context.Context) (*Stall, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stall.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStall sets the old Stall of the mutation.
func withStall(node *Stall) stallOption {
	return func(m *StallMutation) {
		m.oldValue = func(context.Context) (*Stall, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StallMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StallMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stall entities.
func (m *StallMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StallMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StallMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stall.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StallMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StallMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StallMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StallMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StallMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StallMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StallMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StallMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StallMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StallMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StallMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *StallMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StallMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StallMutation) ResetName() {
	m.name = nil
}

// SetStallType sets the "stall_type" field.
func (m *StallMutation) SetStallType(dt domain.StallType) {
	m.stall_type = &dt
}

// StallType returns the value of the "stall_type" field in the mutation.
func (m *StallMutation) StallType() (r domain.StallType, exists bool) {
	v := m.stall_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStallType returns the old "stall_type" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldStallType(ctx context.Context) (v domain.StallType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStallType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStallType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStallType: %w", err)
	}
	return oldValue.StallType, nil
}

// ResetStallType resets all changes to the "stall_type" field.
func (m *StallMutation) ResetStallType() {
	m.stall_type = nil
}

// SetPrintType sets the "print_type" field.
func (m *StallMutation) SetPrintType(dpt domain.StallPrintType) {
	m.print_type = &dpt
}

// PrintType returns the value of the "print_type" field in the mutation.
func (m *StallMutation) PrintType() (r domain.StallPrintType, exists bool) {
	v := m.print_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintType returns the old "print_type" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldPrintType(ctx context.Context) (v domain.StallPrintType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintType: %w", err)
	}
	return oldValue.PrintType, nil
}

// ResetPrintType resets all changes to the "print_type" field.
func (m *StallMutation) ResetPrintType() {
	m.print_type = nil
}

// SetEnabled sets the "enabled" field.
func (m *StallMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *StallMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *StallMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *StallMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *StallMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *StallMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *StallMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *StallMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *StallMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *StallMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *StallMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[stall.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *StallMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[stall.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *StallMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, stall.FieldMerchantID)
}

// SetStoreID sets the "store_id" field.
func (m *StallMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StallMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Stall entity.
// If the Stall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StallMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *StallMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[stall.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *StallMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[stall.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StallMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, stall.FieldStoreID)
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *StallMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[stall.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *StallMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *StallMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *StallMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StallMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[stall.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StallMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StallMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StallMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *StallMutation) AddDeviceIDs(ids ...uuid.UUID) {
	if m.devices == nil {
		m.devices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *StallMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *StallMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *StallMutation) RemoveDeviceIDs(ids ...uuid.UUID) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *StallMutation) RemovedDevicesIDs() (ids []uuid.UUID) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *StallMutation) DevicesIDs() (ids []uuid.UUID) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *StallMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// Where appends a list predicates to the StallMutation builder.
func (m *StallMutation) Where(ps ...predicate.Stall) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StallMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StallMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stall, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StallMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StallMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stall).
func (m *StallMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StallMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, stall.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stall.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, stall.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, stall.FieldName)
	}
	if m.stall_type != nil {
		fields = append(fields, stall.FieldStallType)
	}
	if m.print_type != nil {
		fields = append(fields, stall.FieldPrintType)
	}
	if m.enabled != nil {
		fields = append(fields, stall.FieldEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, stall.FieldSortOrder)
	}
	if m.merchant != nil {
		fields = append(fields, stall.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, stall.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StallMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stall.FieldCreatedAt:
		return m.CreatedAt()
	case stall.FieldUpdatedAt:
		return m.UpdatedAt()
	case stall.FieldDeletedAt:
		return m.DeletedAt()
	case stall.FieldName:
		return m.Name()
	case stall.FieldStallType:
		return m.StallType()
	case stall.FieldPrintType:
		return m.PrintType()
	case stall.FieldEnabled:
		return m.Enabled()
	case stall.FieldSortOrder:
		return m.SortOrder()
	case stall.FieldMerchantID:
		return m.MerchantID()
	case stall.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StallMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stall.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stall.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stall.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case stall.FieldName:
		return m.OldName(ctx)
	case stall.FieldStallType:
		return m.OldStallType(ctx)
	case stall.FieldPrintType:
		return m.OldPrintType(ctx)
	case stall.FieldEnabled:
		return m.OldEnabled(ctx)
	case stall.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case stall.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case stall.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown Stall field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StallMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stall.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stall.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stall.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case stall.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stall.FieldStallType:
		v, ok := value.(domain.StallType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStallType(v)
		return nil
	case stall.FieldPrintType:
		v, ok := value.(domain.StallPrintType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintType(v)
		return nil
	case stall.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case stall.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case stall.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case stall.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown Stall field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StallMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, stall.FieldDeletedAt)
	}
	if m.addsort_order != nil {
		fields = append(fields, stall.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StallMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stall.FieldDeletedAt:
		return m.AddedDeletedAt()
	case stall.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StallMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stall.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case stall.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Stall numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StallMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stall.FieldMerchantID) {
		fields = append(fields, stall.FieldMerchantID)
	}
	if m.FieldCleared(stall.FieldStoreID) {
		fields = append(fields, stall.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StallMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StallMutation) ClearField(name string) error {
	switch name {
	case stall.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case stall.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown Stall nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StallMutation) ResetField(name string) error {
	switch name {
	case stall.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stall.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stall.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case stall.FieldName:
		m.ResetName()
		return nil
	case stall.FieldStallType:
		m.ResetStallType()
		return nil
	case stall.FieldPrintType:
		m.ResetPrintType()
		return nil
	case stall.FieldEnabled:
		m.ResetEnabled()
		return nil
	case stall.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case stall.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case stall.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown Stall field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StallMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.merchant != nil {
		edges = append(edges, stall.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, stall.EdgeStore)
	}
	if m.devices != nil {
		edges = append(edges, stall.EdgeDevices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StallMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stall.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case stall.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case stall.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StallMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddevices != nil {
		edges = append(edges, stall.EdgeDevices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StallMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stall.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StallMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmerchant {
		edges = append(edges, stall.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, stall.EdgeStore)
	}
	if m.cleareddevices {
		edges = append(edges, stall.EdgeDevices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StallMutation) EdgeCleared(name string) bool {
	switch name {
	case stall.EdgeMerchant:
		return m.clearedmerchant
	case stall.EdgeStore:
		return m.clearedstore
	case stall.EdgeDevices:
		return m.cleareddevices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StallMutation) ClearEdge(name string) error {
	switch name {
	case stall.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case stall.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Stall unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StallMutation) ResetEdge(name string) error {
	switch name {
	case stall.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case stall.EdgeStore:
		m.ResetStore()
		return nil
	case stall.EdgeDevices:
		m.ResetDevices()
		return nil
	}
	return fmt.Errorf("unknown Stall edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *int64
	adddeleted_at                 *int64
	admin_phone_number            *string
	store_name                    *string
	store_short_name              *string
	store_code                    *string
	status                        *domain.StoreStatus
	business_model                *domain.BusinessModel
	location_number               *string
	contact_name                  *string
	contact_phone                 *string
	unified_social_credit_code    *string
	store_logo                    *string
	business_license_url          *string
	storefront_url                *string
	cashier_desk_url              *string
	dining_environment_url        *string
	food_operation_license_url    *string
	business_hours                *[]domain.BusinessHours
	appendbusiness_hours          []domain.BusinessHours
	dining_periods                *[]domain.DiningPeriod
	appenddining_periods          []domain.DiningPeriod
	shift_times                   *[]domain.ShiftTime
	appendshift_times             []domain.ShiftTime
	address                       *string
	lng                           *string
	lat                           *string
	super_account                 *string
	clearedFields                 map[string]struct{}
	merchant                      *uuid.UUID
	clearedmerchant               bool
	merchant_business_type        *uuid.UUID
	clearedmerchant_business_type bool
	country                       *uuid.UUID
	clearedcountry                bool
	province                      *uuid.UUID
	clearedprovince               bool
	city                          *uuid.UUID
	clearedcity                   bool
	district                      *uuid.UUID
	cleareddistrict               bool
	store_users                   map[uuid.UUID]struct{}
	removedstore_users            map[uuid.UUID]struct{}
	clearedstore_users            bool
	remarks                       map[uuid.UUID]struct{}
	removedremarks                map[uuid.UUID]struct{}
	clearedremarks                bool
	stalls                        map[uuid.UUID]struct{}
	removedstalls                 map[uuid.UUID]struct{}
	clearedstalls                 bool
	additional_fees               map[uuid.UUID]struct{}
	removedadditional_fees        map[uuid.UUID]struct{}
	clearedadditional_fees        bool
	tax_fees                      map[uuid.UUID]struct{}
	removedtax_fees               map[uuid.UUID]struct{}
	clearedtax_fees               bool
	devices                       map[uuid.UUID]struct{}
	removeddevices                map[uuid.UUID]struct{}
	cleareddevices                bool
	menus                         map[uuid.UUID]struct{}
	removedmenus                  map[uuid.UUID]struct{}
	clearedmenus                  bool
	departments                   map[uuid.UUID]struct{}
	removeddepartments            map[uuid.UUID]struct{}
	cleareddepartments            bool
	roles                         map[uuid.UUID]struct{}
	removedroles                  map[uuid.UUID]struct{}
	clearedroles                  bool
	done                          bool
	oldValue                      func(context.Context) (*Store, error)
	predicates                    []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id uuid.UUID) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Store entities.
func (m *StoreMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StoreMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StoreMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *StoreMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *StoreMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *StoreMutation) ResetMerchantID() {
	m.merchant = nil
}

// SetAdminPhoneNumber sets the "admin_phone_number" field.
func (m *StoreMutation) SetAdminPhoneNumber(s string) {
	m.admin_phone_number = &s
}

// AdminPhoneNumber returns the value of the "admin_phone_number" field in the mutation.
func (m *StoreMutation) AdminPhoneNumber() (r string, exists bool) {
	v := m.admin_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminPhoneNumber returns the old "admin_phone_number" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldAdminPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminPhoneNumber: %w", err)
	}
	return oldValue.AdminPhoneNumber, nil
}

// ResetAdminPhoneNumber resets all changes to the "admin_phone_number" field.
func (m *StoreMutation) ResetAdminPhoneNumber() {
	m.admin_phone_number = nil
}

// SetStoreName sets the "store_name" field.
func (m *StoreMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *StoreMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *StoreMutation) ResetStoreName() {
	m.store_name = nil
}

// SetStoreShortName sets the "store_short_name" field.
func (m *StoreMutation) SetStoreShortName(s string) {
	m.store_short_name = &s
}

// StoreShortName returns the value of the "store_short_name" field in the mutation.
func (m *StoreMutation) StoreShortName() (r string, exists bool) {
	v := m.store_short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreShortName returns the old "store_short_name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreShortName: %w", err)
	}
	return oldValue.StoreShortName, nil
}

// ClearStoreShortName clears the value of the "store_short_name" field.
func (m *StoreMutation) ClearStoreShortName() {
	m.store_short_name = nil
	m.clearedFields[store.FieldStoreShortName] = struct{}{}
}

// StoreShortNameCleared returns if the "store_short_name" field was cleared in this mutation.
func (m *StoreMutation) StoreShortNameCleared() bool {
	_, ok := m.clearedFields[store.FieldStoreShortName]
	return ok
}

// ResetStoreShortName resets all changes to the "store_short_name" field.
func (m *StoreMutation) ResetStoreShortName() {
	m.store_short_name = nil
	delete(m.clearedFields, store.FieldStoreShortName)
}

// SetStoreCode sets the "store_code" field.
func (m *StoreMutation) SetStoreCode(s string) {
	m.store_code = &s
}

// StoreCode returns the value of the "store_code" field in the mutation.
func (m *StoreMutation) StoreCode() (r string, exists bool) {
	v := m.store_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreCode returns the old "store_code" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreCode: %w", err)
	}
	return oldValue.StoreCode, nil
}

// ClearStoreCode clears the value of the "store_code" field.
func (m *StoreMutation) ClearStoreCode() {
	m.store_code = nil
	m.clearedFields[store.FieldStoreCode] = struct{}{}
}

// StoreCodeCleared returns if the "store_code" field was cleared in this mutation.
func (m *StoreMutation) StoreCodeCleared() bool {
	_, ok := m.clearedFields[store.FieldStoreCode]
	return ok
}

// ResetStoreCode resets all changes to the "store_code" field.
func (m *StoreMutation) ResetStoreCode() {
	m.store_code = nil
	delete(m.clearedFields, store.FieldStoreCode)
}

// SetStatus sets the "status" field.
func (m *StoreMutation) SetStatus(ds domain.StoreStatus) {
	m.status = &ds
}

// Status returns the value of the "status" field in the mutation.
func (m *StoreMutation) Status() (r domain.StoreStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStatus(ctx context.Context) (v domain.StoreStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StoreMutation) ResetStatus() {
	m.status = nil
}

// SetBusinessModel sets the "business_model" field.
func (m *StoreMutation) SetBusinessModel(dm domain.BusinessModel) {
	m.business_model = &dm
}

// BusinessModel returns the value of the "business_model" field in the mutation.
func (m *StoreMutation) BusinessModel() (r domain.BusinessModel, exists bool) {
	v := m.business_model
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessModel returns the old "business_model" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBusinessModel(ctx context.Context) (v domain.BusinessModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessModel: %w", err)
	}
	return oldValue.BusinessModel, nil
}

// ResetBusinessModel resets all changes to the "business_model" field.
func (m *StoreMutation) ResetBusinessModel() {
	m.business_model = nil
}

// SetBusinessTypeID sets the "business_type_id" field.
func (m *StoreMutation) SetBusinessTypeID(u uuid.UUID) {
	m.merchant_business_type = &u
}

// BusinessTypeID returns the value of the "business_type_id" field in the mutation.
func (m *StoreMutation) BusinessTypeID() (r uuid.UUID, exists bool) {
	v := m.merchant_business_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessTypeID returns the old "business_type_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBusinessTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessTypeID: %w", err)
	}
	return oldValue.BusinessTypeID, nil
}

// ResetBusinessTypeID resets all changes to the "business_type_id" field.
func (m *StoreMutation) ResetBusinessTypeID() {
	m.merchant_business_type = nil
}

// SetLocationNumber sets the "location_number" field.
func (m *StoreMutation) SetLocationNumber(s string) {
	m.location_number = &s
}

// LocationNumber returns the value of the "location_number" field in the mutation.
func (m *StoreMutation) LocationNumber() (r string, exists bool) {
	v := m.location_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationNumber returns the old "location_number" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLocationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationNumber: %w", err)
	}
	return oldValue.LocationNumber, nil
}

// ResetLocationNumber resets all changes to the "location_number" field.
func (m *StoreMutation) ResetLocationNumber() {
	m.location_number = nil
}

// SetContactName sets the "contact_name" field.
func (m *StoreMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *StoreMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ClearContactName clears the value of the "contact_name" field.
func (m *StoreMutation) ClearContactName() {
	m.contact_name = nil
	m.clearedFields[store.FieldContactName] = struct{}{}
}

// ContactNameCleared returns if the "contact_name" field was cleared in this mutation.
func (m *StoreMutation) ContactNameCleared() bool {
	_, ok := m.clearedFields[store.FieldContactName]
	return ok
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *StoreMutation) ResetContactName() {
	m.contact_name = nil
	delete(m.clearedFields, store.FieldContactName)
}

// SetContactPhone sets the "contact_phone" field.
func (m *StoreMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *StoreMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ClearContactPhone clears the value of the "contact_phone" field.
func (m *StoreMutation) ClearContactPhone() {
	m.contact_phone = nil
	m.clearedFields[store.FieldContactPhone] = struct{}{}
}

// ContactPhoneCleared returns if the "contact_phone" field was cleared in this mutation.
func (m *StoreMutation) ContactPhoneCleared() bool {
	_, ok := m.clearedFields[store.FieldContactPhone]
	return ok
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *StoreMutation) ResetContactPhone() {
	m.contact_phone = nil
	delete(m.clearedFields, store.FieldContactPhone)
}

// SetUnifiedSocialCreditCode sets the "unified_social_credit_code" field.
func (m *StoreMutation) SetUnifiedSocialCreditCode(s string) {
	m.unified_social_credit_code = &s
}

// UnifiedSocialCreditCode returns the value of the "unified_social_credit_code" field in the mutation.
func (m *StoreMutation) UnifiedSocialCreditCode() (r string, exists bool) {
	v := m.unified_social_credit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUnifiedSocialCreditCode returns the old "unified_social_credit_code" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUnifiedSocialCreditCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnifiedSocialCreditCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnifiedSocialCreditCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnifiedSocialCreditCode: %w", err)
	}
	return oldValue.UnifiedSocialCreditCode, nil
}

// ClearUnifiedSocialCreditCode clears the value of the "unified_social_credit_code" field.
func (m *StoreMutation) ClearUnifiedSocialCreditCode() {
	m.unified_social_credit_code = nil
	m.clearedFields[store.FieldUnifiedSocialCreditCode] = struct{}{}
}

// UnifiedSocialCreditCodeCleared returns if the "unified_social_credit_code" field was cleared in this mutation.
func (m *StoreMutation) UnifiedSocialCreditCodeCleared() bool {
	_, ok := m.clearedFields[store.FieldUnifiedSocialCreditCode]
	return ok
}

// ResetUnifiedSocialCreditCode resets all changes to the "unified_social_credit_code" field.
func (m *StoreMutation) ResetUnifiedSocialCreditCode() {
	m.unified_social_credit_code = nil
	delete(m.clearedFields, store.FieldUnifiedSocialCreditCode)
}

// SetStoreLogo sets the "store_logo" field.
func (m *StoreMutation) SetStoreLogo(s string) {
	m.store_logo = &s
}

// StoreLogo returns the value of the "store_logo" field in the mutation.
func (m *StoreMutation) StoreLogo() (r string, exists bool) {
	v := m.store_logo
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreLogo returns the old "store_logo" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreLogo: %w", err)
	}
	return oldValue.StoreLogo, nil
}

// ClearStoreLogo clears the value of the "store_logo" field.
func (m *StoreMutation) ClearStoreLogo() {
	m.store_logo = nil
	m.clearedFields[store.FieldStoreLogo] = struct{}{}
}

// StoreLogoCleared returns if the "store_logo" field was cleared in this mutation.
func (m *StoreMutation) StoreLogoCleared() bool {
	_, ok := m.clearedFields[store.FieldStoreLogo]
	return ok
}

// ResetStoreLogo resets all changes to the "store_logo" field.
func (m *StoreMutation) ResetStoreLogo() {
	m.store_logo = nil
	delete(m.clearedFields, store.FieldStoreLogo)
}

// SetBusinessLicenseURL sets the "business_license_url" field.
func (m *StoreMutation) SetBusinessLicenseURL(s string) {
	m.business_license_url = &s
}

// BusinessLicenseURL returns the value of the "business_license_url" field in the mutation.
func (m *StoreMutation) BusinessLicenseURL() (r string, exists bool) {
	v := m.business_license_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessLicenseURL returns the old "business_license_url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBusinessLicenseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessLicenseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessLicenseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessLicenseURL: %w", err)
	}
	return oldValue.BusinessLicenseURL, nil
}

// ClearBusinessLicenseURL clears the value of the "business_license_url" field.
func (m *StoreMutation) ClearBusinessLicenseURL() {
	m.business_license_url = nil
	m.clearedFields[store.FieldBusinessLicenseURL] = struct{}{}
}

// BusinessLicenseURLCleared returns if the "business_license_url" field was cleared in this mutation.
func (m *StoreMutation) BusinessLicenseURLCleared() bool {
	_, ok := m.clearedFields[store.FieldBusinessLicenseURL]
	return ok
}

// ResetBusinessLicenseURL resets all changes to the "business_license_url" field.
func (m *StoreMutation) ResetBusinessLicenseURL() {
	m.business_license_url = nil
	delete(m.clearedFields, store.FieldBusinessLicenseURL)
}

// SetStorefrontURL sets the "storefront_url" field.
func (m *StoreMutation) SetStorefrontURL(s string) {
	m.storefront_url = &s
}

// StorefrontURL returns the value of the "storefront_url" field in the mutation.
func (m *StoreMutation) StorefrontURL() (r string, exists bool) {
	v := m.storefront_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStorefrontURL returns the old "storefront_url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStorefrontURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorefrontURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorefrontURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorefrontURL: %w", err)
	}
	return oldValue.StorefrontURL, nil
}

// ClearStorefrontURL clears the value of the "storefront_url" field.
func (m *StoreMutation) ClearStorefrontURL() {
	m.storefront_url = nil
	m.clearedFields[store.FieldStorefrontURL] = struct{}{}
}

// StorefrontURLCleared returns if the "storefront_url" field was cleared in this mutation.
func (m *StoreMutation) StorefrontURLCleared() bool {
	_, ok := m.clearedFields[store.FieldStorefrontURL]
	return ok
}

// ResetStorefrontURL resets all changes to the "storefront_url" field.
func (m *StoreMutation) ResetStorefrontURL() {
	m.storefront_url = nil
	delete(m.clearedFields, store.FieldStorefrontURL)
}

// SetCashierDeskURL sets the "cashier_desk_url" field.
func (m *StoreMutation) SetCashierDeskURL(s string) {
	m.cashier_desk_url = &s
}

// CashierDeskURL returns the value of the "cashier_desk_url" field in the mutation.
func (m *StoreMutation) CashierDeskURL() (r string, exists bool) {
	v := m.cashier_desk_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCashierDeskURL returns the old "cashier_desk_url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCashierDeskURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashierDeskURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashierDeskURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashierDeskURL: %w", err)
	}
	return oldValue.CashierDeskURL, nil
}

// ClearCashierDeskURL clears the value of the "cashier_desk_url" field.
func (m *StoreMutation) ClearCashierDeskURL() {
	m.cashier_desk_url = nil
	m.clearedFields[store.FieldCashierDeskURL] = struct{}{}
}

// CashierDeskURLCleared returns if the "cashier_desk_url" field was cleared in this mutation.
func (m *StoreMutation) CashierDeskURLCleared() bool {
	_, ok := m.clearedFields[store.FieldCashierDeskURL]
	return ok
}

// ResetCashierDeskURL resets all changes to the "cashier_desk_url" field.
func (m *StoreMutation) ResetCashierDeskURL() {
	m.cashier_desk_url = nil
	delete(m.clearedFields, store.FieldCashierDeskURL)
}

// SetDiningEnvironmentURL sets the "dining_environment_url" field.
func (m *StoreMutation) SetDiningEnvironmentURL(s string) {
	m.dining_environment_url = &s
}

// DiningEnvironmentURL returns the value of the "dining_environment_url" field in the mutation.
func (m *StoreMutation) DiningEnvironmentURL() (r string, exists bool) {
	v := m.dining_environment_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDiningEnvironmentURL returns the old "dining_environment_url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDiningEnvironmentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiningEnvironmentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiningEnvironmentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiningEnvironmentURL: %w", err)
	}
	return oldValue.DiningEnvironmentURL, nil
}

// ClearDiningEnvironmentURL clears the value of the "dining_environment_url" field.
func (m *StoreMutation) ClearDiningEnvironmentURL() {
	m.dining_environment_url = nil
	m.clearedFields[store.FieldDiningEnvironmentURL] = struct{}{}
}

// DiningEnvironmentURLCleared returns if the "dining_environment_url" field was cleared in this mutation.
func (m *StoreMutation) DiningEnvironmentURLCleared() bool {
	_, ok := m.clearedFields[store.FieldDiningEnvironmentURL]
	return ok
}

// ResetDiningEnvironmentURL resets all changes to the "dining_environment_url" field.
func (m *StoreMutation) ResetDiningEnvironmentURL() {
	m.dining_environment_url = nil
	delete(m.clearedFields, store.FieldDiningEnvironmentURL)
}

// SetFoodOperationLicenseURL sets the "food_operation_license_url" field.
func (m *StoreMutation) SetFoodOperationLicenseURL(s string) {
	m.food_operation_license_url = &s
}

// FoodOperationLicenseURL returns the value of the "food_operation_license_url" field in the mutation.
func (m *StoreMutation) FoodOperationLicenseURL() (r string, exists bool) {
	v := m.food_operation_license_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodOperationLicenseURL returns the old "food_operation_license_url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldFoodOperationLicenseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoodOperationLicenseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoodOperationLicenseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodOperationLicenseURL: %w", err)
	}
	return oldValue.FoodOperationLicenseURL, nil
}

// ClearFoodOperationLicenseURL clears the value of the "food_operation_license_url" field.
func (m *StoreMutation) ClearFoodOperationLicenseURL() {
	m.food_operation_license_url = nil
	m.clearedFields[store.FieldFoodOperationLicenseURL] = struct{}{}
}

// FoodOperationLicenseURLCleared returns if the "food_operation_license_url" field was cleared in this mutation.
func (m *StoreMutation) FoodOperationLicenseURLCleared() bool {
	_, ok := m.clearedFields[store.FieldFoodOperationLicenseURL]
	return ok
}

// ResetFoodOperationLicenseURL resets all changes to the "food_operation_license_url" field.
func (m *StoreMutation) ResetFoodOperationLicenseURL() {
	m.food_operation_license_url = nil
	delete(m.clearedFields, store.FieldFoodOperationLicenseURL)
}

// SetBusinessHours sets the "business_hours" field.
func (m *StoreMutation) SetBusinessHours(dh []domain.BusinessHours) {
	m.business_hours = &dh
	m.appendbusiness_hours = nil
}

// BusinessHours returns the value of the "business_hours" field in the mutation.
func (m *StoreMutation) BusinessHours() (r []domain.BusinessHours, exists bool) {
	v := m.business_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessHours returns the old "business_hours" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBusinessHours(ctx context.Context) (v []domain.BusinessHours, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessHours: %w", err)
	}
	return oldValue.BusinessHours, nil
}

// AppendBusinessHours adds dh to the "business_hours" field.
func (m *StoreMutation) AppendBusinessHours(dh []domain.BusinessHours) {
	m.appendbusiness_hours = append(m.appendbusiness_hours, dh...)
}

// AppendedBusinessHours returns the list of values that were appended to the "business_hours" field in this mutation.
func (m *StoreMutation) AppendedBusinessHours() ([]domain.BusinessHours, bool) {
	if len(m.appendbusiness_hours) == 0 {
		return nil, false
	}
	return m.appendbusiness_hours, true
}

// ResetBusinessHours resets all changes to the "business_hours" field.
func (m *StoreMutation) ResetBusinessHours() {
	m.business_hours = nil
	m.appendbusiness_hours = nil
}

// SetDiningPeriods sets the "dining_periods" field.
func (m *StoreMutation) SetDiningPeriods(dp []domain.DiningPeriod) {
	m.dining_periods = &dp
	m.appenddining_periods = nil
}

// DiningPeriods returns the value of the "dining_periods" field in the mutation.
func (m *StoreMutation) DiningPeriods() (r []domain.DiningPeriod, exists bool) {
	v := m.dining_periods
	if v == nil {
		return
	}
	return *v, true
}

// OldDiningPeriods returns the old "dining_periods" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDiningPeriods(ctx context.Context) (v []domain.DiningPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiningPeriods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiningPeriods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiningPeriods: %w", err)
	}
	return oldValue.DiningPeriods, nil
}

// AppendDiningPeriods adds dp to the "dining_periods" field.
func (m *StoreMutation) AppendDiningPeriods(dp []domain.DiningPeriod) {
	m.appenddining_periods = append(m.appenddining_periods, dp...)
}

// AppendedDiningPeriods returns the list of values that were appended to the "dining_periods" field in this mutation.
func (m *StoreMutation) AppendedDiningPeriods() ([]domain.DiningPeriod, bool) {
	if len(m.appenddining_periods) == 0 {
		return nil, false
	}
	return m.appenddining_periods, true
}

// ResetDiningPeriods resets all changes to the "dining_periods" field.
func (m *StoreMutation) ResetDiningPeriods() {
	m.dining_periods = nil
	m.appenddining_periods = nil
}

// SetShiftTimes sets the "shift_times" field.
func (m *StoreMutation) SetShiftTimes(dt []domain.ShiftTime) {
	m.shift_times = &dt
	m.appendshift_times = nil
}

// ShiftTimes returns the value of the "shift_times" field in the mutation.
func (m *StoreMutation) ShiftTimes() (r []domain.ShiftTime, exists bool) {
	v := m.shift_times
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftTimes returns the old "shift_times" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldShiftTimes(ctx context.Context) (v []domain.ShiftTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftTimes: %w", err)
	}
	return oldValue.ShiftTimes, nil
}

// AppendShiftTimes adds dt to the "shift_times" field.
func (m *StoreMutation) AppendShiftTimes(dt []domain.ShiftTime) {
	m.appendshift_times = append(m.appendshift_times, dt...)
}

// AppendedShiftTimes returns the list of values that were appended to the "shift_times" field in this mutation.
func (m *StoreMutation) AppendedShiftTimes() ([]domain.ShiftTime, bool) {
	if len(m.appendshift_times) == 0 {
		return nil, false
	}
	return m.appendshift_times, true
}

// ResetShiftTimes resets all changes to the "shift_times" field.
func (m *StoreMutation) ResetShiftTimes() {
	m.shift_times = nil
	m.appendshift_times = nil
}

// SetCountryID sets the "country_id" field.
func (m *StoreMutation) SetCountryID(u uuid.UUID) {
	m.country = &u
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *StoreMutation) CountryID() (r uuid.UUID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCountryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ClearCountryID clears the value of the "country_id" field.
func (m *StoreMutation) ClearCountryID() {
	m.country = nil
	m.clearedFields[store.FieldCountryID] = struct{}{}
}

// CountryIDCleared returns if the "country_id" field was cleared in this mutation.
func (m *StoreMutation) CountryIDCleared() bool {
	_, ok := m.clearedFields[store.FieldCountryID]
	return ok
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *StoreMutation) ResetCountryID() {
	m.country = nil
	delete(m.clearedFields, store.FieldCountryID)
}

// SetProvinceID sets the "province_id" field.
func (m *StoreMutation) SetProvinceID(u uuid.UUID) {
	m.province = &u
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *StoreMutation) ProvinceID() (r uuid.UUID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldProvinceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ClearProvinceID clears the value of the "province_id" field.
func (m *StoreMutation) ClearProvinceID() {
	m.province = nil
	m.clearedFields[store.FieldProvinceID] = struct{}{}
}

// ProvinceIDCleared returns if the "province_id" field was cleared in this mutation.
func (m *StoreMutation) ProvinceIDCleared() bool {
	_, ok := m.clearedFields[store.FieldProvinceID]
	return ok
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *StoreMutation) ResetProvinceID() {
	m.province = nil
	delete(m.clearedFields, store.FieldProvinceID)
}

// SetCityID sets the "city_id" field.
func (m *StoreMutation) SetCityID(u uuid.UUID) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *StoreMutation) CityID() (r uuid.UUID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *StoreMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[store.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *StoreMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[store.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *StoreMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, store.FieldCityID)
}

// SetDistrictID sets the "district_id" field.
func (m *StoreMutation) SetDistrictID(u uuid.UUID) {
	m.district = &u
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *StoreMutation) DistrictID() (r uuid.UUID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDistrictID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ClearDistrictID clears the value of the "district_id" field.
func (m *StoreMutation) ClearDistrictID() {
	m.district = nil
	m.clearedFields[store.FieldDistrictID] = struct{}{}
}

// DistrictIDCleared returns if the "district_id" field was cleared in this mutation.
func (m *StoreMutation) DistrictIDCleared() bool {
	_, ok := m.clearedFields[store.FieldDistrictID]
	return ok
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *StoreMutation) ResetDistrictID() {
	m.district = nil
	delete(m.clearedFields, store.FieldDistrictID)
}

// SetAddress sets the "address" field.
func (m *StoreMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *StoreMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *StoreMutation) ResetAddress() {
	m.address = nil
}

// SetLng sets the "lng" field.
func (m *StoreMutation) SetLng(s string) {
	m.lng = &s
}

// Lng returns the value of the "lng" field in the mutation.
func (m *StoreMutation) Lng() (r string, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLng(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// ClearLng clears the value of the "lng" field.
func (m *StoreMutation) ClearLng() {
	m.lng = nil
	m.clearedFields[store.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *StoreMutation) LngCleared() bool {
	_, ok := m.clearedFields[store.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *StoreMutation) ResetLng() {
	m.lng = nil
	delete(m.clearedFields, store.FieldLng)
}

// SetLat sets the "lat" field.
func (m *StoreMutation) SetLat(s string) {
	m.lat = &s
}

// Lat returns the value of the "lat" field in the mutation.
func (m *StoreMutation) Lat() (r string, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// ClearLat clears the value of the "lat" field.
func (m *StoreMutation) ClearLat() {
	m.lat = nil
	m.clearedFields[store.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *StoreMutation) LatCleared() bool {
	_, ok := m.clearedFields[store.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *StoreMutation) ResetLat() {
	m.lat = nil
	delete(m.clearedFields, store.FieldLat)
}

// SetSuperAccount sets the "super_account" field.
func (m *StoreMutation) SetSuperAccount(s string) {
	m.super_account = &s
}

// SuperAccount returns the value of the "super_account" field in the mutation.
func (m *StoreMutation) SuperAccount() (r string, exists bool) {
	v := m.super_account
	if v == nil {
		return
	}
	return *v, true
}

// OldSuperAccount returns the old "super_account" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldSuperAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuperAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuperAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuperAccount: %w", err)
	}
	return oldValue.SuperAccount, nil
}

// ResetSuperAccount resets all changes to the "super_account" field.
func (m *StoreMutation) ResetSuperAccount() {
	m.super_account = nil
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *StoreMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[store.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *StoreMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *StoreMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetMerchantBusinessTypeID sets the "merchant_business_type" edge to the MerchantBusinessType entity by id.
func (m *StoreMutation) SetMerchantBusinessTypeID(id uuid.UUID) {
	m.merchant_business_type = &id
}

// ClearMerchantBusinessType clears the "merchant_business_type" edge to the MerchantBusinessType entity.
func (m *StoreMutation) ClearMerchantBusinessType() {
	m.clearedmerchant_business_type = true
	m.clearedFields[store.FieldBusinessTypeID] = struct{}{}
}

// MerchantBusinessTypeCleared reports if the "merchant_business_type" edge to the MerchantBusinessType entity was cleared.
func (m *StoreMutation) MerchantBusinessTypeCleared() bool {
	return m.clearedmerchant_business_type
}

// MerchantBusinessTypeID returns the "merchant_business_type" edge ID in the mutation.
func (m *StoreMutation) MerchantBusinessTypeID() (id uuid.UUID, exists bool) {
	if m.merchant_business_type != nil {
		return *m.merchant_business_type, true
	}
	return
}

// MerchantBusinessTypeIDs returns the "merchant_business_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantBusinessTypeID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) MerchantBusinessTypeIDs() (ids []uuid.UUID) {
	if id := m.merchant_business_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchantBusinessType resets all changes to the "merchant_business_type" edge.
func (m *StoreMutation) ResetMerchantBusinessType() {
	m.merchant_business_type = nil
	m.clearedmerchant_business_type = false
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *StoreMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[store.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *StoreMutation) CountryCleared() bool {
	return m.CountryIDCleared() || m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *StoreMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *StoreMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[store.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *StoreMutation) ProvinceCleared() bool {
	return m.ProvinceIDCleared() || m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) ProvinceIDs() (ids []uuid.UUID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *StoreMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *StoreMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[store.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *StoreMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) CityIDs() (ids []uuid.UUID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *StoreMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *StoreMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[store.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *StoreMutation) DistrictCleared() bool {
	return m.DistrictIDCleared() || m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) DistrictIDs() (ids []uuid.UUID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *StoreMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// AddStoreUserIDs adds the "store_users" edge to the StoreUser entity by ids.
func (m *StoreMutation) AddStoreUserIDs(ids ...uuid.UUID) {
	if m.store_users == nil {
		m.store_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.store_users[ids[i]] = struct{}{}
	}
}

// ClearStoreUsers clears the "store_users" edge to the StoreUser entity.
func (m *StoreMutation) ClearStoreUsers() {
	m.clearedstore_users = true
}

// StoreUsersCleared reports if the "store_users" edge to the StoreUser entity was cleared.
func (m *StoreMutation) StoreUsersCleared() bool {
	return m.clearedstore_users
}

// RemoveStoreUserIDs removes the "store_users" edge to the StoreUser entity by IDs.
func (m *StoreMutation) RemoveStoreUserIDs(ids ...uuid.UUID) {
	if m.removedstore_users == nil {
		m.removedstore_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.store_users, ids[i])
		m.removedstore_users[ids[i]] = struct{}{}
	}
}

// RemovedStoreUsers returns the removed IDs of the "store_users" edge to the StoreUser entity.
func (m *StoreMutation) RemovedStoreUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedstore_users {
		ids = append(ids, id)
	}
	return
}

// StoreUsersIDs returns the "store_users" edge IDs in the mutation.
func (m *StoreMutation) StoreUsersIDs() (ids []uuid.UUID) {
	for id := range m.store_users {
		ids = append(ids, id)
	}
	return
}

// ResetStoreUsers resets all changes to the "store_users" edge.
func (m *StoreMutation) ResetStoreUsers() {
	m.store_users = nil
	m.clearedstore_users = false
	m.removedstore_users = nil
}

// AddRemarkIDs adds the "remarks" edge to the Remark entity by ids.
func (m *StoreMutation) AddRemarkIDs(ids ...uuid.UUID) {
	if m.remarks == nil {
		m.remarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.remarks[ids[i]] = struct{}{}
	}
}

// ClearRemarks clears the "remarks" edge to the Remark entity.
func (m *StoreMutation) ClearRemarks() {
	m.clearedremarks = true
}

// RemarksCleared reports if the "remarks" edge to the Remark entity was cleared.
func (m *StoreMutation) RemarksCleared() bool {
	return m.clearedremarks
}

// RemoveRemarkIDs removes the "remarks" edge to the Remark entity by IDs.
func (m *StoreMutation) RemoveRemarkIDs(ids ...uuid.UUID) {
	if m.removedremarks == nil {
		m.removedremarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.remarks, ids[i])
		m.removedremarks[ids[i]] = struct{}{}
	}
}

// RemovedRemarks returns the removed IDs of the "remarks" edge to the Remark entity.
func (m *StoreMutation) RemovedRemarksIDs() (ids []uuid.UUID) {
	for id := range m.removedremarks {
		ids = append(ids, id)
	}
	return
}

// RemarksIDs returns the "remarks" edge IDs in the mutation.
func (m *StoreMutation) RemarksIDs() (ids []uuid.UUID) {
	for id := range m.remarks {
		ids = append(ids, id)
	}
	return
}

// ResetRemarks resets all changes to the "remarks" edge.
func (m *StoreMutation) ResetRemarks() {
	m.remarks = nil
	m.clearedremarks = false
	m.removedremarks = nil
}

// AddStallIDs adds the "stalls" edge to the Stall entity by ids.
func (m *StoreMutation) AddStallIDs(ids ...uuid.UUID) {
	if m.stalls == nil {
		m.stalls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stalls[ids[i]] = struct{}{}
	}
}

// ClearStalls clears the "stalls" edge to the Stall entity.
func (m *StoreMutation) ClearStalls() {
	m.clearedstalls = true
}

// StallsCleared reports if the "stalls" edge to the Stall entity was cleared.
func (m *StoreMutation) StallsCleared() bool {
	return m.clearedstalls
}

// RemoveStallIDs removes the "stalls" edge to the Stall entity by IDs.
func (m *StoreMutation) RemoveStallIDs(ids ...uuid.UUID) {
	if m.removedstalls == nil {
		m.removedstalls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stalls, ids[i])
		m.removedstalls[ids[i]] = struct{}{}
	}
}

// RemovedStalls returns the removed IDs of the "stalls" edge to the Stall entity.
func (m *StoreMutation) RemovedStallsIDs() (ids []uuid.UUID) {
	for id := range m.removedstalls {
		ids = append(ids, id)
	}
	return
}

// StallsIDs returns the "stalls" edge IDs in the mutation.
func (m *StoreMutation) StallsIDs() (ids []uuid.UUID) {
	for id := range m.stalls {
		ids = append(ids, id)
	}
	return
}

// ResetStalls resets all changes to the "stalls" edge.
func (m *StoreMutation) ResetStalls() {
	m.stalls = nil
	m.clearedstalls = false
	m.removedstalls = nil
}

// AddAdditionalFeeIDs adds the "additional_fees" edge to the AdditionalFee entity by ids.
func (m *StoreMutation) AddAdditionalFeeIDs(ids ...uuid.UUID) {
	if m.additional_fees == nil {
		m.additional_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.additional_fees[ids[i]] = struct{}{}
	}
}

// ClearAdditionalFees clears the "additional_fees" edge to the AdditionalFee entity.
func (m *StoreMutation) ClearAdditionalFees() {
	m.clearedadditional_fees = true
}

// AdditionalFeesCleared reports if the "additional_fees" edge to the AdditionalFee entity was cleared.
func (m *StoreMutation) AdditionalFeesCleared() bool {
	return m.clearedadditional_fees
}

// RemoveAdditionalFeeIDs removes the "additional_fees" edge to the AdditionalFee entity by IDs.
func (m *StoreMutation) RemoveAdditionalFeeIDs(ids ...uuid.UUID) {
	if m.removedadditional_fees == nil {
		m.removedadditional_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.additional_fees, ids[i])
		m.removedadditional_fees[ids[i]] = struct{}{}
	}
}

// RemovedAdditionalFees returns the removed IDs of the "additional_fees" edge to the AdditionalFee entity.
func (m *StoreMutation) RemovedAdditionalFeesIDs() (ids []uuid.UUID) {
	for id := range m.removedadditional_fees {
		ids = append(ids, id)
	}
	return
}

// AdditionalFeesIDs returns the "additional_fees" edge IDs in the mutation.
func (m *StoreMutation) AdditionalFeesIDs() (ids []uuid.UUID) {
	for id := range m.additional_fees {
		ids = append(ids, id)
	}
	return
}

// ResetAdditionalFees resets all changes to the "additional_fees" edge.
func (m *StoreMutation) ResetAdditionalFees() {
	m.additional_fees = nil
	m.clearedadditional_fees = false
	m.removedadditional_fees = nil
}

// AddTaxFeeIDs adds the "tax_fees" edge to the TaxFee entity by ids.
func (m *StoreMutation) AddTaxFeeIDs(ids ...uuid.UUID) {
	if m.tax_fees == nil {
		m.tax_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tax_fees[ids[i]] = struct{}{}
	}
}

// ClearTaxFees clears the "tax_fees" edge to the TaxFee entity.
func (m *StoreMutation) ClearTaxFees() {
	m.clearedtax_fees = true
}

// TaxFeesCleared reports if the "tax_fees" edge to the TaxFee entity was cleared.
func (m *StoreMutation) TaxFeesCleared() bool {
	return m.clearedtax_fees
}

// RemoveTaxFeeIDs removes the "tax_fees" edge to the TaxFee entity by IDs.
func (m *StoreMutation) RemoveTaxFeeIDs(ids ...uuid.UUID) {
	if m.removedtax_fees == nil {
		m.removedtax_fees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tax_fees, ids[i])
		m.removedtax_fees[ids[i]] = struct{}{}
	}
}

// RemovedTaxFees returns the removed IDs of the "tax_fees" edge to the TaxFee entity.
func (m *StoreMutation) RemovedTaxFeesIDs() (ids []uuid.UUID) {
	for id := range m.removedtax_fees {
		ids = append(ids, id)
	}
	return
}

// TaxFeesIDs returns the "tax_fees" edge IDs in the mutation.
func (m *StoreMutation) TaxFeesIDs() (ids []uuid.UUID) {
	for id := range m.tax_fees {
		ids = append(ids, id)
	}
	return
}

// ResetTaxFees resets all changes to the "tax_fees" edge.
func (m *StoreMutation) ResetTaxFees() {
	m.tax_fees = nil
	m.clearedtax_fees = false
	m.removedtax_fees = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *StoreMutation) AddDeviceIDs(ids ...uuid.UUID) {
	if m.devices == nil {
		m.devices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *StoreMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *StoreMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *StoreMutation) RemoveDeviceIDs(ids ...uuid.UUID) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *StoreMutation) RemovedDevicesIDs() (ids []uuid.UUID) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *StoreMutation) DevicesIDs() (ids []uuid.UUID) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *StoreMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *StoreMutation) AddMenuIDs(ids ...uuid.UUID) {
	if m.menus == nil {
		m.menus = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *StoreMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *StoreMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *StoreMutation) RemoveMenuIDs(ids ...uuid.UUID) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *StoreMutation) RemovedMenusIDs() (ids []uuid.UUID) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *StoreMutation) MenusIDs() (ids []uuid.UUID) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *StoreMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddDepartmentIDs adds the "departments" edge to the Department entity by ids.
func (m *StoreMutation) AddDepartmentIDs(ids ...uuid.UUID) {
	if m.departments == nil {
		m.departments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// ClearDepartments clears the "departments" edge to the Department entity.
func (m *StoreMutation) ClearDepartments() {
	m.cleareddepartments = true
}

// DepartmentsCleared reports if the "departments" edge to the Department entity was cleared.
func (m *StoreMutation) DepartmentsCleared() bool {
	return m.cleareddepartments
}

// RemoveDepartmentIDs removes the "departments" edge to the Department entity by IDs.
func (m *StoreMutation) RemoveDepartmentIDs(ids ...uuid.UUID) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.departments, ids[i])
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed IDs of the "departments" edge to the Department entity.
func (m *StoreMutation) RemovedDepartmentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the "departments" edge IDs in the mutation.
func (m *StoreMutation) DepartmentsIDs() (ids []uuid.UUID) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments resets all changes to the "departments" edge.
func (m *StoreMutation) ResetDepartments() {
	m.departments = nil
	m.cleareddepartments = false
	m.removeddepartments = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *StoreMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *StoreMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *StoreMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *StoreMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *StoreMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *StoreMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *StoreMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Store, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.created_at != nil {
		fields = append(fields, store.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.merchant != nil {
		fields = append(fields, store.FieldMerchantID)
	}
	if m.admin_phone_number != nil {
		fields = append(fields, store.FieldAdminPhoneNumber)
	}
	if m.store_name != nil {
		fields = append(fields, store.FieldStoreName)
	}
	if m.store_short_name != nil {
		fields = append(fields, store.FieldStoreShortName)
	}
	if m.store_code != nil {
		fields = append(fields, store.FieldStoreCode)
	}
	if m.status != nil {
		fields = append(fields, store.FieldStatus)
	}
	if m.business_model != nil {
		fields = append(fields, store.FieldBusinessModel)
	}
	if m.merchant_business_type != nil {
		fields = append(fields, store.FieldBusinessTypeID)
	}
	if m.location_number != nil {
		fields = append(fields, store.FieldLocationNumber)
	}
	if m.contact_name != nil {
		fields = append(fields, store.FieldContactName)
	}
	if m.contact_phone != nil {
		fields = append(fields, store.FieldContactPhone)
	}
	if m.unified_social_credit_code != nil {
		fields = append(fields, store.FieldUnifiedSocialCreditCode)
	}
	if m.store_logo != nil {
		fields = append(fields, store.FieldStoreLogo)
	}
	if m.business_license_url != nil {
		fields = append(fields, store.FieldBusinessLicenseURL)
	}
	if m.storefront_url != nil {
		fields = append(fields, store.FieldStorefrontURL)
	}
	if m.cashier_desk_url != nil {
		fields = append(fields, store.FieldCashierDeskURL)
	}
	if m.dining_environment_url != nil {
		fields = append(fields, store.FieldDiningEnvironmentURL)
	}
	if m.food_operation_license_url != nil {
		fields = append(fields, store.FieldFoodOperationLicenseURL)
	}
	if m.business_hours != nil {
		fields = append(fields, store.FieldBusinessHours)
	}
	if m.dining_periods != nil {
		fields = append(fields, store.FieldDiningPeriods)
	}
	if m.shift_times != nil {
		fields = append(fields, store.FieldShiftTimes)
	}
	if m.country != nil {
		fields = append(fields, store.FieldCountryID)
	}
	if m.province != nil {
		fields = append(fields, store.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, store.FieldCityID)
	}
	if m.district != nil {
		fields = append(fields, store.FieldDistrictID)
	}
	if m.address != nil {
		fields = append(fields, store.FieldAddress)
	}
	if m.lng != nil {
		fields = append(fields, store.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, store.FieldLat)
	}
	if m.super_account != nil {
		fields = append(fields, store.FieldSuperAccount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldCreatedAt:
		return m.CreatedAt()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	case store.FieldDeletedAt:
		return m.DeletedAt()
	case store.FieldMerchantID:
		return m.MerchantID()
	case store.FieldAdminPhoneNumber:
		return m.AdminPhoneNumber()
	case store.FieldStoreName:
		return m.StoreName()
	case store.FieldStoreShortName:
		return m.StoreShortName()
	case store.FieldStoreCode:
		return m.StoreCode()
	case store.FieldStatus:
		return m.Status()
	case store.FieldBusinessModel:
		return m.BusinessModel()
	case store.FieldBusinessTypeID:
		return m.BusinessTypeID()
	case store.FieldLocationNumber:
		return m.LocationNumber()
	case store.FieldContactName:
		return m.ContactName()
	case store.FieldContactPhone:
		return m.ContactPhone()
	case store.FieldUnifiedSocialCreditCode:
		return m.UnifiedSocialCreditCode()
	case store.FieldStoreLogo:
		return m.StoreLogo()
	case store.FieldBusinessLicenseURL:
		return m.BusinessLicenseURL()
	case store.FieldStorefrontURL:
		return m.StorefrontURL()
	case store.FieldCashierDeskURL:
		return m.CashierDeskURL()
	case store.FieldDiningEnvironmentURL:
		return m.DiningEnvironmentURL()
	case store.FieldFoodOperationLicenseURL:
		return m.FoodOperationLicenseURL()
	case store.FieldBusinessHours:
		return m.BusinessHours()
	case store.FieldDiningPeriods:
		return m.DiningPeriods()
	case store.FieldShiftTimes:
		return m.ShiftTimes()
	case store.FieldCountryID:
		return m.CountryID()
	case store.FieldProvinceID:
		return m.ProvinceID()
	case store.FieldCityID:
		return m.CityID()
	case store.FieldDistrictID:
		return m.DistrictID()
	case store.FieldAddress:
		return m.Address()
	case store.FieldLng:
		return m.Lng()
	case store.FieldLat:
		return m.Lat()
	case store.FieldSuperAccount:
		return m.SuperAccount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case store.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case store.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case store.FieldAdminPhoneNumber:
		return m.OldAdminPhoneNumber(ctx)
	case store.FieldStoreName:
		return m.OldStoreName(ctx)
	case store.FieldStoreShortName:
		return m.OldStoreShortName(ctx)
	case store.FieldStoreCode:
		return m.OldStoreCode(ctx)
	case store.FieldStatus:
		return m.OldStatus(ctx)
	case store.FieldBusinessModel:
		return m.OldBusinessModel(ctx)
	case store.FieldBusinessTypeID:
		return m.OldBusinessTypeID(ctx)
	case store.FieldLocationNumber:
		return m.OldLocationNumber(ctx)
	case store.FieldContactName:
		return m.OldContactName(ctx)
	case store.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case store.FieldUnifiedSocialCreditCode:
		return m.OldUnifiedSocialCreditCode(ctx)
	case store.FieldStoreLogo:
		return m.OldStoreLogo(ctx)
	case store.FieldBusinessLicenseURL:
		return m.OldBusinessLicenseURL(ctx)
	case store.FieldStorefrontURL:
		return m.OldStorefrontURL(ctx)
	case store.FieldCashierDeskURL:
		return m.OldCashierDeskURL(ctx)
	case store.FieldDiningEnvironmentURL:
		return m.OldDiningEnvironmentURL(ctx)
	case store.FieldFoodOperationLicenseURL:
		return m.OldFoodOperationLicenseURL(ctx)
	case store.FieldBusinessHours:
		return m.OldBusinessHours(ctx)
	case store.FieldDiningPeriods:
		return m.OldDiningPeriods(ctx)
	case store.FieldShiftTimes:
		return m.OldShiftTimes(ctx)
	case store.FieldCountryID:
		return m.OldCountryID(ctx)
	case store.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case store.FieldCityID:
		return m.OldCityID(ctx)
	case store.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case store.FieldAddress:
		return m.OldAddress(ctx)
	case store.FieldLng:
		return m.OldLng(ctx)
	case store.FieldLat:
		return m.OldLat(ctx)
	case store.FieldSuperAccount:
		return m.OldSuperAccount(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case store.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case store.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case store.FieldAdminPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminPhoneNumber(v)
		return nil
	case store.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case store.FieldStoreShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreShortName(v)
		return nil
	case store.FieldStoreCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreCode(v)
		return nil
	case store.FieldStatus:
		v, ok := value.(domain.StoreStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case store.FieldBusinessModel:
		v, ok := value.(domain.BusinessModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessModel(v)
		return nil
	case store.FieldBusinessTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessTypeID(v)
		return nil
	case store.FieldLocationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationNumber(v)
		return nil
	case store.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case store.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case store.FieldUnifiedSocialCreditCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnifiedSocialCreditCode(v)
		return nil
	case store.FieldStoreLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreLogo(v)
		return nil
	case store.FieldBusinessLicenseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessLicenseURL(v)
		return nil
	case store.FieldStorefrontURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorefrontURL(v)
		return nil
	case store.FieldCashierDeskURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashierDeskURL(v)
		return nil
	case store.FieldDiningEnvironmentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiningEnvironmentURL(v)
		return nil
	case store.FieldFoodOperationLicenseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodOperationLicenseURL(v)
		return nil
	case store.FieldBusinessHours:
		v, ok := value.([]domain.BusinessHours)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessHours(v)
		return nil
	case store.FieldDiningPeriods:
		v, ok := value.([]domain.DiningPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiningPeriods(v)
		return nil
	case store.FieldShiftTimes:
		v, ok := value.([]domain.ShiftTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftTimes(v)
		return nil
	case store.FieldCountryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case store.FieldProvinceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case store.FieldCityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case store.FieldDistrictID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case store.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case store.FieldLng:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case store.FieldLat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case store.FieldSuperAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuperAccount(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(store.FieldStoreShortName) {
		fields = append(fields, store.FieldStoreShortName)
	}
	if m.FieldCleared(store.FieldStoreCode) {
		fields = append(fields, store.FieldStoreCode)
	}
	if m.FieldCleared(store.FieldContactName) {
		fields = append(fields, store.FieldContactName)
	}
	if m.FieldCleared(store.FieldContactPhone) {
		fields = append(fields, store.FieldContactPhone)
	}
	if m.FieldCleared(store.FieldUnifiedSocialCreditCode) {
		fields = append(fields, store.FieldUnifiedSocialCreditCode)
	}
	if m.FieldCleared(store.FieldStoreLogo) {
		fields = append(fields, store.FieldStoreLogo)
	}
	if m.FieldCleared(store.FieldBusinessLicenseURL) {
		fields = append(fields, store.FieldBusinessLicenseURL)
	}
	if m.FieldCleared(store.FieldStorefrontURL) {
		fields = append(fields, store.FieldStorefrontURL)
	}
	if m.FieldCleared(store.FieldCashierDeskURL) {
		fields = append(fields, store.FieldCashierDeskURL)
	}
	if m.FieldCleared(store.FieldDiningEnvironmentURL) {
		fields = append(fields, store.FieldDiningEnvironmentURL)
	}
	if m.FieldCleared(store.FieldFoodOperationLicenseURL) {
		fields = append(fields, store.FieldFoodOperationLicenseURL)
	}
	if m.FieldCleared(store.FieldCountryID) {
		fields = append(fields, store.FieldCountryID)
	}
	if m.FieldCleared(store.FieldProvinceID) {
		fields = append(fields, store.FieldProvinceID)
	}
	if m.FieldCleared(store.FieldCityID) {
		fields = append(fields, store.FieldCityID)
	}
	if m.FieldCleared(store.FieldDistrictID) {
		fields = append(fields, store.FieldDistrictID)
	}
	if m.FieldCleared(store.FieldLng) {
		fields = append(fields, store.FieldLng)
	}
	if m.FieldCleared(store.FieldLat) {
		fields = append(fields, store.FieldLat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	switch name {
	case store.FieldStoreShortName:
		m.ClearStoreShortName()
		return nil
	case store.FieldStoreCode:
		m.ClearStoreCode()
		return nil
	case store.FieldContactName:
		m.ClearContactName()
		return nil
	case store.FieldContactPhone:
		m.ClearContactPhone()
		return nil
	case store.FieldUnifiedSocialCreditCode:
		m.ClearUnifiedSocialCreditCode()
		return nil
	case store.FieldStoreLogo:
		m.ClearStoreLogo()
		return nil
	case store.FieldBusinessLicenseURL:
		m.ClearBusinessLicenseURL()
		return nil
	case store.FieldStorefrontURL:
		m.ClearStorefrontURL()
		return nil
	case store.FieldCashierDeskURL:
		m.ClearCashierDeskURL()
		return nil
	case store.FieldDiningEnvironmentURL:
		m.ClearDiningEnvironmentURL()
		return nil
	case store.FieldFoodOperationLicenseURL:
		m.ClearFoodOperationLicenseURL()
		return nil
	case store.FieldCountryID:
		m.ClearCountryID()
		return nil
	case store.FieldProvinceID:
		m.ClearProvinceID()
		return nil
	case store.FieldCityID:
		m.ClearCityID()
		return nil
	case store.FieldDistrictID:
		m.ClearDistrictID()
		return nil
	case store.FieldLng:
		m.ClearLng()
		return nil
	case store.FieldLat:
		m.ClearLat()
		return nil
	}
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case store.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case store.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case store.FieldAdminPhoneNumber:
		m.ResetAdminPhoneNumber()
		return nil
	case store.FieldStoreName:
		m.ResetStoreName()
		return nil
	case store.FieldStoreShortName:
		m.ResetStoreShortName()
		return nil
	case store.FieldStoreCode:
		m.ResetStoreCode()
		return nil
	case store.FieldStatus:
		m.ResetStatus()
		return nil
	case store.FieldBusinessModel:
		m.ResetBusinessModel()
		return nil
	case store.FieldBusinessTypeID:
		m.ResetBusinessTypeID()
		return nil
	case store.FieldLocationNumber:
		m.ResetLocationNumber()
		return nil
	case store.FieldContactName:
		m.ResetContactName()
		return nil
	case store.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case store.FieldUnifiedSocialCreditCode:
		m.ResetUnifiedSocialCreditCode()
		return nil
	case store.FieldStoreLogo:
		m.ResetStoreLogo()
		return nil
	case store.FieldBusinessLicenseURL:
		m.ResetBusinessLicenseURL()
		return nil
	case store.FieldStorefrontURL:
		m.ResetStorefrontURL()
		return nil
	case store.FieldCashierDeskURL:
		m.ResetCashierDeskURL()
		return nil
	case store.FieldDiningEnvironmentURL:
		m.ResetDiningEnvironmentURL()
		return nil
	case store.FieldFoodOperationLicenseURL:
		m.ResetFoodOperationLicenseURL()
		return nil
	case store.FieldBusinessHours:
		m.ResetBusinessHours()
		return nil
	case store.FieldDiningPeriods:
		m.ResetDiningPeriods()
		return nil
	case store.FieldShiftTimes:
		m.ResetShiftTimes()
		return nil
	case store.FieldCountryID:
		m.ResetCountryID()
		return nil
	case store.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case store.FieldCityID:
		m.ResetCityID()
		return nil
	case store.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case store.FieldAddress:
		m.ResetAddress()
		return nil
	case store.FieldLng:
		m.ResetLng()
		return nil
	case store.FieldLat:
		m.ResetLat()
		return nil
	case store.FieldSuperAccount:
		m.ResetSuperAccount()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.merchant != nil {
		edges = append(edges, store.EdgeMerchant)
	}
	if m.merchant_business_type != nil {
		edges = append(edges, store.EdgeMerchantBusinessType)
	}
	if m.country != nil {
		edges = append(edges, store.EdgeCountry)
	}
	if m.province != nil {
		edges = append(edges, store.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, store.EdgeCity)
	}
	if m.district != nil {
		edges = append(edges, store.EdgeDistrict)
	}
	if m.store_users != nil {
		edges = append(edges, store.EdgeStoreUsers)
	}
	if m.remarks != nil {
		edges = append(edges, store.EdgeRemarks)
	}
	if m.stalls != nil {
		edges = append(edges, store.EdgeStalls)
	}
	if m.additional_fees != nil {
		edges = append(edges, store.EdgeAdditionalFees)
	}
	if m.tax_fees != nil {
		edges = append(edges, store.EdgeTaxFees)
	}
	if m.devices != nil {
		edges = append(edges, store.EdgeDevices)
	}
	if m.menus != nil {
		edges = append(edges, store.EdgeMenus)
	}
	if m.departments != nil {
		edges = append(edges, store.EdgeDepartments)
	}
	if m.roles != nil {
		edges = append(edges, store.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeMerchantBusinessType:
		if id := m.merchant_business_type; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeStoreUsers:
		ids := make([]ent.Value, 0, len(m.store_users))
		for id := range m.store_users {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeRemarks:
		ids := make([]ent.Value, 0, len(m.remarks))
		for id := range m.remarks {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeStalls:
		ids := make([]ent.Value, 0, len(m.stalls))
		for id := range m.stalls {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeAdditionalFees:
		ids := make([]ent.Value, 0, len(m.additional_fees))
		for id := range m.additional_fees {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeTaxFees:
		ids := make([]ent.Value, 0, len(m.tax_fees))
		for id := range m.tax_fees {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedstore_users != nil {
		edges = append(edges, store.EdgeStoreUsers)
	}
	if m.removedremarks != nil {
		edges = append(edges, store.EdgeRemarks)
	}
	if m.removedstalls != nil {
		edges = append(edges, store.EdgeStalls)
	}
	if m.removedadditional_fees != nil {
		edges = append(edges, store.EdgeAdditionalFees)
	}
	if m.removedtax_fees != nil {
		edges = append(edges, store.EdgeTaxFees)
	}
	if m.removeddevices != nil {
		edges = append(edges, store.EdgeDevices)
	}
	if m.removedmenus != nil {
		edges = append(edges, store.EdgeMenus)
	}
	if m.removeddepartments != nil {
		edges = append(edges, store.EdgeDepartments)
	}
	if m.removedroles != nil {
		edges = append(edges, store.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeStoreUsers:
		ids := make([]ent.Value, 0, len(m.removedstore_users))
		for id := range m.removedstore_users {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeRemarks:
		ids := make([]ent.Value, 0, len(m.removedremarks))
		for id := range m.removedremarks {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeStalls:
		ids := make([]ent.Value, 0, len(m.removedstalls))
		for id := range m.removedstalls {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeAdditionalFees:
		ids := make([]ent.Value, 0, len(m.removedadditional_fees))
		for id := range m.removedadditional_fees {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeTaxFees:
		ids := make([]ent.Value, 0, len(m.removedtax_fees))
		for id := range m.removedtax_fees {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedmerchant {
		edges = append(edges, store.EdgeMerchant)
	}
	if m.clearedmerchant_business_type {
		edges = append(edges, store.EdgeMerchantBusinessType)
	}
	if m.clearedcountry {
		edges = append(edges, store.EdgeCountry)
	}
	if m.clearedprovince {
		edges = append(edges, store.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, store.EdgeCity)
	}
	if m.cleareddistrict {
		edges = append(edges, store.EdgeDistrict)
	}
	if m.clearedstore_users {
		edges = append(edges, store.EdgeStoreUsers)
	}
	if m.clearedremarks {
		edges = append(edges, store.EdgeRemarks)
	}
	if m.clearedstalls {
		edges = append(edges, store.EdgeStalls)
	}
	if m.clearedadditional_fees {
		edges = append(edges, store.EdgeAdditionalFees)
	}
	if m.clearedtax_fees {
		edges = append(edges, store.EdgeTaxFees)
	}
	if m.cleareddevices {
		edges = append(edges, store.EdgeDevices)
	}
	if m.clearedmenus {
		edges = append(edges, store.EdgeMenus)
	}
	if m.cleareddepartments {
		edges = append(edges, store.EdgeDepartments)
	}
	if m.clearedroles {
		edges = append(edges, store.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeMerchant:
		return m.clearedmerchant
	case store.EdgeMerchantBusinessType:
		return m.clearedmerchant_business_type
	case store.EdgeCountry:
		return m.clearedcountry
	case store.EdgeProvince:
		return m.clearedprovince
	case store.EdgeCity:
		return m.clearedcity
	case store.EdgeDistrict:
		return m.cleareddistrict
	case store.EdgeStoreUsers:
		return m.clearedstore_users
	case store.EdgeRemarks:
		return m.clearedremarks
	case store.EdgeStalls:
		return m.clearedstalls
	case store.EdgeAdditionalFees:
		return m.clearedadditional_fees
	case store.EdgeTaxFees:
		return m.clearedtax_fees
	case store.EdgeDevices:
		return m.cleareddevices
	case store.EdgeMenus:
		return m.clearedmenus
	case store.EdgeDepartments:
		return m.cleareddepartments
	case store.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	case store.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case store.EdgeMerchantBusinessType:
		m.ClearMerchantBusinessType()
		return nil
	case store.EdgeCountry:
		m.ClearCountry()
		return nil
	case store.EdgeProvince:
		m.ClearProvince()
		return nil
	case store.EdgeCity:
		m.ClearCity()
		return nil
	case store.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case store.EdgeMerchantBusinessType:
		m.ResetMerchantBusinessType()
		return nil
	case store.EdgeCountry:
		m.ResetCountry()
		return nil
	case store.EdgeProvince:
		m.ResetProvince()
		return nil
	case store.EdgeCity:
		m.ResetCity()
		return nil
	case store.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case store.EdgeStoreUsers:
		m.ResetStoreUsers()
		return nil
	case store.EdgeRemarks:
		m.ResetRemarks()
		return nil
	case store.EdgeStalls:
		m.ResetStalls()
		return nil
	case store.EdgeAdditionalFees:
		m.ResetAdditionalFees()
		return nil
	case store.EdgeTaxFees:
		m.ResetTaxFees()
		return nil
	case store.EdgeDevices:
		m.ResetDevices()
		return nil
	case store.EdgeMenus:
		m.ResetMenus()
		return nil
	case store.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case store.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}

// StoreUserMutation represents an operation that mutates the StoreUser nodes in the graph.
type StoreUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	username        *string
	hashed_password *string
	nickname        *string
	clearedFields   map[string]struct{}
	merchant        *uuid.UUID
	clearedmerchant bool
	store           *uuid.UUID
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*StoreUser, error)
	predicates      []predicate.StoreUser
}

var _ ent.Mutation = (*StoreUserMutation)(nil)

// storeuserOption allows management of the mutation configuration using functional options.
type storeuserOption func(*StoreUserMutation)

// newStoreUserMutation creates new mutation for the StoreUser entity.
func newStoreUserMutation(c config, op Op, opts ...storeuserOption) *StoreUserMutation {
	m := &StoreUserMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreUserID sets the ID field of the mutation.
func withStoreUserID(id uuid.UUID) storeuserOption {
	return func(m *StoreUserMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreUser
		)
		m.oldValue = func(ctx context.Context) (*StoreUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreUser sets the old StoreUser of the mutation.
func withStoreUser(node *StoreUser) storeuserOption {
	return func(m *StoreUserMutation) {
		m.oldValue = func(context.Context) (*StoreUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoreUser entities.
func (m *StoreUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreUserMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreUserMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *StoreUserMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StoreUserMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUsername sets the "username" field.
func (m *StoreUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *StoreUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *StoreUserMutation) ResetUsername() {
	m.username = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *StoreUserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *StoreUserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *StoreUserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetNickname sets the "nickname" field.
func (m *StoreUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *StoreUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *StoreUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *StoreUserMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *StoreUserMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *StoreUserMutation) ResetMerchantID() {
	m.merchant = nil
}

// SetStoreID sets the "store_id" field.
func (m *StoreUserMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StoreUserMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StoreUser entity.
// If the StoreUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreUserMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StoreUserMutation) ResetStoreID() {
	m.store = nil
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *StoreUserMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[storeuser.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *StoreUserMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *StoreUserMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *StoreUserMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StoreUserMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[storeuser.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StoreUserMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StoreUserMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StoreUserMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the StoreUserMutation builder.
func (m *StoreUserMutation) Where(ps ...predicate.StoreUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreUser).
func (m *StoreUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, storeuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storeuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storeuser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, storeuser.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, storeuser.FieldHashedPassword)
	}
	if m.nickname != nil {
		fields = append(fields, storeuser.FieldNickname)
	}
	if m.merchant != nil {
		fields = append(fields, storeuser.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, storeuser.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storeuser.FieldCreatedAt:
		return m.CreatedAt()
	case storeuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case storeuser.FieldDeletedAt:
		return m.DeletedAt()
	case storeuser.FieldUsername:
		return m.Username()
	case storeuser.FieldHashedPassword:
		return m.HashedPassword()
	case storeuser.FieldNickname:
		return m.Nickname()
	case storeuser.FieldMerchantID:
		return m.MerchantID()
	case storeuser.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storeuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storeuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storeuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storeuser.FieldUsername:
		return m.OldUsername(ctx)
	case storeuser.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case storeuser.FieldNickname:
		return m.OldNickname(ctx)
	case storeuser.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case storeuser.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown StoreUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storeuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storeuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storeuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storeuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case storeuser.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case storeuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case storeuser.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case storeuser.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown StoreUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreUserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, storeuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storeuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storeuser.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StoreUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StoreUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreUserMutation) ResetField(name string) error {
	switch name {
	case storeuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storeuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storeuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storeuser.FieldUsername:
		m.ResetUsername()
		return nil
	case storeuser.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case storeuser.FieldNickname:
		m.ResetNickname()
		return nil
	case storeuser.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case storeuser.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown StoreUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.merchant != nil {
		edges = append(edges, storeuser.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, storeuser.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storeuser.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case storeuser.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmerchant {
		edges = append(edges, storeuser.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, storeuser.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreUserMutation) EdgeCleared(name string) bool {
	switch name {
	case storeuser.EdgeMerchant:
		return m.clearedmerchant
	case storeuser.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreUserMutation) ClearEdge(name string) error {
	switch name {
	case storeuser.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case storeuser.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown StoreUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreUserMutation) ResetEdge(name string) error {
	switch name {
	case storeuser.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case storeuser.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown StoreUser edge %s", name)
}

// TaxFeeMutation represents an operation that mutates the TaxFee nodes in the graph.
type TaxFeeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int64
	adddeleted_at   *int64
	name            *string
	tax_fee_type    *domain.TaxFeeType
	tax_code        *string
	tax_rate_type   *domain.TaxRateType
	tax_rate        *decimal.Decimal
	default_tax     *bool
	clearedFields   map[string]struct{}
	merchant        *uuid.UUID
	clearedmerchant bool
	store           *uuid.UUID
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*TaxFee, error)
	predicates      []predicate.TaxFee
}

var _ ent.Mutation = (*TaxFeeMutation)(nil)

// taxfeeOption allows management of the mutation configuration using functional options.
type taxfeeOption func(*TaxFeeMutation)

// newTaxFeeMutation creates new mutation for the TaxFee entity.
func newTaxFeeMutation(c config, op Op, opts ...taxfeeOption) *TaxFeeMutation {
	m := &TaxFeeMutation{
		config:        c,
		op:            op,
		typ:           TypeTaxFee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaxFeeID sets the ID field of the mutation.
func withTaxFeeID(id uuid.UUID) taxfeeOption {
	return func(m *TaxFeeMutation) {
		var (
			err   error
			once  sync.Once
			value *TaxFee
		)
		m.oldValue = func(ctx context.Context) (*TaxFee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaxFee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaxFee sets the old TaxFee of the mutation.
func withTaxFee(node *TaxFee) taxfeeOption {
	return func(m *TaxFeeMutation) {
		m.oldValue = func(context.Context) (*TaxFee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaxFeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaxFeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaxFee entities.
func (m *TaxFeeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaxFeeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaxFeeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaxFee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaxFeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaxFeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaxFeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaxFeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaxFeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaxFeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaxFeeMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaxFeeMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TaxFeeMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TaxFeeMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaxFeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *TaxFeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaxFeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaxFeeMutation) ResetName() {
	m.name = nil
}

// SetTaxFeeType sets the "tax_fee_type" field.
func (m *TaxFeeMutation) SetTaxFeeType(dft domain.TaxFeeType) {
	m.tax_fee_type = &dft
}

// TaxFeeType returns the value of the "tax_fee_type" field in the mutation.
func (m *TaxFeeMutation) TaxFeeType() (r domain.TaxFeeType, exists bool) {
	v := m.tax_fee_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxFeeType returns the old "tax_fee_type" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldTaxFeeType(ctx context.Context) (v domain.TaxFeeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxFeeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxFeeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxFeeType: %w", err)
	}
	return oldValue.TaxFeeType, nil
}

// ResetTaxFeeType resets all changes to the "tax_fee_type" field.
func (m *TaxFeeMutation) ResetTaxFeeType() {
	m.tax_fee_type = nil
}

// SetTaxCode sets the "tax_code" field.
func (m *TaxFeeMutation) SetTaxCode(s string) {
	m.tax_code = &s
}

// TaxCode returns the value of the "tax_code" field in the mutation.
func (m *TaxFeeMutation) TaxCode() (r string, exists bool) {
	v := m.tax_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxCode returns the old "tax_code" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldTaxCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxCode: %w", err)
	}
	return oldValue.TaxCode, nil
}

// ResetTaxCode resets all changes to the "tax_code" field.
func (m *TaxFeeMutation) ResetTaxCode() {
	m.tax_code = nil
}

// SetTaxRateType sets the "tax_rate_type" field.
func (m *TaxFeeMutation) SetTaxRateType(drt domain.TaxRateType) {
	m.tax_rate_type = &drt
}

// TaxRateType returns the value of the "tax_rate_type" field in the mutation.
func (m *TaxFeeMutation) TaxRateType() (r domain.TaxRateType, exists bool) {
	v := m.tax_rate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRateType returns the old "tax_rate_type" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldTaxRateType(ctx context.Context) (v domain.TaxRateType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRateType: %w", err)
	}
	return oldValue.TaxRateType, nil
}

// ResetTaxRateType resets all changes to the "tax_rate_type" field.
func (m *TaxFeeMutation) ResetTaxRateType() {
	m.tax_rate_type = nil
}

// SetTaxRate sets the "tax_rate" field.
func (m *TaxFeeMutation) SetTaxRate(d decimal.Decimal) {
	m.tax_rate = &d
}

// TaxRate returns the value of the "tax_rate" field in the mutation.
func (m *TaxFeeMutation) TaxRate() (r decimal.Decimal, exists bool) {
	v := m.tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRate returns the old "tax_rate" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldTaxRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRate: %w", err)
	}
	return oldValue.TaxRate, nil
}

// ResetTaxRate resets all changes to the "tax_rate" field.
func (m *TaxFeeMutation) ResetTaxRate() {
	m.tax_rate = nil
}

// SetDefaultTax sets the "default_tax" field.
func (m *TaxFeeMutation) SetDefaultTax(b bool) {
	m.default_tax = &b
}

// DefaultTax returns the value of the "default_tax" field in the mutation.
func (m *TaxFeeMutation) DefaultTax() (r bool, exists bool) {
	v := m.default_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTax returns the old "default_tax" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldDefaultTax(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTax: %w", err)
	}
	return oldValue.DefaultTax, nil
}

// ResetDefaultTax resets all changes to the "default_tax" field.
func (m *TaxFeeMutation) ResetDefaultTax() {
	m.default_tax = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *TaxFeeMutation) SetMerchantID(u uuid.UUID) {
	m.merchant = &u
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *TaxFeeMutation) MerchantID() (r uuid.UUID, exists bool) {
	v := m.merchant
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldMerchantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "merchant_id" field.
func (m *TaxFeeMutation) ClearMerchantID() {
	m.merchant = nil
	m.clearedFields[taxfee.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "merchant_id" field was cleared in this mutation.
func (m *TaxFeeMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[taxfee.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *TaxFeeMutation) ResetMerchantID() {
	m.merchant = nil
	delete(m.clearedFields, taxfee.FieldMerchantID)
}

// SetStoreID sets the "store_id" field.
func (m *TaxFeeMutation) SetStoreID(u uuid.UUID) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *TaxFeeMutation) StoreID() (r uuid.UUID, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the TaxFee entity.
// If the TaxFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaxFeeMutation) OldStoreID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *TaxFeeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[taxfee.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *TaxFeeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[taxfee.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *TaxFeeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, taxfee.FieldStoreID)
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *TaxFeeMutation) ClearMerchant() {
	m.clearedmerchant = true
	m.clearedFields[taxfee.FieldMerchantID] = struct{}{}
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *TaxFeeMutation) MerchantCleared() bool {
	return m.MerchantIDCleared() || m.clearedmerchant
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *TaxFeeMutation) MerchantIDs() (ids []uuid.UUID) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *TaxFeeMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *TaxFeeMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[taxfee.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *TaxFeeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *TaxFeeMutation) StoreIDs() (ids []uuid.UUID) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *TaxFeeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the TaxFeeMutation builder.
func (m *TaxFeeMutation) Where(ps ...predicate.TaxFee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaxFeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaxFeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaxFee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaxFeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaxFeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaxFee).
func (m *TaxFeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaxFeeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, taxfee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taxfee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, taxfee.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, taxfee.FieldName)
	}
	if m.tax_fee_type != nil {
		fields = append(fields, taxfee.FieldTaxFeeType)
	}
	if m.tax_code != nil {
		fields = append(fields, taxfee.FieldTaxCode)
	}
	if m.tax_rate_type != nil {
		fields = append(fields, taxfee.FieldTaxRateType)
	}
	if m.tax_rate != nil {
		fields = append(fields, taxfee.FieldTaxRate)
	}
	if m.default_tax != nil {
		fields = append(fields, taxfee.FieldDefaultTax)
	}
	if m.merchant != nil {
		fields = append(fields, taxfee.FieldMerchantID)
	}
	if m.store != nil {
		fields = append(fields, taxfee.FieldStoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaxFeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taxfee.FieldCreatedAt:
		return m.CreatedAt()
	case taxfee.FieldUpdatedAt:
		return m.UpdatedAt()
	case taxfee.FieldDeletedAt:
		return m.DeletedAt()
	case taxfee.FieldName:
		return m.Name()
	case taxfee.FieldTaxFeeType:
		return m.TaxFeeType()
	case taxfee.FieldTaxCode:
		return m.TaxCode()
	case taxfee.FieldTaxRateType:
		return m.TaxRateType()
	case taxfee.FieldTaxRate:
		return m.TaxRate()
	case taxfee.FieldDefaultTax:
		return m.DefaultTax()
	case taxfee.FieldMerchantID:
		return m.MerchantID()
	case taxfee.FieldStoreID:
		return m.StoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaxFeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taxfee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taxfee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taxfee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case taxfee.FieldName:
		return m.OldName(ctx)
	case taxfee.FieldTaxFeeType:
		return m.OldTaxFeeType(ctx)
	case taxfee.FieldTaxCode:
		return m.OldTaxCode(ctx)
	case taxfee.FieldTaxRateType:
		return m.OldTaxRateType(ctx)
	case taxfee.FieldTaxRate:
		return m.OldTaxRate(ctx)
	case taxfee.FieldDefaultTax:
		return m.OldDefaultTax(ctx)
	case taxfee.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case taxfee.FieldStoreID:
		return m.OldStoreID(ctx)
	}
	return nil, fmt.Errorf("unknown TaxFee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaxFeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taxfee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taxfee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taxfee.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case taxfee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case taxfee.FieldTaxFeeType:
		v, ok := value.(domain.TaxFeeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxFeeType(v)
		return nil
	case taxfee.FieldTaxCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxCode(v)
		return nil
	case taxfee.FieldTaxRateType:
		v, ok := value.(domain.TaxRateType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRateType(v)
		return nil
	case taxfee.FieldTaxRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRate(v)
		return nil
	case taxfee.FieldDefaultTax:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTax(v)
		return nil
	case taxfee.FieldMerchantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case taxfee.FieldStoreID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	}
	return fmt.Errorf("unknown TaxFee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaxFeeMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, taxfee.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaxFeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taxfee.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaxFeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taxfee.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaxFee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaxFeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taxfee.FieldMerchantID) {
		fields = append(fields, taxfee.FieldMerchantID)
	}
	if m.FieldCleared(taxfee.FieldStoreID) {
		fields = append(fields, taxfee.FieldStoreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaxFeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaxFeeMutation) ClearField(name string) error {
	switch name {
	case taxfee.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case taxfee.FieldStoreID:
		m.ClearStoreID()
		return nil
	}
	return fmt.Errorf("unknown TaxFee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaxFeeMutation) ResetField(name string) error {
	switch name {
	case taxfee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taxfee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taxfee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case taxfee.FieldName:
		m.ResetName()
		return nil
	case taxfee.FieldTaxFeeType:
		m.ResetTaxFeeType()
		return nil
	case taxfee.FieldTaxCode:
		m.ResetTaxCode()
		return nil
	case taxfee.FieldTaxRateType:
		m.ResetTaxRateType()
		return nil
	case taxfee.FieldTaxRate:
		m.ResetTaxRate()
		return nil
	case taxfee.FieldDefaultTax:
		m.ResetDefaultTax()
		return nil
	case taxfee.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case taxfee.FieldStoreID:
		m.ResetStoreID()
		return nil
	}
	return fmt.Errorf("unknown TaxFee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaxFeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.merchant != nil {
		edges = append(edges, taxfee.EdgeMerchant)
	}
	if m.store != nil {
		edges = append(edges, taxfee.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaxFeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taxfee.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case taxfee.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaxFeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaxFeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaxFeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmerchant {
		edges = append(edges, taxfee.EdgeMerchant)
	}
	if m.clearedstore {
		edges = append(edges, taxfee.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaxFeeMutation) EdgeCleared(name string) bool {
	switch name {
	case taxfee.EdgeMerchant:
		return m.clearedmerchant
	case taxfee.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaxFeeMutation) ClearEdge(name string) error {
	switch name {
	case taxfee.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case taxfee.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown TaxFee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaxFeeMutation) ResetEdge(name string) error {
	switch name {
	case taxfee.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case taxfee.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown TaxFee edge %s", name)
}
