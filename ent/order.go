// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"gitlab.jiguang.dev/pos-dine/dine/domain"
	"gitlab.jiguang.dev/pos-dine/dine/ent/order"
)

// Order is the model entity for the Order schema.
type Order struct {
	config `json:"-"`
	// ID of the ent.
	// UUID as primary key
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// 删除时间
	DeletedAt int64 `json:"deleted_at,omitempty"`
	// 品牌商ID
	MerchantID uuid.UUID `json:"merchant_id,omitempty"`
	// 门店ID
	StoreID uuid.UUID `json:"store_id,omitempty"`
	// 营业日（门店营业日，字符串）
	BusinessDate string `json:"business_date,omitempty"`
	// 班次号
	ShiftNo string `json:"shift_no,omitempty"`
	// 订单号（门店内唯一可读编号）
	OrderNo string `json:"order_no,omitempty"`
	// 订单类型：SALE=销售单；REFUND=退单；PARTIAL_REFUND=部分退款单
	OrderType domain.OrderType `json:"order_type,omitempty"`
	// 退款单信息（包含原单信息与退款原因）
	Refund json.RawMessage `json:"refund,omitempty"`
	// 下单时间
	PlacedAt *time.Time `json:"placed_at,omitempty"`
	// 支付完成时间
	PaidAt *time.Time `json:"paid_at,omitempty"`
	// 完成时间
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// 下单操作员ID
	PlacedBy string `json:"placed_by,omitempty"`
	// 就餐模式：DINE_IN=堂食；TAKEAWAY=外卖（自取/配送）
	DiningMode domain.DiningMode `json:"dining_mode,omitempty"`
	// 订单业务状态：PLACED=已下单；COMPLETED=已完成；CANCELLED=已取消
	OrderStatus domain.OrderStatus `json:"order_status,omitempty"`
	// 支付状态：UNPAID=未支付；PAYING=支付中；PAID=已支付；REFUNDED=全额退款
	PaymentStatus domain.PaymentStatus `json:"payment_status,omitempty"`
	// 桌位ID（堂食）
	TableID string `json:"table_id,omitempty"`
	// 桌位名称（堂食，如A01/1号桌）
	TableName string `json:"table_name,omitempty"`
	// 用餐人数（堂食）
	GuestCount int `json:"guest_count,omitempty"`
	// 门店信息
	Store json.RawMessage `json:"store,omitempty"`
	// 下单渠道：POS/MINI_PROGRAM
	Channel order.Channel `json:"channel,omitempty"`
	// POS终端信息
	Pos json.RawMessage `json:"pos,omitempty"`
	// 收银员信息
	Cashier json.RawMessage `json:"cashier,omitempty"`
	// 税率明细
	TaxRates json.RawMessage `json:"tax_rates,omitempty"`
	// 费用明细
	Fees json.RawMessage `json:"fees,omitempty"`
	// 支付记录
	Payments json.RawMessage `json:"payments,omitempty"`
	// 金额汇总
	Amount json.RawMessage `json:"amount,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the OrderQuery when eager-loading is set.
	Edges        OrderEdges `json:"edges"`
	selectValues sql.SelectValues
}

// OrderEdges holds the relations/edges for other nodes in the graph.
type OrderEdges struct {
	// 订单商品明细
	OrderProducts []*OrderProduct `json:"order_products,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// OrderProductsOrErr returns the OrderProducts value or an error if the edge
// was not loaded in eager-loading.
func (e OrderEdges) OrderProductsOrErr() ([]*OrderProduct, error) {
	if e.loadedTypes[0] {
		return e.OrderProducts, nil
	}
	return nil, &NotLoadedError{edge: "order_products"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Order) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case order.FieldRefund, order.FieldStore, order.FieldPos, order.FieldCashier, order.FieldTaxRates, order.FieldFees, order.FieldPayments, order.FieldAmount:
			values[i] = new([]byte)
		case order.FieldDeletedAt, order.FieldGuestCount:
			values[i] = new(sql.NullInt64)
		case order.FieldBusinessDate, order.FieldShiftNo, order.FieldOrderNo, order.FieldOrderType, order.FieldPlacedBy, order.FieldDiningMode, order.FieldOrderStatus, order.FieldPaymentStatus, order.FieldTableID, order.FieldTableName, order.FieldChannel:
			values[i] = new(sql.NullString)
		case order.FieldCreatedAt, order.FieldUpdatedAt, order.FieldPlacedAt, order.FieldPaidAt, order.FieldCompletedAt:
			values[i] = new(sql.NullTime)
		case order.FieldID, order.FieldMerchantID, order.FieldStoreID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Order fields.
func (o *Order) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case order.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				o.ID = *value
			}
		case order.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				o.CreatedAt = value.Time
			}
		case order.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				o.UpdatedAt = value.Time
			}
		case order.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				o.DeletedAt = value.Int64
			}
		case order.FieldMerchantID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field merchant_id", values[i])
			} else if value != nil {
				o.MerchantID = *value
			}
		case order.FieldStoreID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field store_id", values[i])
			} else if value != nil {
				o.StoreID = *value
			}
		case order.FieldBusinessDate:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field business_date", values[i])
			} else if value.Valid {
				o.BusinessDate = value.String
			}
		case order.FieldShiftNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field shift_no", values[i])
			} else if value.Valid {
				o.ShiftNo = value.String
			}
		case order.FieldOrderNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field order_no", values[i])
			} else if value.Valid {
				o.OrderNo = value.String
			}
		case order.FieldOrderType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field order_type", values[i])
			} else if value.Valid {
				o.OrderType = domain.OrderType(value.String)
			}
		case order.FieldRefund:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field refund", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Refund); err != nil {
					return fmt.Errorf("unmarshal field refund: %w", err)
				}
			}
		case order.FieldPlacedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field placed_at", values[i])
			} else if value.Valid {
				o.PlacedAt = new(time.Time)
				*o.PlacedAt = value.Time
			}
		case order.FieldPaidAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field paid_at", values[i])
			} else if value.Valid {
				o.PaidAt = new(time.Time)
				*o.PaidAt = value.Time
			}
		case order.FieldCompletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field completed_at", values[i])
			} else if value.Valid {
				o.CompletedAt = new(time.Time)
				*o.CompletedAt = value.Time
			}
		case order.FieldPlacedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field placed_by", values[i])
			} else if value.Valid {
				o.PlacedBy = value.String
			}
		case order.FieldDiningMode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dining_mode", values[i])
			} else if value.Valid {
				o.DiningMode = domain.DiningMode(value.String)
			}
		case order.FieldOrderStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field order_status", values[i])
			} else if value.Valid {
				o.OrderStatus = domain.OrderStatus(value.String)
			}
		case order.FieldPaymentStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field payment_status", values[i])
			} else if value.Valid {
				o.PaymentStatus = domain.PaymentStatus(value.String)
			}
		case order.FieldTableID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field table_id", values[i])
			} else if value.Valid {
				o.TableID = value.String
			}
		case order.FieldTableName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field table_name", values[i])
			} else if value.Valid {
				o.TableName = value.String
			}
		case order.FieldGuestCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field guest_count", values[i])
			} else if value.Valid {
				o.GuestCount = int(value.Int64)
			}
		case order.FieldStore:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field store", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Store); err != nil {
					return fmt.Errorf("unmarshal field store: %w", err)
				}
			}
		case order.FieldChannel:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field channel", values[i])
			} else if value.Valid {
				o.Channel = order.Channel(value.String)
			}
		case order.FieldPos:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field pos", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Pos); err != nil {
					return fmt.Errorf("unmarshal field pos: %w", err)
				}
			}
		case order.FieldCashier:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field cashier", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Cashier); err != nil {
					return fmt.Errorf("unmarshal field cashier: %w", err)
				}
			}
		case order.FieldTaxRates:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tax_rates", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.TaxRates); err != nil {
					return fmt.Errorf("unmarshal field tax_rates: %w", err)
				}
			}
		case order.FieldFees:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field fees", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Fees); err != nil {
					return fmt.Errorf("unmarshal field fees: %w", err)
				}
			}
		case order.FieldPayments:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field payments", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Payments); err != nil {
					return fmt.Errorf("unmarshal field payments: %w", err)
				}
			}
		case order.FieldAmount:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field amount", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.Amount); err != nil {
					return fmt.Errorf("unmarshal field amount: %w", err)
				}
			}
		default:
			o.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Order.
// This includes values selected through modifiers, order, etc.
func (o *Order) Value(name string) (ent.Value, error) {
	return o.selectValues.Get(name)
}

// QueryOrderProducts queries the "order_products" edge of the Order entity.
func (o *Order) QueryOrderProducts() *OrderProductQuery {
	return NewOrderClient(o.config).QueryOrderProducts(o)
}

// Update returns a builder for updating this Order.
// Note that you need to call Order.Unwrap() before calling this method if this Order
// was returned from a transaction, and the transaction was committed or rolled back.
func (o *Order) Update() *OrderUpdateOne {
	return NewOrderClient(o.config).UpdateOne(o)
}

// Unwrap unwraps the Order entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (o *Order) Unwrap() *Order {
	_tx, ok := o.config.driver.(*txDriver)
	if !ok {
		panic("ent: Order is not a transactional entity")
	}
	o.config.driver = _tx.drv
	return o
}

// String implements the fmt.Stringer.
func (o *Order) String() string {
	var builder strings.Builder
	builder.WriteString("Order(")
	builder.WriteString(fmt.Sprintf("id=%v, ", o.ID))
	builder.WriteString("created_at=")
	builder.WriteString(o.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(o.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(fmt.Sprintf("%v", o.DeletedAt))
	builder.WriteString(", ")
	builder.WriteString("merchant_id=")
	builder.WriteString(fmt.Sprintf("%v", o.MerchantID))
	builder.WriteString(", ")
	builder.WriteString("store_id=")
	builder.WriteString(fmt.Sprintf("%v", o.StoreID))
	builder.WriteString(", ")
	builder.WriteString("business_date=")
	builder.WriteString(o.BusinessDate)
	builder.WriteString(", ")
	builder.WriteString("shift_no=")
	builder.WriteString(o.ShiftNo)
	builder.WriteString(", ")
	builder.WriteString("order_no=")
	builder.WriteString(o.OrderNo)
	builder.WriteString(", ")
	builder.WriteString("order_type=")
	builder.WriteString(fmt.Sprintf("%v", o.OrderType))
	builder.WriteString(", ")
	builder.WriteString("refund=")
	builder.WriteString(fmt.Sprintf("%v", o.Refund))
	builder.WriteString(", ")
	if v := o.PlacedAt; v != nil {
		builder.WriteString("placed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := o.PaidAt; v != nil {
		builder.WriteString("paid_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := o.CompletedAt; v != nil {
		builder.WriteString("completed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("placed_by=")
	builder.WriteString(o.PlacedBy)
	builder.WriteString(", ")
	builder.WriteString("dining_mode=")
	builder.WriteString(fmt.Sprintf("%v", o.DiningMode))
	builder.WriteString(", ")
	builder.WriteString("order_status=")
	builder.WriteString(fmt.Sprintf("%v", o.OrderStatus))
	builder.WriteString(", ")
	builder.WriteString("payment_status=")
	builder.WriteString(fmt.Sprintf("%v", o.PaymentStatus))
	builder.WriteString(", ")
	builder.WriteString("table_id=")
	builder.WriteString(o.TableID)
	builder.WriteString(", ")
	builder.WriteString("table_name=")
	builder.WriteString(o.TableName)
	builder.WriteString(", ")
	builder.WriteString("guest_count=")
	builder.WriteString(fmt.Sprintf("%v", o.GuestCount))
	builder.WriteString(", ")
	builder.WriteString("store=")
	builder.WriteString(fmt.Sprintf("%v", o.Store))
	builder.WriteString(", ")
	builder.WriteString("channel=")
	builder.WriteString(fmt.Sprintf("%v", o.Channel))
	builder.WriteString(", ")
	builder.WriteString("pos=")
	builder.WriteString(fmt.Sprintf("%v", o.Pos))
	builder.WriteString(", ")
	builder.WriteString("cashier=")
	builder.WriteString(fmt.Sprintf("%v", o.Cashier))
	builder.WriteString(", ")
	builder.WriteString("tax_rates=")
	builder.WriteString(fmt.Sprintf("%v", o.TaxRates))
	builder.WriteString(", ")
	builder.WriteString("fees=")
	builder.WriteString(fmt.Sprintf("%v", o.Fees))
	builder.WriteString(", ")
	builder.WriteString("payments=")
	builder.WriteString(fmt.Sprintf("%v", o.Payments))
	builder.WriteString(", ")
	builder.WriteString("amount=")
	builder.WriteString(fmt.Sprintf("%v", o.Amount))
	builder.WriteByte(')')
	return builder.String()
}

// Orders is a parsable slice of Order.
type Orders []*Order
