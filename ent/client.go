// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"gitlab.jiguang.dev/pos-dine/dine/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"gitlab.jiguang.dev/pos-dine/dine/ent/adminuser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/attr"
	"gitlab.jiguang.dev/pos-dine/dine/ent/backenduser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/category"
	"gitlab.jiguang.dev/pos-dine/dine/ent/customer"
	"gitlab.jiguang.dev/pos-dine/dine/ent/dataexport"
	"gitlab.jiguang.dev/pos-dine/dine/ent/dinetable"
	"gitlab.jiguang.dev/pos-dine/dine/ent/frontenduser"
	"gitlab.jiguang.dev/pos-dine/dine/ent/order"
	"gitlab.jiguang.dev/pos-dine/dine/ent/ordercart"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderfinancelog"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderitem"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderitemsetmealdetail"
	"gitlab.jiguang.dev/pos-dine/dine/ent/orderlog"
	"gitlab.jiguang.dev/pos-dine/dine/ent/payment"
	"gitlab.jiguang.dev/pos-dine/dine/ent/paymentcallback"
	"gitlab.jiguang.dev/pos-dine/dine/ent/pointsettlement"
	"gitlab.jiguang.dev/pos-dine/dine/ent/product"
	"gitlab.jiguang.dev/pos-dine/dine/ent/productspec"
	"gitlab.jiguang.dev/pos-dine/dine/ent/recipe"
	"gitlab.jiguang.dev/pos-dine/dine/ent/reconciliationrecord"
	"gitlab.jiguang.dev/pos-dine/dine/ent/setmealdetail"
	"gitlab.jiguang.dev/pos-dine/dine/ent/spec"
	"gitlab.jiguang.dev/pos-dine/dine/ent/store"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeaccount"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeaccounttransaction"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storefinance"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storeinfo"
	"gitlab.jiguang.dev/pos-dine/dine/ent/storewithdraw"
	"gitlab.jiguang.dev/pos-dine/dine/ent/tablearea"
	"gitlab.jiguang.dev/pos-dine/dine/ent/unit"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AdminUser is the client for interacting with the AdminUser builders.
	AdminUser *AdminUserClient
	// Attr is the client for interacting with the Attr builders.
	Attr *AttrClient
	// BackendUser is the client for interacting with the BackendUser builders.
	BackendUser *BackendUserClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// DataExport is the client for interacting with the DataExport builders.
	DataExport *DataExportClient
	// DineTable is the client for interacting with the DineTable builders.
	DineTable *DineTableClient
	// FrontendUser is the client for interacting with the FrontendUser builders.
	FrontendUser *FrontendUserClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderCart is the client for interacting with the OrderCart builders.
	OrderCart *OrderCartClient
	// OrderFinanceLog is the client for interacting with the OrderFinanceLog builders.
	OrderFinanceLog *OrderFinanceLogClient
	// OrderItem is the client for interacting with the OrderItem builders.
	OrderItem *OrderItemClient
	// OrderItemSetMealDetail is the client for interacting with the OrderItemSetMealDetail builders.
	OrderItemSetMealDetail *OrderItemSetMealDetailClient
	// OrderLog is the client for interacting with the OrderLog builders.
	OrderLog *OrderLogClient
	// Payment is the client for interacting with the Payment builders.
	Payment *PaymentClient
	// PaymentCallback is the client for interacting with the PaymentCallback builders.
	PaymentCallback *PaymentCallbackClient
	// PointSettlement is the client for interacting with the PointSettlement builders.
	PointSettlement *PointSettlementClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductSpec is the client for interacting with the ProductSpec builders.
	ProductSpec *ProductSpecClient
	// Recipe is the client for interacting with the Recipe builders.
	Recipe *RecipeClient
	// ReconciliationRecord is the client for interacting with the ReconciliationRecord builders.
	ReconciliationRecord *ReconciliationRecordClient
	// SetMealDetail is the client for interacting with the SetMealDetail builders.
	SetMealDetail *SetMealDetailClient
	// Spec is the client for interacting with the Spec builders.
	Spec *SpecClient
	// Store is the client for interacting with the Store builders.
	Store *StoreClient
	// StoreAccount is the client for interacting with the StoreAccount builders.
	StoreAccount *StoreAccountClient
	// StoreAccountTransaction is the client for interacting with the StoreAccountTransaction builders.
	StoreAccountTransaction *StoreAccountTransactionClient
	// StoreFinance is the client for interacting with the StoreFinance builders.
	StoreFinance *StoreFinanceClient
	// StoreInfo is the client for interacting with the StoreInfo builders.
	StoreInfo *StoreInfoClient
	// StoreWithdraw is the client for interacting with the StoreWithdraw builders.
	StoreWithdraw *StoreWithdrawClient
	// TableArea is the client for interacting with the TableArea builders.
	TableArea *TableAreaClient
	// Unit is the client for interacting with the Unit builders.
	Unit *UnitClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AdminUser = NewAdminUserClient(c.config)
	c.Attr = NewAttrClient(c.config)
	c.BackendUser = NewBackendUserClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.DataExport = NewDataExportClient(c.config)
	c.DineTable = NewDineTableClient(c.config)
	c.FrontendUser = NewFrontendUserClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderCart = NewOrderCartClient(c.config)
	c.OrderFinanceLog = NewOrderFinanceLogClient(c.config)
	c.OrderItem = NewOrderItemClient(c.config)
	c.OrderItemSetMealDetail = NewOrderItemSetMealDetailClient(c.config)
	c.OrderLog = NewOrderLogClient(c.config)
	c.Payment = NewPaymentClient(c.config)
	c.PaymentCallback = NewPaymentCallbackClient(c.config)
	c.PointSettlement = NewPointSettlementClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductSpec = NewProductSpecClient(c.config)
	c.Recipe = NewRecipeClient(c.config)
	c.ReconciliationRecord = NewReconciliationRecordClient(c.config)
	c.SetMealDetail = NewSetMealDetailClient(c.config)
	c.Spec = NewSpecClient(c.config)
	c.Store = NewStoreClient(c.config)
	c.StoreAccount = NewStoreAccountClient(c.config)
	c.StoreAccountTransaction = NewStoreAccountTransactionClient(c.config)
	c.StoreFinance = NewStoreFinanceClient(c.config)
	c.StoreInfo = NewStoreInfoClient(c.config)
	c.StoreWithdraw = NewStoreWithdrawClient(c.config)
	c.TableArea = NewTableAreaClient(c.config)
	c.Unit = NewUnitClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AdminUser:               NewAdminUserClient(cfg),
		Attr:                    NewAttrClient(cfg),
		BackendUser:             NewBackendUserClient(cfg),
		Category:                NewCategoryClient(cfg),
		Customer:                NewCustomerClient(cfg),
		DataExport:              NewDataExportClient(cfg),
		DineTable:               NewDineTableClient(cfg),
		FrontendUser:            NewFrontendUserClient(cfg),
		Order:                   NewOrderClient(cfg),
		OrderCart:               NewOrderCartClient(cfg),
		OrderFinanceLog:         NewOrderFinanceLogClient(cfg),
		OrderItem:               NewOrderItemClient(cfg),
		OrderItemSetMealDetail:  NewOrderItemSetMealDetailClient(cfg),
		OrderLog:                NewOrderLogClient(cfg),
		Payment:                 NewPaymentClient(cfg),
		PaymentCallback:         NewPaymentCallbackClient(cfg),
		PointSettlement:         NewPointSettlementClient(cfg),
		Product:                 NewProductClient(cfg),
		ProductSpec:             NewProductSpecClient(cfg),
		Recipe:                  NewRecipeClient(cfg),
		ReconciliationRecord:    NewReconciliationRecordClient(cfg),
		SetMealDetail:           NewSetMealDetailClient(cfg),
		Spec:                    NewSpecClient(cfg),
		Store:                   NewStoreClient(cfg),
		StoreAccount:            NewStoreAccountClient(cfg),
		StoreAccountTransaction: NewStoreAccountTransactionClient(cfg),
		StoreFinance:            NewStoreFinanceClient(cfg),
		StoreInfo:               NewStoreInfoClient(cfg),
		StoreWithdraw:           NewStoreWithdrawClient(cfg),
		TableArea:               NewTableAreaClient(cfg),
		Unit:                    NewUnitClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AdminUser:               NewAdminUserClient(cfg),
		Attr:                    NewAttrClient(cfg),
		BackendUser:             NewBackendUserClient(cfg),
		Category:                NewCategoryClient(cfg),
		Customer:                NewCustomerClient(cfg),
		DataExport:              NewDataExportClient(cfg),
		DineTable:               NewDineTableClient(cfg),
		FrontendUser:            NewFrontendUserClient(cfg),
		Order:                   NewOrderClient(cfg),
		OrderCart:               NewOrderCartClient(cfg),
		OrderFinanceLog:         NewOrderFinanceLogClient(cfg),
		OrderItem:               NewOrderItemClient(cfg),
		OrderItemSetMealDetail:  NewOrderItemSetMealDetailClient(cfg),
		OrderLog:                NewOrderLogClient(cfg),
		Payment:                 NewPaymentClient(cfg),
		PaymentCallback:         NewPaymentCallbackClient(cfg),
		PointSettlement:         NewPointSettlementClient(cfg),
		Product:                 NewProductClient(cfg),
		ProductSpec:             NewProductSpecClient(cfg),
		Recipe:                  NewRecipeClient(cfg),
		ReconciliationRecord:    NewReconciliationRecordClient(cfg),
		SetMealDetail:           NewSetMealDetailClient(cfg),
		Spec:                    NewSpecClient(cfg),
		Store:                   NewStoreClient(cfg),
		StoreAccount:            NewStoreAccountClient(cfg),
		StoreAccountTransaction: NewStoreAccountTransactionClient(cfg),
		StoreFinance:            NewStoreFinanceClient(cfg),
		StoreInfo:               NewStoreInfoClient(cfg),
		StoreWithdraw:           NewStoreWithdrawClient(cfg),
		TableArea:               NewTableAreaClient(cfg),
		Unit:                    NewUnitClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AdminUser.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AdminUser, c.Attr, c.BackendUser, c.Category, c.Customer, c.DataExport,
		c.DineTable, c.FrontendUser, c.Order, c.OrderCart, c.OrderFinanceLog,
		c.OrderItem, c.OrderItemSetMealDetail, c.OrderLog, c.Payment,
		c.PaymentCallback, c.PointSettlement, c.Product, c.ProductSpec, c.Recipe,
		c.ReconciliationRecord, c.SetMealDetail, c.Spec, c.Store, c.StoreAccount,
		c.StoreAccountTransaction, c.StoreFinance, c.StoreInfo, c.StoreWithdraw,
		c.TableArea, c.Unit,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AdminUser, c.Attr, c.BackendUser, c.Category, c.Customer, c.DataExport,
		c.DineTable, c.FrontendUser, c.Order, c.OrderCart, c.OrderFinanceLog,
		c.OrderItem, c.OrderItemSetMealDetail, c.OrderLog, c.Payment,
		c.PaymentCallback, c.PointSettlement, c.Product, c.ProductSpec, c.Recipe,
		c.ReconciliationRecord, c.SetMealDetail, c.Spec, c.Store, c.StoreAccount,
		c.StoreAccountTransaction, c.StoreFinance, c.StoreInfo, c.StoreWithdraw,
		c.TableArea, c.Unit,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdminUserMutation:
		return c.AdminUser.mutate(ctx, m)
	case *AttrMutation:
		return c.Attr.mutate(ctx, m)
	case *BackendUserMutation:
		return c.BackendUser.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *CustomerMutation:
		return c.Customer.mutate(ctx, m)
	case *DataExportMutation:
		return c.DataExport.mutate(ctx, m)
	case *DineTableMutation:
		return c.DineTable.mutate(ctx, m)
	case *FrontendUserMutation:
		return c.FrontendUser.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderCartMutation:
		return c.OrderCart.mutate(ctx, m)
	case *OrderFinanceLogMutation:
		return c.OrderFinanceLog.mutate(ctx, m)
	case *OrderItemMutation:
		return c.OrderItem.mutate(ctx, m)
	case *OrderItemSetMealDetailMutation:
		return c.OrderItemSetMealDetail.mutate(ctx, m)
	case *OrderLogMutation:
		return c.OrderLog.mutate(ctx, m)
	case *PaymentMutation:
		return c.Payment.mutate(ctx, m)
	case *PaymentCallbackMutation:
		return c.PaymentCallback.mutate(ctx, m)
	case *PointSettlementMutation:
		return c.PointSettlement.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductSpecMutation:
		return c.ProductSpec.mutate(ctx, m)
	case *RecipeMutation:
		return c.Recipe.mutate(ctx, m)
	case *ReconciliationRecordMutation:
		return c.ReconciliationRecord.mutate(ctx, m)
	case *SetMealDetailMutation:
		return c.SetMealDetail.mutate(ctx, m)
	case *SpecMutation:
		return c.Spec.mutate(ctx, m)
	case *StoreMutation:
		return c.Store.mutate(ctx, m)
	case *StoreAccountMutation:
		return c.StoreAccount.mutate(ctx, m)
	case *StoreAccountTransactionMutation:
		return c.StoreAccountTransaction.mutate(ctx, m)
	case *StoreFinanceMutation:
		return c.StoreFinance.mutate(ctx, m)
	case *StoreInfoMutation:
		return c.StoreInfo.mutate(ctx, m)
	case *StoreWithdrawMutation:
		return c.StoreWithdraw.mutate(ctx, m)
	case *TableAreaMutation:
		return c.TableArea.mutate(ctx, m)
	case *UnitMutation:
		return c.Unit.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdminUserClient is a client for the AdminUser schema.
type AdminUserClient struct {
	config
}

// NewAdminUserClient returns a client for the AdminUser from the given config.
func NewAdminUserClient(c config) *AdminUserClient {
	return &AdminUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adminuser.Hooks(f(g(h())))`.
func (c *AdminUserClient) Use(hooks ...Hook) {
	c.hooks.AdminUser = append(c.hooks.AdminUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `adminuser.Intercept(f(g(h())))`.
func (c *AdminUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AdminUser = append(c.inters.AdminUser, interceptors...)
}

// Create returns a builder for creating a AdminUser entity.
func (c *AdminUserClient) Create() *AdminUserCreate {
	mutation := newAdminUserMutation(c.config, OpCreate)
	return &AdminUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AdminUser entities.
func (c *AdminUserClient) CreateBulk(builders ...*AdminUserCreate) *AdminUserCreateBulk {
	return &AdminUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AdminUserClient) MapCreateBulk(slice any, setFunc func(*AdminUserCreate, int)) *AdminUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AdminUserCreateBulk{err: fmt.Errorf("calling to AdminUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AdminUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AdminUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AdminUser.
func (c *AdminUserClient) Update() *AdminUserUpdate {
	mutation := newAdminUserMutation(c.config, OpUpdate)
	return &AdminUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminUserClient) UpdateOne(au *AdminUser) *AdminUserUpdateOne {
	mutation := newAdminUserMutation(c.config, OpUpdateOne, withAdminUser(au))
	return &AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminUserClient) UpdateOneID(id int) *AdminUserUpdateOne {
	mutation := newAdminUserMutation(c.config, OpUpdateOne, withAdminUserID(id))
	return &AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AdminUser.
func (c *AdminUserClient) Delete() *AdminUserDelete {
	mutation := newAdminUserMutation(c.config, OpDelete)
	return &AdminUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdminUserClient) DeleteOne(au *AdminUser) *AdminUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdminUserClient) DeleteOneID(id int) *AdminUserDeleteOne {
	builder := c.Delete().Where(adminuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminUserDeleteOne{builder}
}

// Query returns a query builder for AdminUser.
func (c *AdminUserClient) Query() *AdminUserQuery {
	return &AdminUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAdminUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AdminUser entity by its id.
func (c *AdminUserClient) Get(ctx context.Context, id int) (*AdminUser, error) {
	return c.Query().Where(adminuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminUserClient) GetX(ctx context.Context, id int) *AdminUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AdminUserClient) Hooks() []Hook {
	hooks := c.hooks.AdminUser
	return append(hooks[:len(hooks):len(hooks)], adminuser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AdminUserClient) Interceptors() []Interceptor {
	inters := c.inters.AdminUser
	return append(inters[:len(inters):len(inters)], adminuser.Interceptors[:]...)
}

func (c *AdminUserClient) mutate(ctx context.Context, m *AdminUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdminUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdminUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdminUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AdminUser mutation op: %q", m.Op())
	}
}

// AttrClient is a client for the Attr schema.
type AttrClient struct {
	config
}

// NewAttrClient returns a client for the Attr from the given config.
func NewAttrClient(c config) *AttrClient {
	return &AttrClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attr.Hooks(f(g(h())))`.
func (c *AttrClient) Use(hooks ...Hook) {
	c.hooks.Attr = append(c.hooks.Attr, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attr.Intercept(f(g(h())))`.
func (c *AttrClient) Intercept(interceptors ...Interceptor) {
	c.inters.Attr = append(c.inters.Attr, interceptors...)
}

// Create returns a builder for creating a Attr entity.
func (c *AttrClient) Create() *AttrCreate {
	mutation := newAttrMutation(c.config, OpCreate)
	return &AttrCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attr entities.
func (c *AttrClient) CreateBulk(builders ...*AttrCreate) *AttrCreateBulk {
	return &AttrCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttrClient) MapCreateBulk(slice any, setFunc func(*AttrCreate, int)) *AttrCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttrCreateBulk{err: fmt.Errorf("calling to AttrClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttrCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttrCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attr.
func (c *AttrClient) Update() *AttrUpdate {
	mutation := newAttrMutation(c.config, OpUpdate)
	return &AttrUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttrClient) UpdateOne(a *Attr) *AttrUpdateOne {
	mutation := newAttrMutation(c.config, OpUpdateOne, withAttr(a))
	return &AttrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttrClient) UpdateOneID(id int) *AttrUpdateOne {
	mutation := newAttrMutation(c.config, OpUpdateOne, withAttrID(id))
	return &AttrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attr.
func (c *AttrClient) Delete() *AttrDelete {
	mutation := newAttrMutation(c.config, OpDelete)
	return &AttrDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttrClient) DeleteOne(a *Attr) *AttrDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttrClient) DeleteOneID(id int) *AttrDeleteOne {
	builder := c.Delete().Where(attr.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttrDeleteOne{builder}
}

// Query returns a query builder for Attr.
func (c *AttrClient) Query() *AttrQuery {
	return &AttrQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttr},
		inters: c.Interceptors(),
	}
}

// Get returns a Attr entity by its id.
func (c *AttrClient) Get(ctx context.Context, id int) (*Attr, error) {
	return c.Query().Where(attr.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttrClient) GetX(ctx context.Context, id int) *Attr {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Attr.
func (c *AttrClient) QueryProducts(a *Attr) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attr.Table, attr.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, attr.ProductsTable, attr.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderCartItems queries the order_cart_items edge of a Attr.
func (c *AttrClient) QueryOrderCartItems(a *Attr) *OrderCartQuery {
	query := (&OrderCartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attr.Table, attr.FieldID, id),
			sqlgraph.To(ordercart.Table, ordercart.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, attr.OrderCartItemsTable, attr.OrderCartItemsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttrClient) Hooks() []Hook {
	hooks := c.hooks.Attr
	return append(hooks[:len(hooks):len(hooks)], attr.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AttrClient) Interceptors() []Interceptor {
	inters := c.inters.Attr
	return append(inters[:len(inters):len(inters)], attr.Interceptors[:]...)
}

func (c *AttrClient) mutate(ctx context.Context, m *AttrMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttrCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttrUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttrDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Attr mutation op: %q", m.Op())
	}
}

// BackendUserClient is a client for the BackendUser schema.
type BackendUserClient struct {
	config
}

// NewBackendUserClient returns a client for the BackendUser from the given config.
func NewBackendUserClient(c config) *BackendUserClient {
	return &BackendUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `backenduser.Hooks(f(g(h())))`.
func (c *BackendUserClient) Use(hooks ...Hook) {
	c.hooks.BackendUser = append(c.hooks.BackendUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `backenduser.Intercept(f(g(h())))`.
func (c *BackendUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.BackendUser = append(c.inters.BackendUser, interceptors...)
}

// Create returns a builder for creating a BackendUser entity.
func (c *BackendUserClient) Create() *BackendUserCreate {
	mutation := newBackendUserMutation(c.config, OpCreate)
	return &BackendUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BackendUser entities.
func (c *BackendUserClient) CreateBulk(builders ...*BackendUserCreate) *BackendUserCreateBulk {
	return &BackendUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BackendUserClient) MapCreateBulk(slice any, setFunc func(*BackendUserCreate, int)) *BackendUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BackendUserCreateBulk{err: fmt.Errorf("calling to BackendUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BackendUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BackendUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BackendUser.
func (c *BackendUserClient) Update() *BackendUserUpdate {
	mutation := newBackendUserMutation(c.config, OpUpdate)
	return &BackendUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BackendUserClient) UpdateOne(bu *BackendUser) *BackendUserUpdateOne {
	mutation := newBackendUserMutation(c.config, OpUpdateOne, withBackendUser(bu))
	return &BackendUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BackendUserClient) UpdateOneID(id int) *BackendUserUpdateOne {
	mutation := newBackendUserMutation(c.config, OpUpdateOne, withBackendUserID(id))
	return &BackendUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BackendUser.
func (c *BackendUserClient) Delete() *BackendUserDelete {
	mutation := newBackendUserMutation(c.config, OpDelete)
	return &BackendUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BackendUserClient) DeleteOne(bu *BackendUser) *BackendUserDeleteOne {
	return c.DeleteOneID(bu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BackendUserClient) DeleteOneID(id int) *BackendUserDeleteOne {
	builder := c.Delete().Where(backenduser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BackendUserDeleteOne{builder}
}

// Query returns a query builder for BackendUser.
func (c *BackendUserClient) Query() *BackendUserQuery {
	return &BackendUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBackendUser},
		inters: c.Interceptors(),
	}
}

// Get returns a BackendUser entity by its id.
func (c *BackendUserClient) Get(ctx context.Context, id int) (*BackendUser, error) {
	return c.Query().Where(backenduser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BackendUserClient) GetX(ctx context.Context, id int) *BackendUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a BackendUser.
func (c *BackendUserClient) QueryStore(bu *BackendUser) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(backenduser.Table, backenduser.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, backenduser.StoreTable, backenduser.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(bu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BackendUserClient) Hooks() []Hook {
	hooks := c.hooks.BackendUser
	return append(hooks[:len(hooks):len(hooks)], backenduser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BackendUserClient) Interceptors() []Interceptor {
	inters := c.inters.BackendUser
	return append(inters[:len(inters):len(inters)], backenduser.Interceptors[:]...)
}

func (c *BackendUserClient) mutate(ctx context.Context, m *BackendUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BackendUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BackendUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BackendUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BackendUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BackendUser mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Category.
func (c *CategoryClient) QueryProducts(ca *Category) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.ProductsTable, category.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	hooks := c.hooks.Category
	return append(hooks[:len(hooks):len(hooks)], category.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	inters := c.inters.Category
	return append(inters[:len(inters):len(inters)], category.Interceptors[:]...)
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customer.Intercept(f(g(h())))`.
func (c *CustomerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Customer = append(c.inters.Customer, interceptors...)
}

// Create returns a builder for creating a Customer entity.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Customer entities.
func (c *CustomerClient) CreateBulk(builders ...*CustomerCreate) *CustomerCreateBulk {
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerClient) MapCreateBulk(slice any, setFunc func(*CustomerCreate, int)) *CustomerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerCreateBulk{err: fmt.Errorf("calling to CustomerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Query returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomer},
		inters: c.Interceptors(),
	}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	hooks := c.hooks.Customer
	return append(hooks[:len(hooks):len(hooks)], customer.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CustomerClient) Interceptors() []Interceptor {
	inters := c.inters.Customer
	return append(inters[:len(inters):len(inters)], customer.Interceptors[:]...)
}

func (c *CustomerClient) mutate(ctx context.Context, m *CustomerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Customer mutation op: %q", m.Op())
	}
}

// DataExportClient is a client for the DataExport schema.
type DataExportClient struct {
	config
}

// NewDataExportClient returns a client for the DataExport from the given config.
func NewDataExportClient(c config) *DataExportClient {
	return &DataExportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dataexport.Hooks(f(g(h())))`.
func (c *DataExportClient) Use(hooks ...Hook) {
	c.hooks.DataExport = append(c.hooks.DataExport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dataexport.Intercept(f(g(h())))`.
func (c *DataExportClient) Intercept(interceptors ...Interceptor) {
	c.inters.DataExport = append(c.inters.DataExport, interceptors...)
}

// Create returns a builder for creating a DataExport entity.
func (c *DataExportClient) Create() *DataExportCreate {
	mutation := newDataExportMutation(c.config, OpCreate)
	return &DataExportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DataExport entities.
func (c *DataExportClient) CreateBulk(builders ...*DataExportCreate) *DataExportCreateBulk {
	return &DataExportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DataExportClient) MapCreateBulk(slice any, setFunc func(*DataExportCreate, int)) *DataExportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DataExportCreateBulk{err: fmt.Errorf("calling to DataExportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DataExportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DataExportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DataExport.
func (c *DataExportClient) Update() *DataExportUpdate {
	mutation := newDataExportMutation(c.config, OpUpdate)
	return &DataExportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DataExportClient) UpdateOne(de *DataExport) *DataExportUpdateOne {
	mutation := newDataExportMutation(c.config, OpUpdateOne, withDataExport(de))
	return &DataExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DataExportClient) UpdateOneID(id int) *DataExportUpdateOne {
	mutation := newDataExportMutation(c.config, OpUpdateOne, withDataExportID(id))
	return &DataExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DataExport.
func (c *DataExportClient) Delete() *DataExportDelete {
	mutation := newDataExportMutation(c.config, OpDelete)
	return &DataExportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DataExportClient) DeleteOne(de *DataExport) *DataExportDeleteOne {
	return c.DeleteOneID(de.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DataExportClient) DeleteOneID(id int) *DataExportDeleteOne {
	builder := c.Delete().Where(dataexport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DataExportDeleteOne{builder}
}

// Query returns a query builder for DataExport.
func (c *DataExportClient) Query() *DataExportQuery {
	return &DataExportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDataExport},
		inters: c.Interceptors(),
	}
}

// Get returns a DataExport entity by its id.
func (c *DataExportClient) Get(ctx context.Context, id int) (*DataExport, error) {
	return c.Query().Where(dataexport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DataExportClient) GetX(ctx context.Context, id int) *DataExport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DataExportClient) Hooks() []Hook {
	hooks := c.hooks.DataExport
	return append(hooks[:len(hooks):len(hooks)], dataexport.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DataExportClient) Interceptors() []Interceptor {
	inters := c.inters.DataExport
	return append(inters[:len(inters):len(inters)], dataexport.Interceptors[:]...)
}

func (c *DataExportClient) mutate(ctx context.Context, m *DataExportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DataExportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DataExportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DataExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DataExportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DataExport mutation op: %q", m.Op())
	}
}

// DineTableClient is a client for the DineTable schema.
type DineTableClient struct {
	config
}

// NewDineTableClient returns a client for the DineTable from the given config.
func NewDineTableClient(c config) *DineTableClient {
	return &DineTableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dinetable.Hooks(f(g(h())))`.
func (c *DineTableClient) Use(hooks ...Hook) {
	c.hooks.DineTable = append(c.hooks.DineTable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dinetable.Intercept(f(g(h())))`.
func (c *DineTableClient) Intercept(interceptors ...Interceptor) {
	c.inters.DineTable = append(c.inters.DineTable, interceptors...)
}

// Create returns a builder for creating a DineTable entity.
func (c *DineTableClient) Create() *DineTableCreate {
	mutation := newDineTableMutation(c.config, OpCreate)
	return &DineTableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DineTable entities.
func (c *DineTableClient) CreateBulk(builders ...*DineTableCreate) *DineTableCreateBulk {
	return &DineTableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DineTableClient) MapCreateBulk(slice any, setFunc func(*DineTableCreate, int)) *DineTableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DineTableCreateBulk{err: fmt.Errorf("calling to DineTableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DineTableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DineTableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DineTable.
func (c *DineTableClient) Update() *DineTableUpdate {
	mutation := newDineTableMutation(c.config, OpUpdate)
	return &DineTableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DineTableClient) UpdateOne(dt *DineTable) *DineTableUpdateOne {
	mutation := newDineTableMutation(c.config, OpUpdateOne, withDineTable(dt))
	return &DineTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DineTableClient) UpdateOneID(id int) *DineTableUpdateOne {
	mutation := newDineTableMutation(c.config, OpUpdateOne, withDineTableID(id))
	return &DineTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DineTable.
func (c *DineTableClient) Delete() *DineTableDelete {
	mutation := newDineTableMutation(c.config, OpDelete)
	return &DineTableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DineTableClient) DeleteOne(dt *DineTable) *DineTableDeleteOne {
	return c.DeleteOneID(dt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DineTableClient) DeleteOneID(id int) *DineTableDeleteOne {
	builder := c.Delete().Where(dinetable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DineTableDeleteOne{builder}
}

// Query returns a query builder for DineTable.
func (c *DineTableClient) Query() *DineTableQuery {
	return &DineTableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDineTable},
		inters: c.Interceptors(),
	}
}

// Get returns a DineTable entity by its id.
func (c *DineTableClient) Get(ctx context.Context, id int) (*DineTable, error) {
	return c.Query().Where(dinetable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DineTableClient) GetX(ctx context.Context, id int) *DineTable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTablearea queries the tablearea edge of a DineTable.
func (c *DineTableClient) QueryTablearea(dt *DineTable) *TableAreaQuery {
	query := (&TableAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dinetable.Table, dinetable.FieldID, id),
			sqlgraph.To(tablearea.Table, tablearea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dinetable.TableareaTable, dinetable.TableareaColumn),
		)
		fromV = sqlgraph.Neighbors(dt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrder queries the order edge of a DineTable.
func (c *DineTableClient) QueryOrder(dt *DineTable) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dinetable.Table, dinetable.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, dinetable.OrderTable, dinetable.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(dt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a DineTable.
func (c *DineTableClient) QueryOrders(dt *DineTable) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dinetable.Table, dinetable.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dinetable.OrdersTable, dinetable.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(dt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DineTableClient) Hooks() []Hook {
	hooks := c.hooks.DineTable
	return append(hooks[:len(hooks):len(hooks)], dinetable.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DineTableClient) Interceptors() []Interceptor {
	inters := c.inters.DineTable
	return append(inters[:len(inters):len(inters)], dinetable.Interceptors[:]...)
}

func (c *DineTableClient) mutate(ctx context.Context, m *DineTableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DineTableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DineTableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DineTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DineTableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DineTable mutation op: %q", m.Op())
	}
}

// FrontendUserClient is a client for the FrontendUser schema.
type FrontendUserClient struct {
	config
}

// NewFrontendUserClient returns a client for the FrontendUser from the given config.
func NewFrontendUserClient(c config) *FrontendUserClient {
	return &FrontendUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `frontenduser.Hooks(f(g(h())))`.
func (c *FrontendUserClient) Use(hooks ...Hook) {
	c.hooks.FrontendUser = append(c.hooks.FrontendUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `frontenduser.Intercept(f(g(h())))`.
func (c *FrontendUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.FrontendUser = append(c.inters.FrontendUser, interceptors...)
}

// Create returns a builder for creating a FrontendUser entity.
func (c *FrontendUserClient) Create() *FrontendUserCreate {
	mutation := newFrontendUserMutation(c.config, OpCreate)
	return &FrontendUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FrontendUser entities.
func (c *FrontendUserClient) CreateBulk(builders ...*FrontendUserCreate) *FrontendUserCreateBulk {
	return &FrontendUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FrontendUserClient) MapCreateBulk(slice any, setFunc func(*FrontendUserCreate, int)) *FrontendUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FrontendUserCreateBulk{err: fmt.Errorf("calling to FrontendUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FrontendUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FrontendUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FrontendUser.
func (c *FrontendUserClient) Update() *FrontendUserUpdate {
	mutation := newFrontendUserMutation(c.config, OpUpdate)
	return &FrontendUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FrontendUserClient) UpdateOne(fu *FrontendUser) *FrontendUserUpdateOne {
	mutation := newFrontendUserMutation(c.config, OpUpdateOne, withFrontendUser(fu))
	return &FrontendUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FrontendUserClient) UpdateOneID(id int) *FrontendUserUpdateOne {
	mutation := newFrontendUserMutation(c.config, OpUpdateOne, withFrontendUserID(id))
	return &FrontendUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FrontendUser.
func (c *FrontendUserClient) Delete() *FrontendUserDelete {
	mutation := newFrontendUserMutation(c.config, OpDelete)
	return &FrontendUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FrontendUserClient) DeleteOne(fu *FrontendUser) *FrontendUserDeleteOne {
	return c.DeleteOneID(fu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FrontendUserClient) DeleteOneID(id int) *FrontendUserDeleteOne {
	builder := c.Delete().Where(frontenduser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FrontendUserDeleteOne{builder}
}

// Query returns a query builder for FrontendUser.
func (c *FrontendUserClient) Query() *FrontendUserQuery {
	return &FrontendUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFrontendUser},
		inters: c.Interceptors(),
	}
}

// Get returns a FrontendUser entity by its id.
func (c *FrontendUserClient) Get(ctx context.Context, id int) (*FrontendUser, error) {
	return c.Query().Where(frontenduser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FrontendUserClient) GetX(ctx context.Context, id int) *FrontendUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a FrontendUser.
func (c *FrontendUserClient) QueryStore(fu *FrontendUser) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(frontenduser.Table, frontenduser.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, frontenduser.StoreTable, frontenduser.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(fu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FrontendUserClient) Hooks() []Hook {
	hooks := c.hooks.FrontendUser
	return append(hooks[:len(hooks):len(hooks)], frontenduser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FrontendUserClient) Interceptors() []Interceptor {
	inters := c.inters.FrontendUser
	return append(inters[:len(inters):len(inters)], frontenduser.Interceptors[:]...)
}

func (c *FrontendUserClient) mutate(ctx context.Context, m *FrontendUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FrontendUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FrontendUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FrontendUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FrontendUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FrontendUser mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id int) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a Order.
func (c *OrderClient) QueryItems(o *Order) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.ItemsTable, order.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Order.
func (c *OrderClient) QueryLogs(o *Order) *OrderLogQuery {
	query := (&OrderLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderlog.Table, orderlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.LogsTable, order.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCurrentDinetable queries the current_dinetable edge of a Order.
func (c *OrderClient) QueryCurrentDinetable(o *Order) *DineTableQuery {
	query := (&DineTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(dinetable.Table, dinetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, order.CurrentDinetableTable, order.CurrentDinetableColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDinetable queries the dinetable edge of a Order.
func (c *OrderClient) QueryDinetable(o *Order) *DineTableQuery {
	query := (&DineTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(dinetable.Table, dinetable.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.DinetableTable, order.DinetableColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	hooks := c.hooks.Order
	return append(hooks[:len(hooks):len(hooks)], order.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	inters := c.inters.Order
	return append(inters[:len(inters):len(inters)], order.Interceptors[:]...)
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderCartClient is a client for the OrderCart schema.
type OrderCartClient struct {
	config
}

// NewOrderCartClient returns a client for the OrderCart from the given config.
func NewOrderCartClient(c config) *OrderCartClient {
	return &OrderCartClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ordercart.Hooks(f(g(h())))`.
func (c *OrderCartClient) Use(hooks ...Hook) {
	c.hooks.OrderCart = append(c.hooks.OrderCart, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ordercart.Intercept(f(g(h())))`.
func (c *OrderCartClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderCart = append(c.inters.OrderCart, interceptors...)
}

// Create returns a builder for creating a OrderCart entity.
func (c *OrderCartClient) Create() *OrderCartCreate {
	mutation := newOrderCartMutation(c.config, OpCreate)
	return &OrderCartCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderCart entities.
func (c *OrderCartClient) CreateBulk(builders ...*OrderCartCreate) *OrderCartCreateBulk {
	return &OrderCartCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderCartClient) MapCreateBulk(slice any, setFunc func(*OrderCartCreate, int)) *OrderCartCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCartCreateBulk{err: fmt.Errorf("calling to OrderCartClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCartCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCartCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderCart.
func (c *OrderCartClient) Update() *OrderCartUpdate {
	mutation := newOrderCartMutation(c.config, OpUpdate)
	return &OrderCartUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderCartClient) UpdateOne(oc *OrderCart) *OrderCartUpdateOne {
	mutation := newOrderCartMutation(c.config, OpUpdateOne, withOrderCart(oc))
	return &OrderCartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderCartClient) UpdateOneID(id int) *OrderCartUpdateOne {
	mutation := newOrderCartMutation(c.config, OpUpdateOne, withOrderCartID(id))
	return &OrderCartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderCart.
func (c *OrderCartClient) Delete() *OrderCartDelete {
	mutation := newOrderCartMutation(c.config, OpDelete)
	return &OrderCartDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderCartClient) DeleteOne(oc *OrderCart) *OrderCartDeleteOne {
	return c.DeleteOneID(oc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderCartClient) DeleteOneID(id int) *OrderCartDeleteOne {
	builder := c.Delete().Where(ordercart.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderCartDeleteOne{builder}
}

// Query returns a query builder for OrderCart.
func (c *OrderCartClient) Query() *OrderCartQuery {
	return &OrderCartQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderCart},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderCart entity by its id.
func (c *OrderCartClient) Get(ctx context.Context, id int) (*OrderCart, error) {
	return c.Query().Where(ordercart.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderCartClient) GetX(ctx context.Context, id int) *OrderCart {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a OrderCart.
func (c *OrderCartClient) QueryProduct(oc *OrderCart) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordercart.Table, ordercart.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordercart.ProductTable, ordercart.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductSpec queries the product_spec edge of a OrderCart.
func (c *OrderCartClient) QueryProductSpec(oc *OrderCart) *ProductSpecQuery {
	query := (&ProductSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordercart.Table, ordercart.FieldID, id),
			sqlgraph.To(productspec.Table, productspec.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordercart.ProductSpecTable, ordercart.ProductSpecColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttr queries the attr edge of a OrderCart.
func (c *OrderCartClient) QueryAttr(oc *OrderCart) *AttrQuery {
	query := (&AttrClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordercart.Table, ordercart.FieldID, id),
			sqlgraph.To(attr.Table, attr.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordercart.AttrTable, ordercart.AttrColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecipe queries the recipe edge of a OrderCart.
func (c *OrderCartClient) QueryRecipe(oc *OrderCart) *RecipeQuery {
	query := (&RecipeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordercart.Table, ordercart.FieldID, id),
			sqlgraph.To(recipe.Table, recipe.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordercart.RecipeTable, ordercart.RecipeColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderCartClient) Hooks() []Hook {
	hooks := c.hooks.OrderCart
	return append(hooks[:len(hooks):len(hooks)], ordercart.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrderCartClient) Interceptors() []Interceptor {
	inters := c.inters.OrderCart
	return append(inters[:len(inters):len(inters)], ordercart.Interceptors[:]...)
}

func (c *OrderCartClient) mutate(ctx context.Context, m *OrderCartMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCartCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderCartUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderCartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderCartDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderCart mutation op: %q", m.Op())
	}
}

// OrderFinanceLogClient is a client for the OrderFinanceLog schema.
type OrderFinanceLogClient struct {
	config
}

// NewOrderFinanceLogClient returns a client for the OrderFinanceLog from the given config.
func NewOrderFinanceLogClient(c config) *OrderFinanceLogClient {
	return &OrderFinanceLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderfinancelog.Hooks(f(g(h())))`.
func (c *OrderFinanceLogClient) Use(hooks ...Hook) {
	c.hooks.OrderFinanceLog = append(c.hooks.OrderFinanceLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderfinancelog.Intercept(f(g(h())))`.
func (c *OrderFinanceLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderFinanceLog = append(c.inters.OrderFinanceLog, interceptors...)
}

// Create returns a builder for creating a OrderFinanceLog entity.
func (c *OrderFinanceLogClient) Create() *OrderFinanceLogCreate {
	mutation := newOrderFinanceLogMutation(c.config, OpCreate)
	return &OrderFinanceLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderFinanceLog entities.
func (c *OrderFinanceLogClient) CreateBulk(builders ...*OrderFinanceLogCreate) *OrderFinanceLogCreateBulk {
	return &OrderFinanceLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderFinanceLogClient) MapCreateBulk(slice any, setFunc func(*OrderFinanceLogCreate, int)) *OrderFinanceLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderFinanceLogCreateBulk{err: fmt.Errorf("calling to OrderFinanceLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderFinanceLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderFinanceLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderFinanceLog.
func (c *OrderFinanceLogClient) Update() *OrderFinanceLogUpdate {
	mutation := newOrderFinanceLogMutation(c.config, OpUpdate)
	return &OrderFinanceLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderFinanceLogClient) UpdateOne(ofl *OrderFinanceLog) *OrderFinanceLogUpdateOne {
	mutation := newOrderFinanceLogMutation(c.config, OpUpdateOne, withOrderFinanceLog(ofl))
	return &OrderFinanceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderFinanceLogClient) UpdateOneID(id int) *OrderFinanceLogUpdateOne {
	mutation := newOrderFinanceLogMutation(c.config, OpUpdateOne, withOrderFinanceLogID(id))
	return &OrderFinanceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderFinanceLog.
func (c *OrderFinanceLogClient) Delete() *OrderFinanceLogDelete {
	mutation := newOrderFinanceLogMutation(c.config, OpDelete)
	return &OrderFinanceLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderFinanceLogClient) DeleteOne(ofl *OrderFinanceLog) *OrderFinanceLogDeleteOne {
	return c.DeleteOneID(ofl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderFinanceLogClient) DeleteOneID(id int) *OrderFinanceLogDeleteOne {
	builder := c.Delete().Where(orderfinancelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderFinanceLogDeleteOne{builder}
}

// Query returns a query builder for OrderFinanceLog.
func (c *OrderFinanceLogClient) Query() *OrderFinanceLogQuery {
	return &OrderFinanceLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderFinanceLog},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderFinanceLog entity by its id.
func (c *OrderFinanceLogClient) Get(ctx context.Context, id int) (*OrderFinanceLog, error) {
	return c.Query().Where(orderfinancelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderFinanceLogClient) GetX(ctx context.Context, id int) *OrderFinanceLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderFinanceLogClient) Hooks() []Hook {
	hooks := c.hooks.OrderFinanceLog
	return append(hooks[:len(hooks):len(hooks)], orderfinancelog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrderFinanceLogClient) Interceptors() []Interceptor {
	inters := c.inters.OrderFinanceLog
	return append(inters[:len(inters):len(inters)], orderfinancelog.Interceptors[:]...)
}

func (c *OrderFinanceLogClient) mutate(ctx context.Context, m *OrderFinanceLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderFinanceLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderFinanceLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderFinanceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderFinanceLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderFinanceLog mutation op: %q", m.Op())
	}
}

// OrderItemClient is a client for the OrderItem schema.
type OrderItemClient struct {
	config
}

// NewOrderItemClient returns a client for the OrderItem from the given config.
func NewOrderItemClient(c config) *OrderItemClient {
	return &OrderItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitem.Hooks(f(g(h())))`.
func (c *OrderItemClient) Use(hooks ...Hook) {
	c.hooks.OrderItem = append(c.hooks.OrderItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitem.Intercept(f(g(h())))`.
func (c *OrderItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItem = append(c.inters.OrderItem, interceptors...)
}

// Create returns a builder for creating a OrderItem entity.
func (c *OrderItemClient) Create() *OrderItemCreate {
	mutation := newOrderItemMutation(c.config, OpCreate)
	return &OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItem entities.
func (c *OrderItemClient) CreateBulk(builders ...*OrderItemCreate) *OrderItemCreateBulk {
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemClient) MapCreateBulk(slice any, setFunc func(*OrderItemCreate, int)) *OrderItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemCreateBulk{err: fmt.Errorf("calling to OrderItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItem.
func (c *OrderItemClient) Update() *OrderItemUpdate {
	mutation := newOrderItemMutation(c.config, OpUpdate)
	return &OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemClient) UpdateOne(oi *OrderItem) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItem(oi))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemClient) UpdateOneID(id int) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItemID(id))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItem.
func (c *OrderItemClient) Delete() *OrderItemDelete {
	mutation := newOrderItemMutation(c.config, OpDelete)
	return &OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemClient) DeleteOne(oi *OrderItem) *OrderItemDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemClient) DeleteOneID(id int) *OrderItemDeleteOne {
	builder := c.Delete().Where(orderitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemDeleteOne{builder}
}

// Query returns a query builder for OrderItem.
func (c *OrderItemClient) Query() *OrderItemQuery {
	return &OrderItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItem entity by its id.
func (c *OrderItemClient) Get(ctx context.Context, id int) (*OrderItem, error) {
	return c.Query().Where(orderitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemClient) GetX(ctx context.Context, id int) *OrderItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderItem.
func (c *OrderItemClient) QueryOrder(oi *OrderItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderitem.OrderTable, orderitem.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetMealDetails queries the set_meal_details edge of a OrderItem.
func (c *OrderItemClient) QuerySetMealDetails(oi *OrderItem) *OrderItemSetMealDetailQuery {
	query := (&OrderItemSetMealDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(orderitemsetmealdetail.Table, orderitemsetmealdetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orderitem.SetMealDetailsTable, orderitem.SetMealDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemClient) Hooks() []Hook {
	hooks := c.hooks.OrderItem
	return append(hooks[:len(hooks):len(hooks)], orderitem.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrderItemClient) Interceptors() []Interceptor {
	inters := c.inters.OrderItem
	return append(inters[:len(inters):len(inters)], orderitem.Interceptors[:]...)
}

func (c *OrderItemClient) mutate(ctx context.Context, m *OrderItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItem mutation op: %q", m.Op())
	}
}

// OrderItemSetMealDetailClient is a client for the OrderItemSetMealDetail schema.
type OrderItemSetMealDetailClient struct {
	config
}

// NewOrderItemSetMealDetailClient returns a client for the OrderItemSetMealDetail from the given config.
func NewOrderItemSetMealDetailClient(c config) *OrderItemSetMealDetailClient {
	return &OrderItemSetMealDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitemsetmealdetail.Hooks(f(g(h())))`.
func (c *OrderItemSetMealDetailClient) Use(hooks ...Hook) {
	c.hooks.OrderItemSetMealDetail = append(c.hooks.OrderItemSetMealDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitemsetmealdetail.Intercept(f(g(h())))`.
func (c *OrderItemSetMealDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItemSetMealDetail = append(c.inters.OrderItemSetMealDetail, interceptors...)
}

// Create returns a builder for creating a OrderItemSetMealDetail entity.
func (c *OrderItemSetMealDetailClient) Create() *OrderItemSetMealDetailCreate {
	mutation := newOrderItemSetMealDetailMutation(c.config, OpCreate)
	return &OrderItemSetMealDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItemSetMealDetail entities.
func (c *OrderItemSetMealDetailClient) CreateBulk(builders ...*OrderItemSetMealDetailCreate) *OrderItemSetMealDetailCreateBulk {
	return &OrderItemSetMealDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemSetMealDetailClient) MapCreateBulk(slice any, setFunc func(*OrderItemSetMealDetailCreate, int)) *OrderItemSetMealDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemSetMealDetailCreateBulk{err: fmt.Errorf("calling to OrderItemSetMealDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemSetMealDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemSetMealDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItemSetMealDetail.
func (c *OrderItemSetMealDetailClient) Update() *OrderItemSetMealDetailUpdate {
	mutation := newOrderItemSetMealDetailMutation(c.config, OpUpdate)
	return &OrderItemSetMealDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemSetMealDetailClient) UpdateOne(oismd *OrderItemSetMealDetail) *OrderItemSetMealDetailUpdateOne {
	mutation := newOrderItemSetMealDetailMutation(c.config, OpUpdateOne, withOrderItemSetMealDetail(oismd))
	return &OrderItemSetMealDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemSetMealDetailClient) UpdateOneID(id int) *OrderItemSetMealDetailUpdateOne {
	mutation := newOrderItemSetMealDetailMutation(c.config, OpUpdateOne, withOrderItemSetMealDetailID(id))
	return &OrderItemSetMealDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItemSetMealDetail.
func (c *OrderItemSetMealDetailClient) Delete() *OrderItemSetMealDetailDelete {
	mutation := newOrderItemSetMealDetailMutation(c.config, OpDelete)
	return &OrderItemSetMealDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemSetMealDetailClient) DeleteOne(oismd *OrderItemSetMealDetail) *OrderItemSetMealDetailDeleteOne {
	return c.DeleteOneID(oismd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemSetMealDetailClient) DeleteOneID(id int) *OrderItemSetMealDetailDeleteOne {
	builder := c.Delete().Where(orderitemsetmealdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemSetMealDetailDeleteOne{builder}
}

// Query returns a query builder for OrderItemSetMealDetail.
func (c *OrderItemSetMealDetailClient) Query() *OrderItemSetMealDetailQuery {
	return &OrderItemSetMealDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItemSetMealDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItemSetMealDetail entity by its id.
func (c *OrderItemSetMealDetailClient) Get(ctx context.Context, id int) (*OrderItemSetMealDetail, error) {
	return c.Query().Where(orderitemsetmealdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemSetMealDetailClient) GetX(ctx context.Context, id int) *OrderItemSetMealDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrderItem queries the order_item edge of a OrderItemSetMealDetail.
func (c *OrderItemSetMealDetailClient) QueryOrderItem(oismd *OrderItemSetMealDetail) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oismd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitemsetmealdetail.Table, orderitemsetmealdetail.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderitemsetmealdetail.OrderItemTable, orderitemsetmealdetail.OrderItemColumn),
		)
		fromV = sqlgraph.Neighbors(oismd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemSetMealDetailClient) Hooks() []Hook {
	hooks := c.hooks.OrderItemSetMealDetail
	return append(hooks[:len(hooks):len(hooks)], orderitemsetmealdetail.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrderItemSetMealDetailClient) Interceptors() []Interceptor {
	inters := c.inters.OrderItemSetMealDetail
	return append(inters[:len(inters):len(inters)], orderitemsetmealdetail.Interceptors[:]...)
}

func (c *OrderItemSetMealDetailClient) mutate(ctx context.Context, m *OrderItemSetMealDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemSetMealDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemSetMealDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemSetMealDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemSetMealDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItemSetMealDetail mutation op: %q", m.Op())
	}
}

// OrderLogClient is a client for the OrderLog schema.
type OrderLogClient struct {
	config
}

// NewOrderLogClient returns a client for the OrderLog from the given config.
func NewOrderLogClient(c config) *OrderLogClient {
	return &OrderLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderlog.Hooks(f(g(h())))`.
func (c *OrderLogClient) Use(hooks ...Hook) {
	c.hooks.OrderLog = append(c.hooks.OrderLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderlog.Intercept(f(g(h())))`.
func (c *OrderLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderLog = append(c.inters.OrderLog, interceptors...)
}

// Create returns a builder for creating a OrderLog entity.
func (c *OrderLogClient) Create() *OrderLogCreate {
	mutation := newOrderLogMutation(c.config, OpCreate)
	return &OrderLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderLog entities.
func (c *OrderLogClient) CreateBulk(builders ...*OrderLogCreate) *OrderLogCreateBulk {
	return &OrderLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderLogClient) MapCreateBulk(slice any, setFunc func(*OrderLogCreate, int)) *OrderLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderLogCreateBulk{err: fmt.Errorf("calling to OrderLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderLog.
func (c *OrderLogClient) Update() *OrderLogUpdate {
	mutation := newOrderLogMutation(c.config, OpUpdate)
	return &OrderLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderLogClient) UpdateOne(ol *OrderLog) *OrderLogUpdateOne {
	mutation := newOrderLogMutation(c.config, OpUpdateOne, withOrderLog(ol))
	return &OrderLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderLogClient) UpdateOneID(id int) *OrderLogUpdateOne {
	mutation := newOrderLogMutation(c.config, OpUpdateOne, withOrderLogID(id))
	return &OrderLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderLog.
func (c *OrderLogClient) Delete() *OrderLogDelete {
	mutation := newOrderLogMutation(c.config, OpDelete)
	return &OrderLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderLogClient) DeleteOne(ol *OrderLog) *OrderLogDeleteOne {
	return c.DeleteOneID(ol.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderLogClient) DeleteOneID(id int) *OrderLogDeleteOne {
	builder := c.Delete().Where(orderlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderLogDeleteOne{builder}
}

// Query returns a query builder for OrderLog.
func (c *OrderLogClient) Query() *OrderLogQuery {
	return &OrderLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderLog},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderLog entity by its id.
func (c *OrderLogClient) Get(ctx context.Context, id int) (*OrderLog, error) {
	return c.Query().Where(orderlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderLogClient) GetX(ctx context.Context, id int) *OrderLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderLog.
func (c *OrderLogClient) QueryOrder(ol *OrderLog) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ol.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderlog.Table, orderlog.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderlog.OrderTable, orderlog.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(ol.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderLogClient) Hooks() []Hook {
	hooks := c.hooks.OrderLog
	return append(hooks[:len(hooks):len(hooks)], orderlog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrderLogClient) Interceptors() []Interceptor {
	inters := c.inters.OrderLog
	return append(inters[:len(inters):len(inters)], orderlog.Interceptors[:]...)
}

func (c *OrderLogClient) mutate(ctx context.Context, m *OrderLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderLog mutation op: %q", m.Op())
	}
}

// PaymentClient is a client for the Payment schema.
type PaymentClient struct {
	config
}

// NewPaymentClient returns a client for the Payment from the given config.
func NewPaymentClient(c config) *PaymentClient {
	return &PaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payment.Hooks(f(g(h())))`.
func (c *PaymentClient) Use(hooks ...Hook) {
	c.hooks.Payment = append(c.hooks.Payment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payment.Intercept(f(g(h())))`.
func (c *PaymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payment = append(c.inters.Payment, interceptors...)
}

// Create returns a builder for creating a Payment entity.
func (c *PaymentClient) Create() *PaymentCreate {
	mutation := newPaymentMutation(c.config, OpCreate)
	return &PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payment entities.
func (c *PaymentClient) CreateBulk(builders ...*PaymentCreate) *PaymentCreateBulk {
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentClient) MapCreateBulk(slice any, setFunc func(*PaymentCreate, int)) *PaymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentCreateBulk{err: fmt.Errorf("calling to PaymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payment.
func (c *PaymentClient) Update() *PaymentUpdate {
	mutation := newPaymentMutation(c.config, OpUpdate)
	return &PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentClient) UpdateOne(pa *Payment) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPayment(pa))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentClient) UpdateOneID(id int) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPaymentID(id))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payment.
func (c *PaymentClient) Delete() *PaymentDelete {
	mutation := newPaymentMutation(c.config, OpDelete)
	return &PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentClient) DeleteOne(pa *Payment) *PaymentDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentClient) DeleteOneID(id int) *PaymentDeleteOne {
	builder := c.Delete().Where(payment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentDeleteOne{builder}
}

// Query returns a query builder for Payment.
func (c *PaymentClient) Query() *PaymentQuery {
	return &PaymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayment},
		inters: c.Interceptors(),
	}
}

// Get returns a Payment entity by its id.
func (c *PaymentClient) Get(ctx context.Context, id int) (*Payment, error) {
	return c.Query().Where(payment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentClient) GetX(ctx context.Context, id int) *Payment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentClient) Hooks() []Hook {
	hooks := c.hooks.Payment
	return append(hooks[:len(hooks):len(hooks)], payment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PaymentClient) Interceptors() []Interceptor {
	inters := c.inters.Payment
	return append(inters[:len(inters):len(inters)], payment.Interceptors[:]...)
}

func (c *PaymentClient) mutate(ctx context.Context, m *PaymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Payment mutation op: %q", m.Op())
	}
}

// PaymentCallbackClient is a client for the PaymentCallback schema.
type PaymentCallbackClient struct {
	config
}

// NewPaymentCallbackClient returns a client for the PaymentCallback from the given config.
func NewPaymentCallbackClient(c config) *PaymentCallbackClient {
	return &PaymentCallbackClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymentcallback.Hooks(f(g(h())))`.
func (c *PaymentCallbackClient) Use(hooks ...Hook) {
	c.hooks.PaymentCallback = append(c.hooks.PaymentCallback, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paymentcallback.Intercept(f(g(h())))`.
func (c *PaymentCallbackClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaymentCallback = append(c.inters.PaymentCallback, interceptors...)
}

// Create returns a builder for creating a PaymentCallback entity.
func (c *PaymentCallbackClient) Create() *PaymentCallbackCreate {
	mutation := newPaymentCallbackMutation(c.config, OpCreate)
	return &PaymentCallbackCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaymentCallback entities.
func (c *PaymentCallbackClient) CreateBulk(builders ...*PaymentCallbackCreate) *PaymentCallbackCreateBulk {
	return &PaymentCallbackCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentCallbackClient) MapCreateBulk(slice any, setFunc func(*PaymentCallbackCreate, int)) *PaymentCallbackCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentCallbackCreateBulk{err: fmt.Errorf("calling to PaymentCallbackClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentCallbackCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentCallbackCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaymentCallback.
func (c *PaymentCallbackClient) Update() *PaymentCallbackUpdate {
	mutation := newPaymentCallbackMutation(c.config, OpUpdate)
	return &PaymentCallbackUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentCallbackClient) UpdateOne(pc *PaymentCallback) *PaymentCallbackUpdateOne {
	mutation := newPaymentCallbackMutation(c.config, OpUpdateOne, withPaymentCallback(pc))
	return &PaymentCallbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentCallbackClient) UpdateOneID(id int) *PaymentCallbackUpdateOne {
	mutation := newPaymentCallbackMutation(c.config, OpUpdateOne, withPaymentCallbackID(id))
	return &PaymentCallbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentCallback.
func (c *PaymentCallbackClient) Delete() *PaymentCallbackDelete {
	mutation := newPaymentCallbackMutation(c.config, OpDelete)
	return &PaymentCallbackDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentCallbackClient) DeleteOne(pc *PaymentCallback) *PaymentCallbackDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentCallbackClient) DeleteOneID(id int) *PaymentCallbackDeleteOne {
	builder := c.Delete().Where(paymentcallback.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentCallbackDeleteOne{builder}
}

// Query returns a query builder for PaymentCallback.
func (c *PaymentCallbackClient) Query() *PaymentCallbackQuery {
	return &PaymentCallbackQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaymentCallback},
		inters: c.Interceptors(),
	}
}

// Get returns a PaymentCallback entity by its id.
func (c *PaymentCallbackClient) Get(ctx context.Context, id int) (*PaymentCallback, error) {
	return c.Query().Where(paymentcallback.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentCallbackClient) GetX(ctx context.Context, id int) *PaymentCallback {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentCallbackClient) Hooks() []Hook {
	hooks := c.hooks.PaymentCallback
	return append(hooks[:len(hooks):len(hooks)], paymentcallback.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PaymentCallbackClient) Interceptors() []Interceptor {
	inters := c.inters.PaymentCallback
	return append(inters[:len(inters):len(inters)], paymentcallback.Interceptors[:]...)
}

func (c *PaymentCallbackClient) mutate(ctx context.Context, m *PaymentCallbackMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentCallbackCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentCallbackUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentCallbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentCallbackDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PaymentCallback mutation op: %q", m.Op())
	}
}

// PointSettlementClient is a client for the PointSettlement schema.
type PointSettlementClient struct {
	config
}

// NewPointSettlementClient returns a client for the PointSettlement from the given config.
func NewPointSettlementClient(c config) *PointSettlementClient {
	return &PointSettlementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pointsettlement.Hooks(f(g(h())))`.
func (c *PointSettlementClient) Use(hooks ...Hook) {
	c.hooks.PointSettlement = append(c.hooks.PointSettlement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pointsettlement.Intercept(f(g(h())))`.
func (c *PointSettlementClient) Intercept(interceptors ...Interceptor) {
	c.inters.PointSettlement = append(c.inters.PointSettlement, interceptors...)
}

// Create returns a builder for creating a PointSettlement entity.
func (c *PointSettlementClient) Create() *PointSettlementCreate {
	mutation := newPointSettlementMutation(c.config, OpCreate)
	return &PointSettlementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PointSettlement entities.
func (c *PointSettlementClient) CreateBulk(builders ...*PointSettlementCreate) *PointSettlementCreateBulk {
	return &PointSettlementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PointSettlementClient) MapCreateBulk(slice any, setFunc func(*PointSettlementCreate, int)) *PointSettlementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PointSettlementCreateBulk{err: fmt.Errorf("calling to PointSettlementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PointSettlementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PointSettlementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PointSettlement.
func (c *PointSettlementClient) Update() *PointSettlementUpdate {
	mutation := newPointSettlementMutation(c.config, OpUpdate)
	return &PointSettlementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PointSettlementClient) UpdateOne(ps *PointSettlement) *PointSettlementUpdateOne {
	mutation := newPointSettlementMutation(c.config, OpUpdateOne, withPointSettlement(ps))
	return &PointSettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PointSettlementClient) UpdateOneID(id int) *PointSettlementUpdateOne {
	mutation := newPointSettlementMutation(c.config, OpUpdateOne, withPointSettlementID(id))
	return &PointSettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PointSettlement.
func (c *PointSettlementClient) Delete() *PointSettlementDelete {
	mutation := newPointSettlementMutation(c.config, OpDelete)
	return &PointSettlementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PointSettlementClient) DeleteOne(ps *PointSettlement) *PointSettlementDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PointSettlementClient) DeleteOneID(id int) *PointSettlementDeleteOne {
	builder := c.Delete().Where(pointsettlement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PointSettlementDeleteOne{builder}
}

// Query returns a query builder for PointSettlement.
func (c *PointSettlementClient) Query() *PointSettlementQuery {
	return &PointSettlementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePointSettlement},
		inters: c.Interceptors(),
	}
}

// Get returns a PointSettlement entity by its id.
func (c *PointSettlementClient) Get(ctx context.Context, id int) (*PointSettlement, error) {
	return c.Query().Where(pointsettlement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PointSettlementClient) GetX(ctx context.Context, id int) *PointSettlement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PointSettlementClient) Hooks() []Hook {
	return c.hooks.PointSettlement
}

// Interceptors returns the client interceptors.
func (c *PointSettlementClient) Interceptors() []Interceptor {
	return c.inters.PointSettlement
}

func (c *PointSettlementClient) mutate(ctx context.Context, m *PointSettlementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PointSettlementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PointSettlementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PointSettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PointSettlementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PointSettlement mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategory queries the category edge of a Product.
func (c *ProductClient) QueryCategory(pr *Product) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.CategoryTable, product.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnit queries the unit edge of a Product.
func (c *ProductClient) QueryUnit(pr *Product) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.UnitTable, product.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttrs queries the attrs edge of a Product.
func (c *ProductClient) QueryAttrs(pr *Product) *AttrQuery {
	query := (&AttrClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(attr.Table, attr.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.AttrsTable, product.AttrsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecipes queries the recipes edge of a Product.
func (c *ProductClient) QueryRecipes(pr *Product) *RecipeQuery {
	query := (&RecipeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(recipe.Table, recipe.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.RecipesTable, product.RecipesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductSpecs queries the product_specs edge of a Product.
func (c *ProductClient) QueryProductSpecs(pr *Product) *ProductSpecQuery {
	query := (&ProductSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(productspec.Table, productspec.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.ProductSpecsTable, product.ProductSpecsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetMealDetails queries the set_meal_details edge of a Product.
func (c *ProductClient) QuerySetMealDetails(pr *Product) *SetMealDetailQuery {
	query := (&SetMealDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(setmealdetail.Table, setmealdetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.SetMealDetailsTable, product.SetMealDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedInSetMeals queries the included_in_set_meals edge of a Product.
func (c *ProductClient) QueryIncludedInSetMeals(pr *Product) *SetMealDetailQuery {
	query := (&SetMealDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(setmealdetail.Table, setmealdetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.IncludedInSetMealsTable, product.IncludedInSetMealsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderCartItems queries the order_cart_items edge of a Product.
func (c *ProductClient) QueryOrderCartItems(pr *Product) *OrderCartQuery {
	query := (&OrderCartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(ordercart.Table, ordercart.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.OrderCartItemsTable, product.OrderCartItemsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	hooks := c.hooks.Product
	return append(hooks[:len(hooks):len(hooks)], product.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	inters := c.inters.Product
	return append(inters[:len(inters):len(inters)], product.Interceptors[:]...)
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// ProductSpecClient is a client for the ProductSpec schema.
type ProductSpecClient struct {
	config
}

// NewProductSpecClient returns a client for the ProductSpec from the given config.
func NewProductSpecClient(c config) *ProductSpecClient {
	return &ProductSpecClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productspec.Hooks(f(g(h())))`.
func (c *ProductSpecClient) Use(hooks ...Hook) {
	c.hooks.ProductSpec = append(c.hooks.ProductSpec, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productspec.Intercept(f(g(h())))`.
func (c *ProductSpecClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductSpec = append(c.inters.ProductSpec, interceptors...)
}

// Create returns a builder for creating a ProductSpec entity.
func (c *ProductSpecClient) Create() *ProductSpecCreate {
	mutation := newProductSpecMutation(c.config, OpCreate)
	return &ProductSpecCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductSpec entities.
func (c *ProductSpecClient) CreateBulk(builders ...*ProductSpecCreate) *ProductSpecCreateBulk {
	return &ProductSpecCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductSpecClient) MapCreateBulk(slice any, setFunc func(*ProductSpecCreate, int)) *ProductSpecCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductSpecCreateBulk{err: fmt.Errorf("calling to ProductSpecClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductSpecCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductSpecCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductSpec.
func (c *ProductSpecClient) Update() *ProductSpecUpdate {
	mutation := newProductSpecMutation(c.config, OpUpdate)
	return &ProductSpecUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductSpecClient) UpdateOne(ps *ProductSpec) *ProductSpecUpdateOne {
	mutation := newProductSpecMutation(c.config, OpUpdateOne, withProductSpec(ps))
	return &ProductSpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductSpecClient) UpdateOneID(id int) *ProductSpecUpdateOne {
	mutation := newProductSpecMutation(c.config, OpUpdateOne, withProductSpecID(id))
	return &ProductSpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductSpec.
func (c *ProductSpecClient) Delete() *ProductSpecDelete {
	mutation := newProductSpecMutation(c.config, OpDelete)
	return &ProductSpecDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductSpecClient) DeleteOne(ps *ProductSpec) *ProductSpecDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductSpecClient) DeleteOneID(id int) *ProductSpecDeleteOne {
	builder := c.Delete().Where(productspec.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductSpecDeleteOne{builder}
}

// Query returns a query builder for ProductSpec.
func (c *ProductSpecClient) Query() *ProductSpecQuery {
	return &ProductSpecQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductSpec},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductSpec entity by its id.
func (c *ProductSpecClient) Get(ctx context.Context, id int) (*ProductSpec, error) {
	return c.Query().Where(productspec.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductSpecClient) GetX(ctx context.Context, id int) *ProductSpec {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductSpec.
func (c *ProductSpecClient) QueryProduct(ps *ProductSpec) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productspec.Table, productspec.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productspec.ProductTable, productspec.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySpec queries the spec edge of a ProductSpec.
func (c *ProductSpecClient) QuerySpec(ps *ProductSpec) *SpecQuery {
	query := (&SpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productspec.Table, productspec.FieldID, id),
			sqlgraph.To(spec.Table, spec.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, productspec.SpecTable, productspec.SpecColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetMealDetails queries the set_meal_details edge of a ProductSpec.
func (c *ProductSpecClient) QuerySetMealDetails(ps *ProductSpec) *SetMealDetailQuery {
	query := (&SetMealDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productspec.Table, productspec.FieldID, id),
			sqlgraph.To(setmealdetail.Table, setmealdetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, productspec.SetMealDetailsTable, productspec.SetMealDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderCartItems queries the order_cart_items edge of a ProductSpec.
func (c *ProductSpecClient) QueryOrderCartItems(ps *ProductSpec) *OrderCartQuery {
	query := (&OrderCartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productspec.Table, productspec.FieldID, id),
			sqlgraph.To(ordercart.Table, ordercart.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, productspec.OrderCartItemsTable, productspec.OrderCartItemsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductSpecClient) Hooks() []Hook {
	return c.hooks.ProductSpec
}

// Interceptors returns the client interceptors.
func (c *ProductSpecClient) Interceptors() []Interceptor {
	return c.inters.ProductSpec
}

func (c *ProductSpecClient) mutate(ctx context.Context, m *ProductSpecMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductSpecCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductSpecUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductSpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductSpecDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductSpec mutation op: %q", m.Op())
	}
}

// RecipeClient is a client for the Recipe schema.
type RecipeClient struct {
	config
}

// NewRecipeClient returns a client for the Recipe from the given config.
func NewRecipeClient(c config) *RecipeClient {
	return &RecipeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recipe.Hooks(f(g(h())))`.
func (c *RecipeClient) Use(hooks ...Hook) {
	c.hooks.Recipe = append(c.hooks.Recipe, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recipe.Intercept(f(g(h())))`.
func (c *RecipeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Recipe = append(c.inters.Recipe, interceptors...)
}

// Create returns a builder for creating a Recipe entity.
func (c *RecipeClient) Create() *RecipeCreate {
	mutation := newRecipeMutation(c.config, OpCreate)
	return &RecipeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Recipe entities.
func (c *RecipeClient) CreateBulk(builders ...*RecipeCreate) *RecipeCreateBulk {
	return &RecipeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecipeClient) MapCreateBulk(slice any, setFunc func(*RecipeCreate, int)) *RecipeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecipeCreateBulk{err: fmt.Errorf("calling to RecipeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecipeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecipeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Recipe.
func (c *RecipeClient) Update() *RecipeUpdate {
	mutation := newRecipeMutation(c.config, OpUpdate)
	return &RecipeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecipeClient) UpdateOne(r *Recipe) *RecipeUpdateOne {
	mutation := newRecipeMutation(c.config, OpUpdateOne, withRecipe(r))
	return &RecipeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecipeClient) UpdateOneID(id int) *RecipeUpdateOne {
	mutation := newRecipeMutation(c.config, OpUpdateOne, withRecipeID(id))
	return &RecipeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Recipe.
func (c *RecipeClient) Delete() *RecipeDelete {
	mutation := newRecipeMutation(c.config, OpDelete)
	return &RecipeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecipeClient) DeleteOne(r *Recipe) *RecipeDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecipeClient) DeleteOneID(id int) *RecipeDeleteOne {
	builder := c.Delete().Where(recipe.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecipeDeleteOne{builder}
}

// Query returns a query builder for Recipe.
func (c *RecipeClient) Query() *RecipeQuery {
	return &RecipeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecipe},
		inters: c.Interceptors(),
	}
}

// Get returns a Recipe entity by its id.
func (c *RecipeClient) Get(ctx context.Context, id int) (*Recipe, error) {
	return c.Query().Where(recipe.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecipeClient) GetX(ctx context.Context, id int) *Recipe {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Recipe.
func (c *RecipeClient) QueryProducts(r *Recipe) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recipe.Table, recipe.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, recipe.ProductsTable, recipe.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderCartItems queries the order_cart_items edge of a Recipe.
func (c *RecipeClient) QueryOrderCartItems(r *Recipe) *OrderCartQuery {
	query := (&OrderCartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recipe.Table, recipe.FieldID, id),
			sqlgraph.To(ordercart.Table, ordercart.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, recipe.OrderCartItemsTable, recipe.OrderCartItemsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RecipeClient) Hooks() []Hook {
	hooks := c.hooks.Recipe
	return append(hooks[:len(hooks):len(hooks)], recipe.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RecipeClient) Interceptors() []Interceptor {
	inters := c.inters.Recipe
	return append(inters[:len(inters):len(inters)], recipe.Interceptors[:]...)
}

func (c *RecipeClient) mutate(ctx context.Context, m *RecipeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecipeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecipeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecipeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecipeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Recipe mutation op: %q", m.Op())
	}
}

// ReconciliationRecordClient is a client for the ReconciliationRecord schema.
type ReconciliationRecordClient struct {
	config
}

// NewReconciliationRecordClient returns a client for the ReconciliationRecord from the given config.
func NewReconciliationRecordClient(c config) *ReconciliationRecordClient {
	return &ReconciliationRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reconciliationrecord.Hooks(f(g(h())))`.
func (c *ReconciliationRecordClient) Use(hooks ...Hook) {
	c.hooks.ReconciliationRecord = append(c.hooks.ReconciliationRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reconciliationrecord.Intercept(f(g(h())))`.
func (c *ReconciliationRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReconciliationRecord = append(c.inters.ReconciliationRecord, interceptors...)
}

// Create returns a builder for creating a ReconciliationRecord entity.
func (c *ReconciliationRecordClient) Create() *ReconciliationRecordCreate {
	mutation := newReconciliationRecordMutation(c.config, OpCreate)
	return &ReconciliationRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReconciliationRecord entities.
func (c *ReconciliationRecordClient) CreateBulk(builders ...*ReconciliationRecordCreate) *ReconciliationRecordCreateBulk {
	return &ReconciliationRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReconciliationRecordClient) MapCreateBulk(slice any, setFunc func(*ReconciliationRecordCreate, int)) *ReconciliationRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReconciliationRecordCreateBulk{err: fmt.Errorf("calling to ReconciliationRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReconciliationRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReconciliationRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReconciliationRecord.
func (c *ReconciliationRecordClient) Update() *ReconciliationRecordUpdate {
	mutation := newReconciliationRecordMutation(c.config, OpUpdate)
	return &ReconciliationRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReconciliationRecordClient) UpdateOne(rr *ReconciliationRecord) *ReconciliationRecordUpdateOne {
	mutation := newReconciliationRecordMutation(c.config, OpUpdateOne, withReconciliationRecord(rr))
	return &ReconciliationRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReconciliationRecordClient) UpdateOneID(id int) *ReconciliationRecordUpdateOne {
	mutation := newReconciliationRecordMutation(c.config, OpUpdateOne, withReconciliationRecordID(id))
	return &ReconciliationRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReconciliationRecord.
func (c *ReconciliationRecordClient) Delete() *ReconciliationRecordDelete {
	mutation := newReconciliationRecordMutation(c.config, OpDelete)
	return &ReconciliationRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReconciliationRecordClient) DeleteOne(rr *ReconciliationRecord) *ReconciliationRecordDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReconciliationRecordClient) DeleteOneID(id int) *ReconciliationRecordDeleteOne {
	builder := c.Delete().Where(reconciliationrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReconciliationRecordDeleteOne{builder}
}

// Query returns a query builder for ReconciliationRecord.
func (c *ReconciliationRecordClient) Query() *ReconciliationRecordQuery {
	return &ReconciliationRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReconciliationRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a ReconciliationRecord entity by its id.
func (c *ReconciliationRecordClient) Get(ctx context.Context, id int) (*ReconciliationRecord, error) {
	return c.Query().Where(reconciliationrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReconciliationRecordClient) GetX(ctx context.Context, id int) *ReconciliationRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ReconciliationRecordClient) Hooks() []Hook {
	return c.hooks.ReconciliationRecord
}

// Interceptors returns the client interceptors.
func (c *ReconciliationRecordClient) Interceptors() []Interceptor {
	return c.inters.ReconciliationRecord
}

func (c *ReconciliationRecordClient) mutate(ctx context.Context, m *ReconciliationRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReconciliationRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReconciliationRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReconciliationRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReconciliationRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ReconciliationRecord mutation op: %q", m.Op())
	}
}

// SetMealDetailClient is a client for the SetMealDetail schema.
type SetMealDetailClient struct {
	config
}

// NewSetMealDetailClient returns a client for the SetMealDetail from the given config.
func NewSetMealDetailClient(c config) *SetMealDetailClient {
	return &SetMealDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setmealdetail.Hooks(f(g(h())))`.
func (c *SetMealDetailClient) Use(hooks ...Hook) {
	c.hooks.SetMealDetail = append(c.hooks.SetMealDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setmealdetail.Intercept(f(g(h())))`.
func (c *SetMealDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.SetMealDetail = append(c.inters.SetMealDetail, interceptors...)
}

// Create returns a builder for creating a SetMealDetail entity.
func (c *SetMealDetailClient) Create() *SetMealDetailCreate {
	mutation := newSetMealDetailMutation(c.config, OpCreate)
	return &SetMealDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SetMealDetail entities.
func (c *SetMealDetailClient) CreateBulk(builders ...*SetMealDetailCreate) *SetMealDetailCreateBulk {
	return &SetMealDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SetMealDetailClient) MapCreateBulk(slice any, setFunc func(*SetMealDetailCreate, int)) *SetMealDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SetMealDetailCreateBulk{err: fmt.Errorf("calling to SetMealDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SetMealDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SetMealDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SetMealDetail.
func (c *SetMealDetailClient) Update() *SetMealDetailUpdate {
	mutation := newSetMealDetailMutation(c.config, OpUpdate)
	return &SetMealDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SetMealDetailClient) UpdateOne(smd *SetMealDetail) *SetMealDetailUpdateOne {
	mutation := newSetMealDetailMutation(c.config, OpUpdateOne, withSetMealDetail(smd))
	return &SetMealDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SetMealDetailClient) UpdateOneID(id int) *SetMealDetailUpdateOne {
	mutation := newSetMealDetailMutation(c.config, OpUpdateOne, withSetMealDetailID(id))
	return &SetMealDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SetMealDetail.
func (c *SetMealDetailClient) Delete() *SetMealDetailDelete {
	mutation := newSetMealDetailMutation(c.config, OpDelete)
	return &SetMealDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SetMealDetailClient) DeleteOne(smd *SetMealDetail) *SetMealDetailDeleteOne {
	return c.DeleteOneID(smd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SetMealDetailClient) DeleteOneID(id int) *SetMealDetailDeleteOne {
	builder := c.Delete().Where(setmealdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SetMealDetailDeleteOne{builder}
}

// Query returns a query builder for SetMealDetail.
func (c *SetMealDetailClient) Query() *SetMealDetailQuery {
	return &SetMealDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetMealDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a SetMealDetail entity by its id.
func (c *SetMealDetailClient) Get(ctx context.Context, id int) (*SetMealDetail, error) {
	return c.Query().Where(setmealdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SetMealDetailClient) GetX(ctx context.Context, id int) *SetMealDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySetMeal queries the set_meal edge of a SetMealDetail.
func (c *SetMealDetailClient) QuerySetMeal(smd *SetMealDetail) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := smd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setmealdetail.Table, setmealdetail.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, setmealdetail.SetMealTable, setmealdetail.SetMealColumn),
		)
		fromV = sqlgraph.Neighbors(smd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a SetMealDetail.
func (c *SetMealDetailClient) QueryProduct(smd *SetMealDetail) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := smd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setmealdetail.Table, setmealdetail.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, setmealdetail.ProductTable, setmealdetail.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(smd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductSpec queries the product_spec edge of a SetMealDetail.
func (c *SetMealDetailClient) QueryProductSpec(smd *SetMealDetail) *ProductSpecQuery {
	query := (&ProductSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := smd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setmealdetail.Table, setmealdetail.FieldID, id),
			sqlgraph.To(productspec.Table, productspec.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, setmealdetail.ProductSpecTable, setmealdetail.ProductSpecColumn),
		)
		fromV = sqlgraph.Neighbors(smd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SetMealDetailClient) Hooks() []Hook {
	hooks := c.hooks.SetMealDetail
	return append(hooks[:len(hooks):len(hooks)], setmealdetail.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SetMealDetailClient) Interceptors() []Interceptor {
	inters := c.inters.SetMealDetail
	return append(inters[:len(inters):len(inters)], setmealdetail.Interceptors[:]...)
}

func (c *SetMealDetailClient) mutate(ctx context.Context, m *SetMealDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SetMealDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SetMealDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SetMealDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SetMealDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SetMealDetail mutation op: %q", m.Op())
	}
}

// SpecClient is a client for the Spec schema.
type SpecClient struct {
	config
}

// NewSpecClient returns a client for the Spec from the given config.
func NewSpecClient(c config) *SpecClient {
	return &SpecClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spec.Hooks(f(g(h())))`.
func (c *SpecClient) Use(hooks ...Hook) {
	c.hooks.Spec = append(c.hooks.Spec, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spec.Intercept(f(g(h())))`.
func (c *SpecClient) Intercept(interceptors ...Interceptor) {
	c.inters.Spec = append(c.inters.Spec, interceptors...)
}

// Create returns a builder for creating a Spec entity.
func (c *SpecClient) Create() *SpecCreate {
	mutation := newSpecMutation(c.config, OpCreate)
	return &SpecCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Spec entities.
func (c *SpecClient) CreateBulk(builders ...*SpecCreate) *SpecCreateBulk {
	return &SpecCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpecClient) MapCreateBulk(slice any, setFunc func(*SpecCreate, int)) *SpecCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpecCreateBulk{err: fmt.Errorf("calling to SpecClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpecCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpecCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Spec.
func (c *SpecClient) Update() *SpecUpdate {
	mutation := newSpecMutation(c.config, OpUpdate)
	return &SpecUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpecClient) UpdateOne(s *Spec) *SpecUpdateOne {
	mutation := newSpecMutation(c.config, OpUpdateOne, withSpec(s))
	return &SpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpecClient) UpdateOneID(id int) *SpecUpdateOne {
	mutation := newSpecMutation(c.config, OpUpdateOne, withSpecID(id))
	return &SpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Spec.
func (c *SpecClient) Delete() *SpecDelete {
	mutation := newSpecMutation(c.config, OpDelete)
	return &SpecDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpecClient) DeleteOne(s *Spec) *SpecDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpecClient) DeleteOneID(id int) *SpecDeleteOne {
	builder := c.Delete().Where(spec.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpecDeleteOne{builder}
}

// Query returns a query builder for Spec.
func (c *SpecClient) Query() *SpecQuery {
	return &SpecQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpec},
		inters: c.Interceptors(),
	}
}

// Get returns a Spec entity by its id.
func (c *SpecClient) Get(ctx context.Context, id int) (*Spec, error) {
	return c.Query().Where(spec.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpecClient) GetX(ctx context.Context, id int) *Spec {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductSpecs queries the product_specs edge of a Spec.
func (c *SpecClient) QueryProductSpecs(s *Spec) *ProductSpecQuery {
	query := (&ProductSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(spec.Table, spec.FieldID, id),
			sqlgraph.To(productspec.Table, productspec.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, spec.ProductSpecsTable, spec.ProductSpecsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SpecClient) Hooks() []Hook {
	hooks := c.hooks.Spec
	return append(hooks[:len(hooks):len(hooks)], spec.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SpecClient) Interceptors() []Interceptor {
	inters := c.inters.Spec
	return append(inters[:len(inters):len(inters)], spec.Interceptors[:]...)
}

func (c *SpecClient) mutate(ctx context.Context, m *SpecMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpecCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpecUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpecDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Spec mutation op: %q", m.Op())
	}
}

// StoreClient is a client for the Store schema.
type StoreClient struct {
	config
}

// NewStoreClient returns a client for the Store from the given config.
func NewStoreClient(c config) *StoreClient {
	return &StoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `store.Hooks(f(g(h())))`.
func (c *StoreClient) Use(hooks ...Hook) {
	c.hooks.Store = append(c.hooks.Store, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `store.Intercept(f(g(h())))`.
func (c *StoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.Store = append(c.inters.Store, interceptors...)
}

// Create returns a builder for creating a Store entity.
func (c *StoreClient) Create() *StoreCreate {
	mutation := newStoreMutation(c.config, OpCreate)
	return &StoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Store entities.
func (c *StoreClient) CreateBulk(builders ...*StoreCreate) *StoreCreateBulk {
	return &StoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoreClient) MapCreateBulk(slice any, setFunc func(*StoreCreate, int)) *StoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoreCreateBulk{err: fmt.Errorf("calling to StoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Store.
func (c *StoreClient) Update() *StoreUpdate {
	mutation := newStoreMutation(c.config, OpUpdate)
	return &StoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoreClient) UpdateOne(s *Store) *StoreUpdateOne {
	mutation := newStoreMutation(c.config, OpUpdateOne, withStore(s))
	return &StoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoreClient) UpdateOneID(id int) *StoreUpdateOne {
	mutation := newStoreMutation(c.config, OpUpdateOne, withStoreID(id))
	return &StoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Store.
func (c *StoreClient) Delete() *StoreDelete {
	mutation := newStoreMutation(c.config, OpDelete)
	return &StoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoreClient) DeleteOne(s *Store) *StoreDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoreClient) DeleteOneID(id int) *StoreDeleteOne {
	builder := c.Delete().Where(store.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoreDeleteOne{builder}
}

// Query returns a query builder for Store.
func (c *StoreClient) Query() *StoreQuery {
	return &StoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStore},
		inters: c.Interceptors(),
	}
}

// Get returns a Store entity by its id.
func (c *StoreClient) Get(ctx context.Context, id int) (*Store, error) {
	return c.Query().Where(store.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoreClient) GetX(ctx context.Context, id int) *Store {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackendUser queries the backend_user edge of a Store.
func (c *StoreClient) QueryBackendUser(s *Store) *BackendUserQuery {
	query := (&BackendUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(backenduser.Table, backenduser.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, store.BackendUserTable, store.BackendUserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFrontendUsers queries the frontend_users edge of a Store.
func (c *StoreClient) QueryFrontendUsers(s *Store) *FrontendUserQuery {
	query := (&FrontendUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(frontenduser.Table, frontenduser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, store.FrontendUsersTable, store.FrontendUsersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStoreInfo queries the store_info edge of a Store.
func (c *StoreClient) QueryStoreInfo(s *Store) *StoreInfoQuery {
	query := (&StoreInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(storeinfo.Table, storeinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, store.StoreInfoTable, store.StoreInfoColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStoreFinance queries the store_finance edge of a Store.
func (c *StoreClient) QueryStoreFinance(s *Store) *StoreFinanceQuery {
	query := (&StoreFinanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(storefinance.Table, storefinance.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, store.StoreFinanceTable, store.StoreFinanceColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStoreAccount queries the store_account edge of a Store.
func (c *StoreClient) QueryStoreAccount(s *Store) *StoreAccountQuery {
	query := (&StoreAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(storeaccount.Table, storeaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, store.StoreAccountTable, store.StoreAccountColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStoreWithdraws queries the store_withdraws edge of a Store.
func (c *StoreClient) QueryStoreWithdraws(s *Store) *StoreWithdrawQuery {
	query := (&StoreWithdrawClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(storewithdraw.Table, storewithdraw.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, store.StoreWithdrawsTable, store.StoreWithdrawsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStoreAccountTransactions queries the store_account_transactions edge of a Store.
func (c *StoreClient) QueryStoreAccountTransactions(s *Store) *StoreAccountTransactionQuery {
	query := (&StoreAccountTransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(store.Table, store.FieldID, id),
			sqlgraph.To(storeaccounttransaction.Table, storeaccounttransaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, store.StoreAccountTransactionsTable, store.StoreAccountTransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StoreClient) Hooks() []Hook {
	hooks := c.hooks.Store
	return append(hooks[:len(hooks):len(hooks)], store.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StoreClient) Interceptors() []Interceptor {
	inters := c.inters.Store
	return append(inters[:len(inters):len(inters)], store.Interceptors[:]...)
}

func (c *StoreClient) mutate(ctx context.Context, m *StoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Store mutation op: %q", m.Op())
	}
}

// StoreAccountClient is a client for the StoreAccount schema.
type StoreAccountClient struct {
	config
}

// NewStoreAccountClient returns a client for the StoreAccount from the given config.
func NewStoreAccountClient(c config) *StoreAccountClient {
	return &StoreAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storeaccount.Hooks(f(g(h())))`.
func (c *StoreAccountClient) Use(hooks ...Hook) {
	c.hooks.StoreAccount = append(c.hooks.StoreAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storeaccount.Intercept(f(g(h())))`.
func (c *StoreAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.StoreAccount = append(c.inters.StoreAccount, interceptors...)
}

// Create returns a builder for creating a StoreAccount entity.
func (c *StoreAccountClient) Create() *StoreAccountCreate {
	mutation := newStoreAccountMutation(c.config, OpCreate)
	return &StoreAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StoreAccount entities.
func (c *StoreAccountClient) CreateBulk(builders ...*StoreAccountCreate) *StoreAccountCreateBulk {
	return &StoreAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoreAccountClient) MapCreateBulk(slice any, setFunc func(*StoreAccountCreate, int)) *StoreAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoreAccountCreateBulk{err: fmt.Errorf("calling to StoreAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoreAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoreAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StoreAccount.
func (c *StoreAccountClient) Update() *StoreAccountUpdate {
	mutation := newStoreAccountMutation(c.config, OpUpdate)
	return &StoreAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoreAccountClient) UpdateOne(sa *StoreAccount) *StoreAccountUpdateOne {
	mutation := newStoreAccountMutation(c.config, OpUpdateOne, withStoreAccount(sa))
	return &StoreAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoreAccountClient) UpdateOneID(id int) *StoreAccountUpdateOne {
	mutation := newStoreAccountMutation(c.config, OpUpdateOne, withStoreAccountID(id))
	return &StoreAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StoreAccount.
func (c *StoreAccountClient) Delete() *StoreAccountDelete {
	mutation := newStoreAccountMutation(c.config, OpDelete)
	return &StoreAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoreAccountClient) DeleteOne(sa *StoreAccount) *StoreAccountDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoreAccountClient) DeleteOneID(id int) *StoreAccountDeleteOne {
	builder := c.Delete().Where(storeaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoreAccountDeleteOne{builder}
}

// Query returns a query builder for StoreAccount.
func (c *StoreAccountClient) Query() *StoreAccountQuery {
	return &StoreAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStoreAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a StoreAccount entity by its id.
func (c *StoreAccountClient) Get(ctx context.Context, id int) (*StoreAccount, error) {
	return c.Query().Where(storeaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoreAccountClient) GetX(ctx context.Context, id int) *StoreAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a StoreAccount.
func (c *StoreAccountClient) QueryStore(sa *StoreAccount) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(storeaccount.Table, storeaccount.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, storeaccount.StoreTable, storeaccount.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StoreAccountClient) Hooks() []Hook {
	hooks := c.hooks.StoreAccount
	return append(hooks[:len(hooks):len(hooks)], storeaccount.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StoreAccountClient) Interceptors() []Interceptor {
	inters := c.inters.StoreAccount
	return append(inters[:len(inters):len(inters)], storeaccount.Interceptors[:]...)
}

func (c *StoreAccountClient) mutate(ctx context.Context, m *StoreAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoreAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoreAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoreAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoreAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StoreAccount mutation op: %q", m.Op())
	}
}

// StoreAccountTransactionClient is a client for the StoreAccountTransaction schema.
type StoreAccountTransactionClient struct {
	config
}

// NewStoreAccountTransactionClient returns a client for the StoreAccountTransaction from the given config.
func NewStoreAccountTransactionClient(c config) *StoreAccountTransactionClient {
	return &StoreAccountTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storeaccounttransaction.Hooks(f(g(h())))`.
func (c *StoreAccountTransactionClient) Use(hooks ...Hook) {
	c.hooks.StoreAccountTransaction = append(c.hooks.StoreAccountTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storeaccounttransaction.Intercept(f(g(h())))`.
func (c *StoreAccountTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.StoreAccountTransaction = append(c.inters.StoreAccountTransaction, interceptors...)
}

// Create returns a builder for creating a StoreAccountTransaction entity.
func (c *StoreAccountTransactionClient) Create() *StoreAccountTransactionCreate {
	mutation := newStoreAccountTransactionMutation(c.config, OpCreate)
	return &StoreAccountTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StoreAccountTransaction entities.
func (c *StoreAccountTransactionClient) CreateBulk(builders ...*StoreAccountTransactionCreate) *StoreAccountTransactionCreateBulk {
	return &StoreAccountTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoreAccountTransactionClient) MapCreateBulk(slice any, setFunc func(*StoreAccountTransactionCreate, int)) *StoreAccountTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoreAccountTransactionCreateBulk{err: fmt.Errorf("calling to StoreAccountTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoreAccountTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoreAccountTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StoreAccountTransaction.
func (c *StoreAccountTransactionClient) Update() *StoreAccountTransactionUpdate {
	mutation := newStoreAccountTransactionMutation(c.config, OpUpdate)
	return &StoreAccountTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoreAccountTransactionClient) UpdateOne(sat *StoreAccountTransaction) *StoreAccountTransactionUpdateOne {
	mutation := newStoreAccountTransactionMutation(c.config, OpUpdateOne, withStoreAccountTransaction(sat))
	return &StoreAccountTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoreAccountTransactionClient) UpdateOneID(id int) *StoreAccountTransactionUpdateOne {
	mutation := newStoreAccountTransactionMutation(c.config, OpUpdateOne, withStoreAccountTransactionID(id))
	return &StoreAccountTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StoreAccountTransaction.
func (c *StoreAccountTransactionClient) Delete() *StoreAccountTransactionDelete {
	mutation := newStoreAccountTransactionMutation(c.config, OpDelete)
	return &StoreAccountTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoreAccountTransactionClient) DeleteOne(sat *StoreAccountTransaction) *StoreAccountTransactionDeleteOne {
	return c.DeleteOneID(sat.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoreAccountTransactionClient) DeleteOneID(id int) *StoreAccountTransactionDeleteOne {
	builder := c.Delete().Where(storeaccounttransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoreAccountTransactionDeleteOne{builder}
}

// Query returns a query builder for StoreAccountTransaction.
func (c *StoreAccountTransactionClient) Query() *StoreAccountTransactionQuery {
	return &StoreAccountTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStoreAccountTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a StoreAccountTransaction entity by its id.
func (c *StoreAccountTransactionClient) Get(ctx context.Context, id int) (*StoreAccountTransaction, error) {
	return c.Query().Where(storeaccounttransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoreAccountTransactionClient) GetX(ctx context.Context, id int) *StoreAccountTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a StoreAccountTransaction.
func (c *StoreAccountTransactionClient) QueryStore(sat *StoreAccountTransaction) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(storeaccounttransaction.Table, storeaccounttransaction.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, storeaccounttransaction.StoreTable, storeaccounttransaction.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(sat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StoreAccountTransactionClient) Hooks() []Hook {
	hooks := c.hooks.StoreAccountTransaction
	return append(hooks[:len(hooks):len(hooks)], storeaccounttransaction.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StoreAccountTransactionClient) Interceptors() []Interceptor {
	inters := c.inters.StoreAccountTransaction
	return append(inters[:len(inters):len(inters)], storeaccounttransaction.Interceptors[:]...)
}

func (c *StoreAccountTransactionClient) mutate(ctx context.Context, m *StoreAccountTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoreAccountTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoreAccountTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoreAccountTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoreAccountTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StoreAccountTransaction mutation op: %q", m.Op())
	}
}

// StoreFinanceClient is a client for the StoreFinance schema.
type StoreFinanceClient struct {
	config
}

// NewStoreFinanceClient returns a client for the StoreFinance from the given config.
func NewStoreFinanceClient(c config) *StoreFinanceClient {
	return &StoreFinanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storefinance.Hooks(f(g(h())))`.
func (c *StoreFinanceClient) Use(hooks ...Hook) {
	c.hooks.StoreFinance = append(c.hooks.StoreFinance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storefinance.Intercept(f(g(h())))`.
func (c *StoreFinanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.StoreFinance = append(c.inters.StoreFinance, interceptors...)
}

// Create returns a builder for creating a StoreFinance entity.
func (c *StoreFinanceClient) Create() *StoreFinanceCreate {
	mutation := newStoreFinanceMutation(c.config, OpCreate)
	return &StoreFinanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StoreFinance entities.
func (c *StoreFinanceClient) CreateBulk(builders ...*StoreFinanceCreate) *StoreFinanceCreateBulk {
	return &StoreFinanceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoreFinanceClient) MapCreateBulk(slice any, setFunc func(*StoreFinanceCreate, int)) *StoreFinanceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoreFinanceCreateBulk{err: fmt.Errorf("calling to StoreFinanceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoreFinanceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoreFinanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StoreFinance.
func (c *StoreFinanceClient) Update() *StoreFinanceUpdate {
	mutation := newStoreFinanceMutation(c.config, OpUpdate)
	return &StoreFinanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoreFinanceClient) UpdateOne(sf *StoreFinance) *StoreFinanceUpdateOne {
	mutation := newStoreFinanceMutation(c.config, OpUpdateOne, withStoreFinance(sf))
	return &StoreFinanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoreFinanceClient) UpdateOneID(id int) *StoreFinanceUpdateOne {
	mutation := newStoreFinanceMutation(c.config, OpUpdateOne, withStoreFinanceID(id))
	return &StoreFinanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StoreFinance.
func (c *StoreFinanceClient) Delete() *StoreFinanceDelete {
	mutation := newStoreFinanceMutation(c.config, OpDelete)
	return &StoreFinanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoreFinanceClient) DeleteOne(sf *StoreFinance) *StoreFinanceDeleteOne {
	return c.DeleteOneID(sf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoreFinanceClient) DeleteOneID(id int) *StoreFinanceDeleteOne {
	builder := c.Delete().Where(storefinance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoreFinanceDeleteOne{builder}
}

// Query returns a query builder for StoreFinance.
func (c *StoreFinanceClient) Query() *StoreFinanceQuery {
	return &StoreFinanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStoreFinance},
		inters: c.Interceptors(),
	}
}

// Get returns a StoreFinance entity by its id.
func (c *StoreFinanceClient) Get(ctx context.Context, id int) (*StoreFinance, error) {
	return c.Query().Where(storefinance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoreFinanceClient) GetX(ctx context.Context, id int) *StoreFinance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a StoreFinance.
func (c *StoreFinanceClient) QueryStore(sf *StoreFinance) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(storefinance.Table, storefinance.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, storefinance.StoreTable, storefinance.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(sf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StoreFinanceClient) Hooks() []Hook {
	return c.hooks.StoreFinance
}

// Interceptors returns the client interceptors.
func (c *StoreFinanceClient) Interceptors() []Interceptor {
	return c.inters.StoreFinance
}

func (c *StoreFinanceClient) mutate(ctx context.Context, m *StoreFinanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoreFinanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoreFinanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoreFinanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoreFinanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StoreFinance mutation op: %q", m.Op())
	}
}

// StoreInfoClient is a client for the StoreInfo schema.
type StoreInfoClient struct {
	config
}

// NewStoreInfoClient returns a client for the StoreInfo from the given config.
func NewStoreInfoClient(c config) *StoreInfoClient {
	return &StoreInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storeinfo.Hooks(f(g(h())))`.
func (c *StoreInfoClient) Use(hooks ...Hook) {
	c.hooks.StoreInfo = append(c.hooks.StoreInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storeinfo.Intercept(f(g(h())))`.
func (c *StoreInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.StoreInfo = append(c.inters.StoreInfo, interceptors...)
}

// Create returns a builder for creating a StoreInfo entity.
func (c *StoreInfoClient) Create() *StoreInfoCreate {
	mutation := newStoreInfoMutation(c.config, OpCreate)
	return &StoreInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StoreInfo entities.
func (c *StoreInfoClient) CreateBulk(builders ...*StoreInfoCreate) *StoreInfoCreateBulk {
	return &StoreInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoreInfoClient) MapCreateBulk(slice any, setFunc func(*StoreInfoCreate, int)) *StoreInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoreInfoCreateBulk{err: fmt.Errorf("calling to StoreInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoreInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoreInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StoreInfo.
func (c *StoreInfoClient) Update() *StoreInfoUpdate {
	mutation := newStoreInfoMutation(c.config, OpUpdate)
	return &StoreInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoreInfoClient) UpdateOne(si *StoreInfo) *StoreInfoUpdateOne {
	mutation := newStoreInfoMutation(c.config, OpUpdateOne, withStoreInfo(si))
	return &StoreInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoreInfoClient) UpdateOneID(id int) *StoreInfoUpdateOne {
	mutation := newStoreInfoMutation(c.config, OpUpdateOne, withStoreInfoID(id))
	return &StoreInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StoreInfo.
func (c *StoreInfoClient) Delete() *StoreInfoDelete {
	mutation := newStoreInfoMutation(c.config, OpDelete)
	return &StoreInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoreInfoClient) DeleteOne(si *StoreInfo) *StoreInfoDeleteOne {
	return c.DeleteOneID(si.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoreInfoClient) DeleteOneID(id int) *StoreInfoDeleteOne {
	builder := c.Delete().Where(storeinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoreInfoDeleteOne{builder}
}

// Query returns a query builder for StoreInfo.
func (c *StoreInfoClient) Query() *StoreInfoQuery {
	return &StoreInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStoreInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a StoreInfo entity by its id.
func (c *StoreInfoClient) Get(ctx context.Context, id int) (*StoreInfo, error) {
	return c.Query().Where(storeinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoreInfoClient) GetX(ctx context.Context, id int) *StoreInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a StoreInfo.
func (c *StoreInfoClient) QueryStore(si *StoreInfo) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := si.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(storeinfo.Table, storeinfo.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, storeinfo.StoreTable, storeinfo.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(si.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StoreInfoClient) Hooks() []Hook {
	return c.hooks.StoreInfo
}

// Interceptors returns the client interceptors.
func (c *StoreInfoClient) Interceptors() []Interceptor {
	return c.inters.StoreInfo
}

func (c *StoreInfoClient) mutate(ctx context.Context, m *StoreInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoreInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoreInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoreInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoreInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StoreInfo mutation op: %q", m.Op())
	}
}

// StoreWithdrawClient is a client for the StoreWithdraw schema.
type StoreWithdrawClient struct {
	config
}

// NewStoreWithdrawClient returns a client for the StoreWithdraw from the given config.
func NewStoreWithdrawClient(c config) *StoreWithdrawClient {
	return &StoreWithdrawClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storewithdraw.Hooks(f(g(h())))`.
func (c *StoreWithdrawClient) Use(hooks ...Hook) {
	c.hooks.StoreWithdraw = append(c.hooks.StoreWithdraw, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storewithdraw.Intercept(f(g(h())))`.
func (c *StoreWithdrawClient) Intercept(interceptors ...Interceptor) {
	c.inters.StoreWithdraw = append(c.inters.StoreWithdraw, interceptors...)
}

// Create returns a builder for creating a StoreWithdraw entity.
func (c *StoreWithdrawClient) Create() *StoreWithdrawCreate {
	mutation := newStoreWithdrawMutation(c.config, OpCreate)
	return &StoreWithdrawCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StoreWithdraw entities.
func (c *StoreWithdrawClient) CreateBulk(builders ...*StoreWithdrawCreate) *StoreWithdrawCreateBulk {
	return &StoreWithdrawCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StoreWithdrawClient) MapCreateBulk(slice any, setFunc func(*StoreWithdrawCreate, int)) *StoreWithdrawCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StoreWithdrawCreateBulk{err: fmt.Errorf("calling to StoreWithdrawClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StoreWithdrawCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StoreWithdrawCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StoreWithdraw.
func (c *StoreWithdrawClient) Update() *StoreWithdrawUpdate {
	mutation := newStoreWithdrawMutation(c.config, OpUpdate)
	return &StoreWithdrawUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StoreWithdrawClient) UpdateOne(sw *StoreWithdraw) *StoreWithdrawUpdateOne {
	mutation := newStoreWithdrawMutation(c.config, OpUpdateOne, withStoreWithdraw(sw))
	return &StoreWithdrawUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StoreWithdrawClient) UpdateOneID(id int) *StoreWithdrawUpdateOne {
	mutation := newStoreWithdrawMutation(c.config, OpUpdateOne, withStoreWithdrawID(id))
	return &StoreWithdrawUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StoreWithdraw.
func (c *StoreWithdrawClient) Delete() *StoreWithdrawDelete {
	mutation := newStoreWithdrawMutation(c.config, OpDelete)
	return &StoreWithdrawDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StoreWithdrawClient) DeleteOne(sw *StoreWithdraw) *StoreWithdrawDeleteOne {
	return c.DeleteOneID(sw.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StoreWithdrawClient) DeleteOneID(id int) *StoreWithdrawDeleteOne {
	builder := c.Delete().Where(storewithdraw.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StoreWithdrawDeleteOne{builder}
}

// Query returns a query builder for StoreWithdraw.
func (c *StoreWithdrawClient) Query() *StoreWithdrawQuery {
	return &StoreWithdrawQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStoreWithdraw},
		inters: c.Interceptors(),
	}
}

// Get returns a StoreWithdraw entity by its id.
func (c *StoreWithdrawClient) Get(ctx context.Context, id int) (*StoreWithdraw, error) {
	return c.Query().Where(storewithdraw.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StoreWithdrawClient) GetX(ctx context.Context, id int) *StoreWithdraw {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStore queries the store edge of a StoreWithdraw.
func (c *StoreWithdrawClient) QueryStore(sw *StoreWithdraw) *StoreQuery {
	query := (&StoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sw.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(storewithdraw.Table, storewithdraw.FieldID, id),
			sqlgraph.To(store.Table, store.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, storewithdraw.StoreTable, storewithdraw.StoreColumn),
		)
		fromV = sqlgraph.Neighbors(sw.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StoreWithdrawClient) Hooks() []Hook {
	hooks := c.hooks.StoreWithdraw
	return append(hooks[:len(hooks):len(hooks)], storewithdraw.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StoreWithdrawClient) Interceptors() []Interceptor {
	inters := c.inters.StoreWithdraw
	return append(inters[:len(inters):len(inters)], storewithdraw.Interceptors[:]...)
}

func (c *StoreWithdrawClient) mutate(ctx context.Context, m *StoreWithdrawMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StoreWithdrawCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StoreWithdrawUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StoreWithdrawUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StoreWithdrawDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StoreWithdraw mutation op: %q", m.Op())
	}
}

// TableAreaClient is a client for the TableArea schema.
type TableAreaClient struct {
	config
}

// NewTableAreaClient returns a client for the TableArea from the given config.
func NewTableAreaClient(c config) *TableAreaClient {
	return &TableAreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tablearea.Hooks(f(g(h())))`.
func (c *TableAreaClient) Use(hooks ...Hook) {
	c.hooks.TableArea = append(c.hooks.TableArea, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tablearea.Intercept(f(g(h())))`.
func (c *TableAreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.TableArea = append(c.inters.TableArea, interceptors...)
}

// Create returns a builder for creating a TableArea entity.
func (c *TableAreaClient) Create() *TableAreaCreate {
	mutation := newTableAreaMutation(c.config, OpCreate)
	return &TableAreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TableArea entities.
func (c *TableAreaClient) CreateBulk(builders ...*TableAreaCreate) *TableAreaCreateBulk {
	return &TableAreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TableAreaClient) MapCreateBulk(slice any, setFunc func(*TableAreaCreate, int)) *TableAreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TableAreaCreateBulk{err: fmt.Errorf("calling to TableAreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TableAreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TableAreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TableArea.
func (c *TableAreaClient) Update() *TableAreaUpdate {
	mutation := newTableAreaMutation(c.config, OpUpdate)
	return &TableAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TableAreaClient) UpdateOne(ta *TableArea) *TableAreaUpdateOne {
	mutation := newTableAreaMutation(c.config, OpUpdateOne, withTableArea(ta))
	return &TableAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TableAreaClient) UpdateOneID(id int) *TableAreaUpdateOne {
	mutation := newTableAreaMutation(c.config, OpUpdateOne, withTableAreaID(id))
	return &TableAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TableArea.
func (c *TableAreaClient) Delete() *TableAreaDelete {
	mutation := newTableAreaMutation(c.config, OpDelete)
	return &TableAreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TableAreaClient) DeleteOne(ta *TableArea) *TableAreaDeleteOne {
	return c.DeleteOneID(ta.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TableAreaClient) DeleteOneID(id int) *TableAreaDeleteOne {
	builder := c.Delete().Where(tablearea.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TableAreaDeleteOne{builder}
}

// Query returns a query builder for TableArea.
func (c *TableAreaClient) Query() *TableAreaQuery {
	return &TableAreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTableArea},
		inters: c.Interceptors(),
	}
}

// Get returns a TableArea entity by its id.
func (c *TableAreaClient) Get(ctx context.Context, id int) (*TableArea, error) {
	return c.Query().Where(tablearea.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TableAreaClient) GetX(ctx context.Context, id int) *TableArea {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDinetables queries the dinetables edge of a TableArea.
func (c *TableAreaClient) QueryDinetables(ta *TableArea) *DineTableQuery {
	query := (&DineTableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ta.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tablearea.Table, tablearea.FieldID, id),
			sqlgraph.To(dinetable.Table, dinetable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tablearea.DinetablesTable, tablearea.DinetablesColumn),
		)
		fromV = sqlgraph.Neighbors(ta.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TableAreaClient) Hooks() []Hook {
	hooks := c.hooks.TableArea
	return append(hooks[:len(hooks):len(hooks)], tablearea.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TableAreaClient) Interceptors() []Interceptor {
	inters := c.inters.TableArea
	return append(inters[:len(inters):len(inters)], tablearea.Interceptors[:]...)
}

func (c *TableAreaClient) mutate(ctx context.Context, m *TableAreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TableAreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TableAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TableAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TableAreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TableArea mutation op: %q", m.Op())
	}
}

// UnitClient is a client for the Unit schema.
type UnitClient struct {
	config
}

// NewUnitClient returns a client for the Unit from the given config.
func NewUnitClient(c config) *UnitClient {
	return &UnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `unit.Hooks(f(g(h())))`.
func (c *UnitClient) Use(hooks ...Hook) {
	c.hooks.Unit = append(c.hooks.Unit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `unit.Intercept(f(g(h())))`.
func (c *UnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Unit = append(c.inters.Unit, interceptors...)
}

// Create returns a builder for creating a Unit entity.
func (c *UnitClient) Create() *UnitCreate {
	mutation := newUnitMutation(c.config, OpCreate)
	return &UnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Unit entities.
func (c *UnitClient) CreateBulk(builders ...*UnitCreate) *UnitCreateBulk {
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UnitClient) MapCreateBulk(slice any, setFunc func(*UnitCreate, int)) *UnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UnitCreateBulk{err: fmt.Errorf("calling to UnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Unit.
func (c *UnitClient) Update() *UnitUpdate {
	mutation := newUnitMutation(c.config, OpUpdate)
	return &UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UnitClient) UpdateOne(u *Unit) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnit(u))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UnitClient) UpdateOneID(id int) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnitID(id))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Unit.
func (c *UnitClient) Delete() *UnitDelete {
	mutation := newUnitMutation(c.config, OpDelete)
	return &UnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UnitClient) DeleteOne(u *Unit) *UnitDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UnitClient) DeleteOneID(id int) *UnitDeleteOne {
	builder := c.Delete().Where(unit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UnitDeleteOne{builder}
}

// Query returns a query builder for Unit.
func (c *UnitClient) Query() *UnitQuery {
	return &UnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a Unit entity by its id.
func (c *UnitClient) Get(ctx context.Context, id int) (*Unit, error) {
	return c.Query().Where(unit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UnitClient) GetX(ctx context.Context, id int) *Unit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Unit.
func (c *UnitClient) QueryProducts(u *Unit) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, unit.ProductsTable, unit.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UnitClient) Hooks() []Hook {
	hooks := c.hooks.Unit
	return append(hooks[:len(hooks):len(hooks)], unit.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UnitClient) Interceptors() []Interceptor {
	inters := c.inters.Unit
	return append(inters[:len(inters):len(inters)], unit.Interceptors[:]...)
}

func (c *UnitClient) mutate(ctx context.Context, m *UnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Unit mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AdminUser, Attr, BackendUser, Category, Customer, DataExport, DineTable,
		FrontendUser, Order, OrderCart, OrderFinanceLog, OrderItem,
		OrderItemSetMealDetail, OrderLog, Payment, PaymentCallback, PointSettlement,
		Product, ProductSpec, Recipe, ReconciliationRecord, SetMealDetail, Spec, Store,
		StoreAccount, StoreAccountTransaction, StoreFinance, StoreInfo, StoreWithdraw,
		TableArea, Unit []ent.Hook
	}
	inters struct {
		AdminUser, Attr, BackendUser, Category, Customer, DataExport, DineTable,
		FrontendUser, Order, OrderCart, OrderFinanceLog, OrderItem,
		OrderItemSetMealDetail, OrderLog, Payment, PaymentCallback, PointSettlement,
		Product, ProductSpec, Recipe, ReconciliationRecord, SetMealDetail, Spec, Store,
		StoreAccount, StoreAccountTransaction, StoreFinance, StoreInfo, StoreWithdraw,
		TableArea, Unit []ent.Interceptor
	}
)
